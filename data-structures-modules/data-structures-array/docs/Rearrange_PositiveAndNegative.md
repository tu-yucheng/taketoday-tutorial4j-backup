## 1. 问题描述

数组包含随机顺序的正数和负数。重新排列数组元素，以便交替放置正数和负数。正数和负数的数目不必相等。
如果有更多的正数，它们将放置在数组的末尾。如果有更多的负数，它们也会放置在数组的末尾。
例如，如果输入数组为[-1、2、-3、4、5、6、-7、8、9]，则输出应为[9、-7、8、-3、5、-1、2、4、6]。

注意：分区过程改变了元素的相对顺序。这种方法不能保持元素出现的顺序。解决方法是首先使用快速排序的分区过程将正数和负数分开。
在分区过程中，将0视为pivot元素的值，以便将所有负数放在正数之前。将负数和正数分开后，我们就从第一个负数和第一个正数开始，将每个交替的负数与下一个正数交换。

## 2. 算法实现

```java
public class PositiveNegativeSplit {

  public static void rearrange(int[] arr, int n) {
    // 下面几行类似于QuickSort的分区过程。这个想法是将0视为pivot并围绕它划分数组。
    int i = -1, temp;
    for (int j = 0; j < n; j++) {
      if (arr[j] < 0) {
        i++;
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
    }

    // 现在所有正数都在数组的末尾，负数在数组的开头。初始化要交换的正负数起点的索引
    int pos = i + 1, neg = 0;

    // 将负索引加2，正索引加1，即将每个交替的负数与下一个正数交换
    while (pos < n && neg < pos && arr[neg] < 0) {
      temp = arr[neg];
      arr[neg] = arr[pos];
      arr[pos] = temp;
      pos++;
      neg += 2;
    }
  }
}
```

时间复杂度：O(n)，其中n是给定数组中的元素个数。

辅助空间：O(1)，我们没有使用任何额外的空间。

## 3. 扩展

给定一组正数和负数，以交替方式排列它们，使每个正数后面跟着负数，反之亦然，保持原始数组元素出现的顺序。

正数和负数的数目不必相等。如果有更多的正数，它们将出现在数组的末尾。如果有更多的负数，它们也会出现在数组的末尾。

示例：

```
输入: arr[] = {1, 2, 3, -4, -1, 4}
输出: arr[] = {-4, 1, -1, 2, 3, 4}

输入: arr[] = {-5, -2, 5, 2, 4, 7, 1, 8, 0, -8}
输出: arr[] = {-5, 5, -2, 2, -8, 4, 7, 1, 8, 0}
```

## 4. 算法实现

如果允许O(n)的额外空间，上述问题可以很容易地解决。由于O(1)空间和出现顺序的限制，这似乎变得更棘手。

其思想是从左到右处理数组。在处理时，在剩余的未处理数组中找到第一个不合适的元素。如果元素为负且位于奇数索引(基于0的索引)，
或者它为正且位于偶数索引，则元素不合适。一旦我们找到一个不合适的元素，我们就会找到它之后的第一个符号相反元素。
我们在这两个元素(包括这两个元素)之间右旋子数组。

以下是上述想法的具体实现：

