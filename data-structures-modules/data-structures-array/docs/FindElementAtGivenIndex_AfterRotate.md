## 1. 问题描述

给出了一个由N个整数组成的数组。我们执行几个范围为[L...R]的右旋转。在执行这些旋转之后，我们需要找到给定索引处的元素。

示例：

```
输入: arr[] = {1, 2, 3, 4, 5}
     ranges[] = {{0, 2}, {0, 3}}
     index : 1
输出: 3
解释: 在第一次给定旋转{0, 2}之后arr[] = {3, 1, 2, 4, 5}
     在第二次旋转{0, 3}后arr[] = {4, 3, 1, 2, 5}
在所有旋转之后，给定索引1处的元素为3。
```

## 2. 算法实现

暴力破解：暴力解法实际上是在所有给定范围内旋转数组，最后返回修改后数组中给定索引处的元素。

另一种高效的方法是我们可以在保存所有范围后进行离线处理。假设我们的旋转范围是：[0...2]和[0...3]。

我们从反向运行这些旋转。

在范围[0...3]之后，索引0将具有索引3上的元素。因此，我们可以将0更改为3，即，如果index=left，索引将更改为right。
在范围[0...2]之后，索引3将保持不受影响。

所以，我们可以做3种情况：

如果index=left，index将更改为right。
如果index不受范围限制，则旋转不会产生任何影响。
如果index在范围内，则index将具有index-1处的元素。具体情况如下：

为了更好地解释：

```
10 20 30 40 50
Index: 1
Rotations: {0,2} {1,4} {0,3}
答案：索引1在按{0,2} {1,4} {0,3}的顺序所有3次旋转后的值为30。

我们在A上执行了{0,2}，现在我们有了一个新的数组A1。
我们在A1上执行了{1,4}，现在我们有了一个新的数组A2。
我们在A2上执行了{0,3}，现在我们有了一个新的数组A3。
现在我们寻找A3中索引1处的值。
但是A3是在A2上完成的{0,3}。
所以A3中的索引1是A2中的索引0。
但是A2是在A1上完成的{1,4}。
因此A2中的索引0也是A1中的索引0，因为它不在{1,4}范围内。
但是A1是在A上完成的{0,2}。
所以A1中的索引0是A中的索引2。
通过观察，我们将从最近的旋转开始，到之前的旋转。

{0,3}
  |
{1,4}
  |
{0,2}

这就是我们以相反顺序处理旋转的原因。
请注意，我们并没有按相反的顺序旋转元素，只是从相反的方向处理索引。
因为如果我们实际上以相反的顺序旋转，我们可能会得到一个完全不同的答案，因为在旋转的情况下，顺序很重要。
```

以下为具体实现：

```java
public class FindElement {

  public static int findElement(int[] arr, int[][] ranges, int rotations, int index) {
    for (int i = rotations - 1; i >= 0; i--) {
      int left = ranges[i][0];
      int right = ranges[i][1];
      if (left <= index && right >= index)
        if (index == left)
          index = right;
        else
          index--;
    }
    return arr[index];
  }
}
```