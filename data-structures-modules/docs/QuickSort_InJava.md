## 1. 概述

在本文中，我们将详细介绍快速排序算法，重点介绍其Java实现。

我们还将介绍其优缺点，然后分析其时间复杂度。

## 2. 快速排序算法

快速排序是一种利用分而治之思想的排序算法。它的平均复杂度为O(nlog n)，是最常用的排序算法之一，尤其是对于大数据量。

重要的是记住快速排序不是一种稳定的算法。稳定排序算法是一种算法，其中具有相同值的元素在排序输出数组中的出现顺序与在输入数组中出现的顺序相同。

输入列表被称为pivot(轴)的元素分为两个子列表；一个子列表的元素小于轴，另一个子列表的元素大于轴。此过程对每个子列表重复。

最后，所有排序的子列表合并形成最终输出。

### 2.1 算法步骤

1. 我们从列表中选择一个元素，称为pivot。我们使用它将列表分为两个子列表。
2. 我们对轴周围的所有元素重新排序--值较小的元素放在它之前，所有大于轴的元素放在它之后。在这一步之后，轴处于其最终位置。这是重要的分区步骤。
3. 我们将上述步骤递归地应用于轴左侧和右侧的两个子列表。

正如我们所见，快速排序自然是一种递归算法，就像任何分治的方法一样。

为了更好地理解这个算法，让我们举一个简单的例子。

```
arr[] = {5, 9, 4, 6, 5, 3}
```

1. 为了简单起见，假设我们选择5作为轴
2. 我们首先将所有小于5的元素放在数组的第一个位置：{3, 4, 5, 6, 5, 9}
3. 然后我们将对左边的子数组{3,4}重复它，以3为轴
4. 没有小于3的元素
5. 我们对轴右侧的子数组应用快速排序，即{4}
6. 此子数组仅包含一个排序元素
7. 我们继续使用原始数组的右部分{6，5，9}，直到得到最终的有序数组

### 2.2 选择最佳pivot

快速排序的关键是选择最佳的pivot。中间的元素当然是最好的，因为它会将列表分成两个相等的子列表。

但从无序列表中找到中间元素既困难又耗时，这就是为什么我们将第一个元素、最后一个元素、中值或任何其他随机元素作为轴。

## 3. Java实现

第一个方法是quickSort()，它将要排序的数组、第一个和最后一个索引作为参数。首先，我们检查索引并仅在仍有要排序的元素时继续。

我们得到排序后的轴的索引，并使用它递归调用partition()方法，参数与quickSort()方法相同，但索引不同：

我们继续使用partition()方法。为简单起见，此方法以最后一个元素为轴。然后，检查每个元素，如果其值较小，则在枢之前交换它。

到分区结束时，所有小于轴的元素都在它的左侧，所有大于轴的元素都在它的右侧。轴位于其最终排序位置，方法返回此位置：

