## 1. 问题描述

给定一个表示中序遍历的数组，找到具有给定中序遍历的所有可能的二叉树并打印它们的前序遍历。

示例：

```
输入:  in[] = {3, 2};
输出:  不同可能的二叉树的前序遍历是：
         3 2
         2 3
以下是可能的不同二叉树：
    3        2
           /
      2    3

输入:  in[] = {4, 5, 7};
输出:  不同可能的二叉树的前序遍历是：
          4 5 7 
          4 7 5 
          5 4 7 
          7 4 5 
          7 5 4 
以下是可能的不同二叉树：
  4         4           5         7       7
                    /         /       /
    5          7     4     7    4       5
             /                       /
      7      5                    5   4 
```

## 2. 算法分析

设给定的中序遍历数组为in[]。在给定的遍历中，in[i]的左子树中的所有节点必须出现在它之前，而在右子树中的所有节点必须出现在它之后。
所以当我们把in[i]看作根节点时，从in[0]到in[i-1]的所有元素都将位于左子树中，[i+1]到n-1的所有元素都将位于右子树中。
如果in[0]到in[i-1]中可以形成x个不同的树，in[i+1]到in[n-1]中可以形成y个不同的树，那么当in[i]作为根时，我们将得到xy个总树。
所以我们简单地从0迭代到n-1来获取根节点。对于in[i]中的每个节点，递归地找到不同的左右子树。
如果我们仔细观察，我们可以注意到总数基本上是第n个卡特兰数。

其思想是维护所有二叉树的根节点列表。递归地构造所有可能的左子树和右子树。为每对左右子树创建一棵树，并将树添加到列表中。下面是详细的算法。

```
1. 将二叉树list初始化为空。
2. 对于in[i]的每个元素，其中i从0到n-1变化，执行以下操作
   a) 创建一个新节点，key为'arr[i]'，设这个节点成为“node”
   b) 递归构造所有左子树的列表。
   c) 递归构造所有右子树的列表。
3. 迭代所有左子树
   a) 对于当前的左子树，迭代所有的右子树，将当前左右子树添加到“node”，并将'node'添加到list。
```

