## 1. 二叉树的BFS和DFS是什么？

+ 中序遍历(left-root-right)
+ 前序遍历(root-left-right)
+ 后序遍历(left-right-root)

<img src="../assets/BFS_DFS_InBinaryTree.png">

```
上述树的BFS和DFS

广度优先遍历 : 1 2 3 4 5

深度优先遍历:
      前序遍历 : 1 2 4 5 3 
      中序遍历 : 4 2 5 1 3 
      后序遍历 : 4 5 2 3 1
```

## 2. 为什么需要这些遍历方式

有许多树问题可以使用上述四种遍历方式中的任何一种来解决。此类问题的示例有树的大小、最大值、最小值、打印左视图等。

### 2.1 在时间复杂度方面有什么不同吗？

所有四种类型的遍历都需要O(n)时间，因为它们只访问每个节点一次。

### 2.2 在额外空间方面有什么不同吗？

在所需的额外空间方面存在差异。

1. 层序遍历所需的额外空间为O(w)，其中w是二叉树的最大宽度。在层序遍历中，队列一个一个地存储不同层级的节点。
2. 深度优先遍历所需的额外空间为O(h)，其中h是二叉树的最大高度。在深度优先遍历中，栈存储节点的所有祖先。

### 2.3 空间复杂度分析

二叉树在深度(或高度)h处的最大宽度可以是2<sup>h</sup>，其中h从0开始。因此最大节点数在最后一层。
当二叉树是一个节点数为1、3、7、15等的完美二叉树时，就会出现最坏的情况。在最坏的情况下，2<sup>h</sup>的值是Ceil(n/2)。

平衡二叉树的高度为O(Log n)。最坏情况发生在倾斜树上，最坏情况高度变为O(n)。

所以在最坏的情况下，这两种情况所需的额外空间都是O(n)。但最坏的情况发生在不同类型的树上。

从以上几点可以看出，当树更平衡时，层序遍历所需的额外空间可能会更多，而当树不平衡时，深度优先遍历所需的额外空间可能会更多。

## 3. 如何选择

1. 额外空间可能是一个因素(如上所述)。
2. 深度优先遍历通常是递归的，递归代码需要函数调用开销。
3. 最重要的一点是，BFS从根开始访问节点，而DFS从叶开始访问节点。
   因此，如果我们的问题是搜索更接近根节点的节点，我们更推荐使用BFS。如果目标节点靠近叶节点，我们更偏向于DFS。

## 4. 思考

应该使用哪种遍历来打印二叉树的叶节点，为什么？
当k远小于总层数时，应该使用哪种遍历来打印第k层的节点？