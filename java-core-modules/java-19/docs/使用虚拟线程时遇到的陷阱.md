## 1. 介绍

虚拟线程是新的，并且是针对特定工作负载的线程的一个很好的替代方案，如果不是更好的话。但是，在实施或使用它们时需要记住一些事情。在本文中，我将介绍你在使用虚拟线程时可能遇到的一些陷阱。

## 2. 不要池化虚拟线程

当我们在以前的Java版本中创建线程时，它也会创建一个由操作系统(OS)管理和调度的线程。操作系统管理的这些线程称为平台线程。要创建平台线程，你需要进行系统调用，而这些调用都是昂贵的。因为它们的创建成本如此之高，所以重复使用它们而不是每次需要时都创建一个新的是有益的。

另一方面，虚拟线程的创建成本低廉，而且你可以同时拥有多个虚拟线程。它们很便宜，因为不需要系统调用来创建它们。因此，没有必要将它们集中起来。你可以继续生产它们，并在不再需要时丢弃它们。

## 3. 限制对资源的访问(使用池)

你可能拥有诸如数据库或其他服务之类的资源，它们只能同时处理一定数量的线程。使用平台线程，你可以创建一个池，其中包含与你的资源可能占用的线程数相同的线程数。

虚拟线程不应该被池化，所以我们不能使用池来限制对资源的访问。但是，这创造了通过使代码更明确来提高代码质量的机会。除了池之外，我们还可以使用[信号量](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html)或其他类型的锁来防止太多线程同时访问资源。

## 4. 将现有执行器替换为虚拟线程的执行器

虚拟线程仍然很新。库可能没有机会试验和采用虚拟线程的使用。明智的做法是从小处着手，看看它对你的应用程序有什么影响。因此不要在你的应用程序中盲目地将线程替换为虚拟线程。

原因是编写库或你的应用程序时考虑到线程的创建和池化成本很高。池化是你永远不必与虚拟线程打交道的事情。一个简单的开始方法是用Executors.newVirtualThreadPerTaskExecutor()替换当前使用池的ExecutorService，为每个任务创建一个新的虚拟线程。

## 5. 自己管理线程的生命周期(大部分时间)

Project Loom不仅引入了虚拟线程，而且还为我们提供了结构化并发。结构化并发背后的思想是让线程的生命周期与结构化编程中的代码块一样工作。例如，在像Java这样的结构化编程语言中，如果在方法A中调用方法B，则方法B必须先完成，然后才能退出方法A。方法B的生命周期不能超过方法A的生命周期。

对于结构化并发，我们需要与结构化编程相同的规则。当你在虚拟线程Y中创建虚拟线程X时，线程X的生命周期不能超过线程Y的生命周期。结构化并发使线程的工作和思考变得更加容易。该模式的关键是避免火灾并忘记并发。

如果你想了解更多关于结构化并发的信息，请阅读[这篇文章](https://davidvlijmincx.com/posts/loom/jep_428_structured_concurrency/)。

## 6. 线程现在基本上是免费的

要记住的最重要的事情是，创建虚拟线程的成本很低，而且你不应该将它们池化在一起。这是你在使用这种新型线程时必须转变的思维方式。

## 7. 你无需学习任何新知识即可使用虚拟线程

虚拟线程不需要你学习一个全新的库。语言没有改变，只添加了几个新方法。在以下示例中，你将看到最重要的几个。

```java
// create a virtual thread for a given task.
Thread ofVirtualThread = Thread.ofVirtual().start(task);

// check if a thread is a virtual thread
ofVirtualThread.isVirtual()
        
// A new method to create an executorService for virtual threads 
ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor();
```

最后，你不必学习很多新方法或API。但是，在使用虚拟线程时，你必须忘记一些使用传统线程的习惯或最佳实践。

## 8. 总结

在本文中，我们探讨了在使用虚拟线程时可能遇到的几个陷阱。在撰写本文时，虚拟线程仍处于预览阶段，因此它们可能会发生变化。