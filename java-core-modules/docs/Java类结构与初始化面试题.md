## **一、简介**

类结构和初始化是每个 Java 程序员都应该熟悉的基础知识。本文提供了您可能会遇到的关于该主题的一些面试问题的答案。

### **Q1。描述应用于类、方法、字段或局部变量时 final 关键字的含义。**

当应用于不同的语言结构时，*final*关键字具有多种不同的含义：

-   *最终*类是不能被子类化的类
-   final方法是不能在子类*中*重写的方法
-   final字段是必须在构造函数或初始化程序块中初始化并且之后不能修改的*字段*
-   final变量是只能被赋值（并且必须被赋值）一次并且之后永远不会被修改的*变量*

### **Q2。什么是默认方法？**

在 Java 8 之前，接口只能有抽象方法，即没有主体的方法。从 Java 8 开始，接口方法可以有一个默认实现。如果实现类不重写此方法，则使用默认实现。*这样的方法适当地用default*关键字标记。

*默认*方法的一个突出用例是向现有接口添加方法。如果您不将此类接口方法标记为*default*，则此接口的所有现有实现都将中断。*添加具有默认*实现的方法可确保遗留代码与此接口的新版本的二进制兼容性。

一个很好的例子是*Iterator*接口，它允许一个类成为 for-each 循环的目标。该接口首先出现在 Java 5 中，但在 Java 8 中它获得了两个额外的方法，*forEach*和*spliterator*。它们被定义为具有实现的默认方法，因此不会破坏向后兼容性：

```java
public interface Iterable<T> {

    Iterator<T> iterator();

    default void forEach(Consumer<? super T> action) { /* */ }

    default Spliterator<T> spliterator() { /* */ }
}复制
```

### **Q3. 什么是静态类成员？**

*类的静态*字段和方法不绑定到类的特定实例。相反，它们绑定到类对象本身。调用*静态*方法或寻址*静态*字段是在编译时解决的，因为与实例方法和字段相反，我们不需要遍历引用并确定我们所引用的实际对象。

### **Q4. 如果一个类没有任何抽象成员，它可以被声明为抽象类吗？此类课程的目的是什么？**

是的，一个类可以声明为*抽象的*，即使它不包含任何*抽象*成员。作为一个抽象类，它不能被实例化，但它可以作为某个层次结构的根对象，提供对其实现有用的方法。

### **Q5. 什么是构造函数链接？**

构造函数链接是一种通过提供多个按顺序相互调用的构造函数来简化对象构造的方法。

最具体的构造函数可能采用所有可能的参数，并可能用于最详细的对象配置。不太具体的构造函数可以通过为其某些参数提供默认值来调用更具体的构造函数。在链的顶部，无参数构造函数可以实例化具有默认值的对象。

下面是一个类的示例，该类模拟在一定天数内可用的百分比折扣。如果我们在使用无参数构造函数时没有指定它们，则使用默认值 10% 和 2 天：

```java
public class Discount {

    private int percent;

    private int days;

    public Discount() {
        this(10);
    }

    public Discount(int percent) {
        this(percent, 2);
    }

    public Discount(int percent, int days) {
        this.percent = percent;
        this.days = days;
    }

}复制
```

### **Q6. 什么是覆盖和重载方法？他们有何不同？**

当您定义具有与超类中相同签名的方法时，方法的覆盖是在子类中完成的。这允许运行时根据您调用该方法的实际对象类型来选择一个方法。*toString*、*equals*和*hashCode*方法在子类中经常被覆盖。

方法的重载发生在同一个类中。当您创建具有相同名称但具有不同类型或参数数量的方法时，就会发生重载。这允许您根据提供的参数类型执行特定代码，而方法名称保持不变。

*下面是java.io.Writer*抽象类中的重载示例。以下方法都被命名为*write*，但其中一个接收一个*int*而另一个接收一个*char*数组。

```java
public abstract class Writer {

    public void write(int c) throws IOException {
        // ...
    }

    public void write(char cbuf[]) throws IOException {
        // ...
    }

}复制
```

### **Q7. 你能覆盖静态方法吗？**

不，你不能。根据定义，如果方法的实现在运行时由实际实例的类型确定（称为动态方法查找的过程），则只能重写该方法。静态方法的实现是在编译时使用引用的类型确定的，因此重写无论如何都没有多大意义*。*尽管您可以向子类中添加一个具有与超类中完全相同的签名的*静态方法，但这在技术上并不重要。*

### **Q8. 什么是不可变类，如何创建一个？**

不可变类的实例在创建后不能更改。通过更改，我们的意思是通过修改实例字段的值来改变状态。不可变类有很多优点：它们是线程安全的，当您没有可变状态要考虑时，更容易推理它们。

要使类不可变，您应该确保以下几点：

-   所有字段都应声明为*private*和*final*；这表明它们应该在构造函数中初始化，并且从那以后就不会改变；
-   该类不应该有 setter 或其他方法来改变字段的值；
-   通过构造函数传递的类的所有字段也应该是不可变的，或者它们的值应该在字段初始化之前被复制（否则我们可以通过保留这些值并修改它们来更改此类的状态）；
-   类的方法不应该被覆盖；要么所有方法都应该是*final*，要么构造函数应该是*私有的*并且只能通过*静态*工厂方法调用。

### **Q9. 如何比较两个枚举值：使用\*equals()\*还是使用 ==？**

实际上，您可以同时使用两者。枚举值是对象，因此可以将它们与*equals()*进行比较，但它们在*底层*也是作为*静态*常量实现的，因此您不妨将它们与*==*进行比较。这主要是代码风格的问题，但如果你想节省字符空间（并可能跳过不需要的方法调用），你应该将枚举与*==*进行比较。

### **Q10。什么是初始化程序块？什么是静态初始化程序块？**

初始化程序块是类范围内的花括号代码块，在实例创建期间执行。您可以使用它来初始化比就地初始化单行更复杂的字段。

实际上，编译器只是在每个构造函数中复制这个块，所以这是从所有构造函数中提取公共代码的好方法。

静态初始化程序块是花括号代码块，其前面带有*static修饰符。*它在类加载期间执行一次，可用于初始化静态字段或一些副作用。

### **Q11. 什么是标记界面？Java 中标记接口的著名示例有哪些？**

标记接口是没有任何方法的接口。它通常由类实现或由另一个接口扩展以表示某种属性。标准 Java 库中最广为人知的标记接口如下：

-   *Serializable*用于明确表示该类可以被序列化；
-   *Cloneable*允许使用 clone*方法*克隆对象（没有*Cloneable*接口，此方法抛出*CloneNotSupportedException*）；
-   *Remote*在 RMI 中用于指定可以远程调用方法的接口。

### **Q12. 什么是单例以及如何在 Java 中实现它？**

单例是面向对象编程的一种模式。一个单例类可能只有一个实例，通常是全局可见和可访问的。

在 Java 中有多种创建单例的方法。以下是最简单的示例，其中包含就地初始化的*静态字段。*初始化是线程安全的，因为*静态*字段保证以线程安全的方式初始化。构造函数是*私有的*，因此外部代码无法创建该类的多个实例。

```java
public class SingletonExample {

    private static SingletonExample instance = new SingletonExample();

    private SingletonExample() {}

    public static SingletonExample getInstance() {
        return instance;
    }
}
复制
```

但这种方法可能有一个严重的缺点——实例将在首次访问此类时被实例化。如果此类的初始化是一项繁重的操作，我们可能希望将其推迟到实际需要实例时（可能永远不需要），但同时保持线程安全。在这种情况下，我们应该使用一种称为**双重检查锁定的**技术。

### **Q13. 什么是可变参数？Var-Arg 有哪些限制？如何在方法体内使用它？**

Var-arg 是方法的可变长度参数。一个方法可能只有一个可变参数，并且它必须在参数列表中排在最后。它被指定为一个类型名称，后跟一个省略号和一个参数名称。在方法主体内部，var-arg 用作指定类型的数组。

下面是标准库中的一个示例——Collections.addAll*方法*，它接收一个集合、可变数量的元素，并将所有元素添加到集合中：

```java
public static <T> boolean addAll(
  Collection<? super T> c, T... elements) {
    boolean result = false;
    for (T element : elements)
        result |= c.add(element);
    return result;
}复制
```

### **Q14. 您可以访问超类的重写方法吗？你能以类似的方式访问超超类的重写方法吗？**

要访问超类的重写方法，可以使用*super*关键字。但是您没有类似的方法来访问超超类的重写方法。

作为标准库中的一个示例，*LinkedHashMap*类扩展了*HashMap*并主要重用了它的功能，在其值上添加了一个链表以保持迭代顺序。*LinkedHashMap*重用其超类的*clear*方法，然后清除其链表的头尾引用：

```java
public void clear() {
    super.clear();
    head = tail = null;
}
```