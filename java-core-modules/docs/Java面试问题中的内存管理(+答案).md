## 一、简介

在本文中，我们将探讨一些在 Java 开发人员面试中经常出现的内存管理问题。内存管理是一个没有多少开发人员熟悉的领域。

事实上，开发人员通常不必直接处理这个概念——因为 JVM 会处理细节。除非出现严重错误，否则即使是经验丰富的开发人员也可能无法轻松获得有关内存管理的准确信息。

另一方面，这些概念实际上在采访中非常普遍——所以让我们直接进入。

## 2.问题

### **Q1。“内存在 Java 中管理”这句话是什么意思？**

内存是应用程序有效运行所需的关键资源，并且与任何资源一样，它是稀缺的。因此，它在应用程序或应用程序的不同部分之间的分配和释放需要大量的关注和考虑。

然而，在 Java 中，开发人员不需要显式分配和释放内存——JVM，更具体地说，垃圾收集器——有处理内存分配的职责，因此开发人员不必这样做。

这与 C 等语言中发生的情况相反，在 C 语言中，程序员可以直接访问内存并在其代码中直接引用内存单元，从而为内存泄漏创造了很大的空间。

### **Q2。什么是垃圾收集及其优势？**

垃圾收集是查看堆内存、识别哪些对象在使用中、哪些没有使用，并删除未使用的对象的过程。

使用中的对象或引用的对象意味着您的程序的某些部分仍然保留指向该对象的指针。未使用的对象或未引用的对象不再被程序的任何部分引用。因此可以回收未引用对象使用的内存。

垃圾回收最大的好处就是免除了我们手动分配/释放内存的负担，让我们可以专注于解决手头的问题。

### **Q3. 垃圾收集有什么缺点吗？**

是的。每当垃圾收集器运行时，它都会对应用程序的性能产生影响。这是因为必须停止应用程序中的所有其他线程以允许垃圾收集器线程有效地完成其工作。

根据应用程序的要求，这可能是客户无法接受的实际问题。但是，通过巧妙的优化和垃圾收集器调整以及使用不同的 GC 算法，可以大大减少甚至消除这个问题。

### **Q4. “停止世界”一词的含义是什么？**

当垃圾收集器线程运行时，其他线程停止，这意味着应用程序暂时停止。这类似于房屋清洁或熏蒸，在过程完成之前，住户被拒绝进入。

根据应用程序的需要，“停止世界”垃圾收集可能会导致无法接受的冻结。这就是为什么进行垃圾收集器调整和 JVM 优化很重要，这样遇到的冻结至少是可以接受的。

### **Q5. 什么是栈和堆？这些内存结构中的每一个都存储了什么，它们是如何相互关联的？**

堆栈是内存的一部分，包含有关嵌套方法调用的信息，一直到程序中的当前位置。它还包含所有局部变量和对当前正在执行的方法中定义的堆上对象的引用。

此结构允许运行时从知道调用地址的方法返回，并在退出方法后清除所有局部变量。每个线程都有自己的堆栈。

堆是用于分配对象的大量内存。*当您使用new*关键字创建对象时，它会在堆上分配。但是，对该对象的引用存在于堆栈中。

### **Q6. 什么是分代垃圾收集，是什么让它成为一种流行的垃圾收集方法？**

分代垃圾收集可以粗略地定义为垃圾收集器使用的策略，其中堆被分成许多称为世代的部分，每个部分将根据对象在堆上的“年龄”来保存对象。

每当垃圾收集器运行时，该过程的第一步称为标记。这是垃圾收集器识别哪些内存正在使用，哪些没有使用的地方。如果必须扫描系统中的所有对象，这可能是一个非常耗时的过程。

随着越来越多的对象被分配，对象列表越来越大，导致垃圾收集时间越来越长。然而，应用程序的实证分析表明，大多数对象都是短暂的。

使用分代垃圾收集，对象根据它们存活的垃圾收集周期的“年龄”进行分组。这样，大部分工作分布在各种次要和主要的收集周期中。

今天，几乎所有的垃圾收集器都是分代的。这种策略之所以如此受欢迎，是因为随着时间的推移，它已被证明是最佳解决方案。

### **Q7. 详细描述分代垃圾收集的工作原理**

**要正确理解分代垃圾回收的工作原理，首先要记住 Java 堆的结构是**如何促进分代垃圾回收的，这一点很重要。

堆被分成更小的空间或代。这些空间是新生代、老年代或终身代以及永久代。

年轻**代承载了大部分新创建的对象**。对大多数应用程序的实证研究表明，大多数对象的生命周期很快，因此很快就有资格收集。因此，新的对象从这里开始它们的旅程，只有在达到一定的“年龄”后，才会被“提升”到老年代空间。

分代垃圾回收中的术语**“年龄”****是指对象存活的回收周期数**。

新生代空间进一步分为三个空间：一个Eden空间和两个Survivor 1（s1）和Survivor 2（s2）这样的survivor空间。

老年代存放**在内存中存活时间超过某个“年龄”的****对象** 。从年轻一代垃圾收集中幸存下来的对象被提升到这个空间。它通常比年轻一代大。由于它的大小更大，垃圾收集比年轻一代更昂贵且发生频率更低。

永久**代** **或更通常称为\*PermGen，\*包含 JVM 所需的元数据**，用于描述应用程序中使用的类和方法。它还包含用于存储驻留字符串的字符串池。它由 JVM 在运行时根据应用程序使用的类填充。此外，平台库类和方法可能存储在这里。

首先，**任何新对象都被分配到伊甸园空间**。两个幸存者空间开始时都是空的。当 Eden 空间填满时，将触发次要垃圾回收。引用的对象被移动到第一个幸存者空间。未引用的对象被删除。

在下一次小型 GC 期间，伊甸园空间也会发生同样的事情。未引用的对象被删除，引用的对象被移动到幸存者空间。然而，在这种情况下，它们被移动到第二个幸存者空间（S2）。

此外，来自第一个幸存者空间 (S1) 中最后一次次要 GC 的对象的年龄增加并被移动到 S2。一旦所有幸存的对象都被移动到 S2，S1 和 Eden 空间都被清除。此时，S2 包含不同年龄的对象。

在下一次小型 GC 中，重复相同的过程。然而这次幸存者空间发生了变化。引用的对象从 Eden 和 S2 移动到 S1。幸存的对象是老化的。伊甸园和 S2 被清除。

在每个次要垃圾回收周期之后，检查每个对象的年龄。那些已经达到某个任意年龄（例如 8 岁）的人将从年轻一代提升到老一代或终身一代。对于所有后续的次要 GC 周期，对象将继续提升到老年代空间。

这几乎耗尽了年轻一代的垃圾收集过程。最终，将对老年代执行一次主要的垃圾收集，清理并压缩该空间。对于每个主要的 GC，都有几个次要的 GC。

### **Q8. 对象何时可以进行垃圾收集？描述一下 Gc 是如何收集一个符合条件的对象的？**

如果无法从任何活动线程或任何静态引用访问对象，则该对象有资格进行垃圾收集或 GC。

一个对象符合垃圾回收条件的最直接的情况是它的所有引用都为空。没有任何实时外部引用的循环依赖项也适用于 GC。因此，如果对象 A 引用对象 B，而对象 B 引用对象 A，并且它们没有任何其他实时引用，那么对象 A 和 B 都将符合垃圾收集的条件。

另一个明显的情况是父对象设置为 null。当厨房对象在内部引用冰箱对象和水槽对象，并且厨房对象设置为空时，冰箱和水槽都将有资格与其父厨房一起进行垃圾回收。

### **Q9. 如何从 Java 代码触发垃圾收集？**

**作为 Java 程序员，你不能强制在 Java 中进行垃圾回收**；它只会在 JVM 认为它需要基于 Java 堆大小的垃圾收集时触发。

在从内存中删除对象之前，垃圾收集线程会调用该对象的 finalize() 方法，并提供执行所需的任何类型清理的机会。您也可以调用目标代码的此方法，但是，不能保证调用此方法时会发生垃圾回收。

此外，还有 System.gc() 和 Runtime.gc() 等方法用于向 JVM 发送垃圾收集请求，但不能保证垃圾收集会发生。

### **Q10。当没有足够的堆空间来容纳新对象的存储时会发生什么？**

如果在 Heap 中没有用于创建新对象的内存空间，Java 虚拟机将抛出*OutOfMemoryError*或更具体的***java.lang.OutOfMemoryError\*****堆空间。**

### **Q11. 是否有可能“复活”一个符合垃圾收集条件的对象？**

当一个对象符合垃圾回收条件时，GC 必须对其运行*finalize方法。*finalize方法保证只运行一次，因此 GC 将对象标记为已完成并让它休息直到下一个周期*。*

在*finalize*方法中，您可以从技术上“复活”一个对象，例如，通过将其分配给*静态*字段。该对象将再次变为活动状态并且不符合垃圾收集的条件，因此 GC 不会在下一个循环中收集它。

但是，该对象将被标记为已完成，因此当它再次符合条件时，不会调用 finalize 方法。从本质上讲，您只能在对象的生命周期内使用一次这种“复活”技巧。请注意，只有当您真正知道自己在做什么时才应使用这种丑陋的 hack — 然而，理解这个技巧可以让您深入了解 GC 的工作原理。

### **Q12. 描述强引用、弱引用、软引用和虚引用及其在垃圾收集中的作用。**

就像在 Java 中管理内存一样，工程师可能需要在关键应用程序中执行尽可能多的优化以最小化延迟并最大化吞吐量。就像在 JVM 中**无法明确控制何时触发垃圾收集一样，****可以影响我们创建的对象的垃圾收集方式。**

Java为我们提供了引用对象来控制我们创建的对象与垃圾收集器之间的关系。

默认情况下，我们在 Java 程序中创建的每个对象都被一个变量强引用：

```java
StringBuilder sb = new StringBuilder();复制
```

在上面的代码片段中，*new*关键字创建了一个新的*StringBuilder*对象并将其存储在堆中。然后变量*sb*存储了对该对象的**强引用。**这对垃圾收集器来说意味着特定的*StringBuilder对象根本不符合收集条件，因为**sb*持有对它的强引用。只有当我们像这样取消*sb*时，故事才会改变：

```java
sb = null;复制
```

调用上述行后，该对象将符合收集条件。

我们可以通过将对象显式包装在位于*java.lang.ref*包内的另一个引用对象中来更改对象与垃圾收集器之间的这种关系。

可以像这样创建对上述对象的**软引用**：

```java
StringBuilder sb = new StringBuilder();
SoftReference<StringBuilder> sbRef = new SoftReference<>(sb);
sb = null;复制
```

在上面的代码片段中，我们创建了两个对*StringBuilder*对象的引用。第一行创建一个**强引用** *sb*，第二行创建一个**软引用** *sbRef*。第三行应该使对象符合收集条件，但垃圾收集器将因为*sbRef*而推迟收集它。

只有当内存变得紧张并且 JVM 即将抛出*OutOfMemory*错误时，情况才会改变。换句话说，收集只有软引用的对象作为回收内存的最后手段。

*可以使用WeakReference*类以类似的方式创建弱**引用**。当*sb*设置为 null 并且*StringBuilder*对象只有一个弱引用时，JVM 的垃圾收集器将毫不妥协地在下一个周期立即收集该对象。

幻影**引用**类似于弱引用，只有幻影引用的对象将被回收而无需等待。但是，一旦收集到幻象引用的对象，它们就会排队。我们可以轮询引用队列以准确了解对象何时被收集。

### **Q13. 假设我们有一个循环引用（两个相互引用的对象）。这样的一对对象是否有资格进行垃圾收集？为什么？**

是的，一对具有循环引用的对象可以成为垃圾收集的对象。这是因为 Java 的垃圾收集器处理循环引用的方式。它认为对象是活的，不是当它们有任何对它们的引用时，而是当它们可以通过从某个垃圾收集根（活动线程的局部变量或静态字段）开始导航对象图来访问时。如果一对具有循环引用的对象无法从任何根访问，则认为它符合垃圾收集条件。

### **Q14. 字符串在内存中是如何表示的？**

*Java 中的String*实例是一个具有两个字段的对象：一个*char[] 值*字段和一个*int 哈希*字段。value字段是一个表示字符串本身的字符数组，*hash*字段包含字符串的*hashCode*，它初始化为零，在第一次*hashCode()调用**期间*计算并从那时起缓存。作为一种奇怪的边缘情况，如果字符串的*hashCode*具有零值，则每次调用*hashCode()*时都必须重新计算它。

重要的是*String*实例是不可变的：您无法获取或修改底层的*char[]*数组。字符串的另一个特点是静态常量字符串被加载并缓存在字符串池中。如果源代码中有多个相同的*String*对象，它们在运行时都由一个实例表示。

### **Q15. 什么是 Stringbuilder 以及它的用例是什么？将字符串附加到 Stringbuilder 和使用 + 运算符连接两个字符串有什么区别？Stringbuilder 与 Stringbuffer 有何不同？**

*StringBuilder*允许通过添加、删除和插入字符和字符串来操作字符序列。*这是一个可变的数据结构，与不可变的String*类相反。

连接两个*String*实例时，会创建一个新对象，并复制字符串。如果我们需要在循环中创建或修改字符串，这可能会带来巨大的垃圾收集器开销。*StringBuilder*允许更有效地处理字符串操作。

*StringBuffer*与*StringBuilder 的*不同之处在于它是线程安全的。如果需要在单个线程中操作字符串，请改用*StringBuilder*。

## **3.结论**

在本文中，我们涵盖了 Java 工程师面试中经常出现的一些最常见的问题。有关内存管理的问题主要是针对高级 Java 开发人员候选人提出的，因为面试官希望您构建的应用程序非常重要，而这些应用程序很多时候都受到内存问题的困扰。

这不应被视为详尽无遗的问题清单，而是进一步研究的起点。在 Baeldung，我们祝愿您在接下来的面试中取得成功。