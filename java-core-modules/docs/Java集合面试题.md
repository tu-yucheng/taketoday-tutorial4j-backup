## 一、简介

Java 集合是 Java 开发人员在技术面试中经常提到的一个话题。本文回顾了一些最常被问到但可能很难正确回答的重要问题。

## 2.问题

### **Q1。描述集合类型层次结构。有哪些主要接口，它们之间有什么区别？**

***Iterable\***接口表示可以使用*for-each*循环迭代的任何集合。Collection接口继承自*Iterable*并添加了通用方法来检查元素是否在集合中、从集合中添加和删除元素、确定其大小等***。\***

List 、***Set\***和***Queue\******接口\***继承自*Collection*接口。

***List\***是一个有序的集合，它的元素可以通过它们在列表中的索引来访问。

***集合\***是具有不同元素的无序集合，类似于集合的数学概念。

***Queue\***是一个集合，具有用于添加、删除和检查元素的附加方法，可用于在处理之前保存元素。

***Map\***接口也是集合框架的一部分，但它不扩展*Collection*。这是设计使然，以强调难以在通用抽象下收集的集合和映射之间的区别。Map*接口表示具有唯一键且每个键不超过一个值*的键值数据结构。

 

### **Q2。描述地图接口的各种实现及其用例差异。**

*Map*接口最常用的实现之一是***HashMap\***。它是一种典型的哈希映射数据结构，允许在常数时间或 O(1) 内访问元素，但**不保留顺序并且不是线程安全的**。

要保留元素的插入顺序，您可以使用***LinkedHashMap\***类，它扩展了*HashMap*并另外将元素绑定到链表中，但开销是可预见的。

TreeMap***类\***将其元素存储在红黑树结构中，允许以对数时间或 O(log(n)) 访问元素。在大多数情况下，它比*HashMap*慢，但它允许根据一些*Comparator*保持元素的顺序。

ConcurrentHashMap是哈希映射**的**线程安全实现。它提供了检索的完全并发性（因为*获取*操作不需要锁定）和更新的高预期并发性。

Hashtable类从 1.0 版***开始\***就存在于 Java 中。它没有被弃用，但大多被认为已过时。它是一个线程安全的哈希映射，但与*ConcurrentHashMap*不同，它的所有方法都是简单*同步的*，这意味着对该映射块的所有操作，甚至是独立值的检索。

 

### **Q3. 解释 Linkedlist 和 Arraylist 之间的区别。**

***ArrayList\***是基于数组的*List*接口的实现*ArrayList*在添加或删除元素时在内部处理此数组的大小调整。您可以通过数组中的索引在恒定时间内访问其元素。但是，插入或删除元素意味着移动所有后续元素，如果数组很大并且插入或删除的元素接近列表的开头，这可能会很慢。

***LinkedList\***是一个双向链表：单个元素被放入*Node*对象中，这些对象引用了上一个和下一个*Node*。如果您在列表的不同部分进行大量插入或删除操作，尤其是在列表很大的情况下，此实现可能看起来比*ArrayList更有效。*

然而，在大多数情况下，*ArrayList*优于*LinkedList*。即使元素在*ArrayList*中移动，虽然是一个 O(n) 操作，也被实现为一个非常快速的*System.arraycopy()*调用。*它甚至可以比LinkedList*的 O(1) 插入更快，后者需要实例化*Node*对象并在后台更新多个引用。由于创建了多个小的*Node对象，* *LinkedList*也会有很大的内存开销。

 

### **Q4. 哈希集和树集有什么区别？**

***HashSet\***和***TreeSet\***类都实现了*Set*接口并表示不同元素的集合。此外，*TreeSet*还实现了*NavigableSet*接口。该接口定义了利用元素排序的方法。

*HashSet*在内部基于*HashMap*，而*TreeSet由**TreeMap*实例支持，该实例定义了它们的属性：*HashSet*不以任何特定顺序保留元素。*对HashSet*中的元素进行迭代以打乱顺序生成它们。另一方面，*TreeSet根据一些预定义的**Comparator*按顺序生成元素。

 

### **Q5. Java中Hashmap是如何实现的？它的实现是如何使用对象的Hashcode和Equals方法的？从这种结构中放入和获取元素的时间复杂度是多少？**

HashMap类代表具有特定设计选择*的*典型哈希映射数据结构。

HashMap由大小为二次方的可调整大小的数组支持*。*将元素添加到 HashMap 时*，*首先会计算其*hashCode （一个**int*值）。然后将该值的一定数量的低位作为数组索引。这个索引直接指向应该放置这个键值对的数组单元格（称为桶）。通过数组中的索引访问元素是一个非常快的 O(1) 操作，这是哈希映射结构的主要特征。

*但是，哈希码*不是唯一的，即使对于不同的*哈希码*，我们也可能会收到相同的数组位置。这称为碰撞。解决散列映射数据结构中的冲突的方法不止一种。在 Java 的*HashMap*中，每个 bucket 实际上指的不是单个对象，而是所有落入这个 bucket 的对象的红黑树（在 Java 8 之前，这是一个链表）。

所以当*HashMap*确定了一个键的桶时，它必须遍历这棵树以将键值对放在它的位置。如果桶中已经存在具有此类密钥的一对，则将其替换为新的一对。

要通过其键检索对象，HashMap*必须*再次计算键的*hashCode*，找到相应的桶，遍历树，对树中的键调用*equals*并找到匹配的。

*HashMap*在放置和获取元素方面具有 O(1) 复杂度，或常量时间复杂度。当然，在最坏的情况下，当所有元素都落在一个桶中时，大量碰撞可能会将性能降低到 O(log(n)) 时间复杂度。这通常通过提供具有均匀分布的良好散列函数来解决。

当*HashMap*内部数组被填满时（在下一个问题中详细介绍），它会自动调整为两倍大。*此操作推断重新散列（重建内部数据结构），这是昂贵的，因此您应该事先规划好您的HashMap*的大小。

 

### **Q6. Hashmap 的初始容量和负载因子参数的用途是什么？它们的默认值是多少？**

*HashMap*构造函数的*initialCapacity*参数会影响*HashMap*内部数据结构的大小，但推导映射的实际大小有点棘手。HashMap的内部数据结构是一个具有二次方大小的数组*。*因此*initialCapacity*参数值增加到下一个二次幂（例如，如果将其设置为 10，则内部数组的实际大小将为 16）。

*HashMap*的负载因子是元素计数除以桶计数（即内部数组大小）的比率。例如，如果一个 16-bucket 的*HashMap*包含 12 个元素，则其负载因子为 12/16 = 0.75。高负载因子意味着很多碰撞，这反过来意味着地图的大小应该调整为下一个二的幂。所以*loadFactor*参数是地图加载因子的最大值。当映射达到此负载因子时，它会将其内部数组的大小调整为下一个二次方值。

默认情况下， initialCapacity为 16，loadFactor 默认为 0.75，因此您可以将 12 个元素放入使用默认构造函数实例化的 HashMap 中*，**并且*不会调整大小。*HashSet*也是如此，它在内部由*HashMap*实例支持。

*因此，提出满足您需求的initialCapacity*并非易事。这就是 Guava 库具有*Maps.newHashMapWithExpectedSize()*和*Sets.newHashSetWithExpectedSize()*方法的原因，这些方法允许您构建一个*HashMap*或*HashSet*，它可以在不调整大小的情况下容纳预期数量的元素。

### 

### **Q7. 描述枚举的特殊集合。与常规集合相比，它们的实施有什么好处？**

***EnumSet\***和***EnumMap\****分别是Set*和*Map*接口的特殊实现。在处理枚举时，您应该始终使用这些实现，因为它们非常高效。

EnumSet只是一个位向量，其位置对应于集合中存在的枚举的序数值*。*要检查枚举值是否在集合中，实现只需检查向量中的相应位是否为“1”，这是一个非常简单的操作。类似地，*EnumMap*是一个数组，使用枚举的序数值作为索引进行访问。对于*EnumMap*，无需计算哈希码或解决冲突。

 

### **Q8. Fail-Fast 和 Fail-Safe 迭代器有什么区别？**

不同集合的迭代器要么是快速失败的，要么是失败安全的，这取决于它们对并发修改的反应。并发修改不仅是从另一个线程修改集合，还包括从同一个线程修改，但使用另一个迭代器或直接修改集合。

**快速失败**迭代器（由*HashMap*、*ArrayList*和其他非线程安全集合返回的迭代器）迭代集合的内部数据结构，一旦检测到并发修改，它们就会抛出*ConcurrentModificationException 。*

**故障安全**迭代器（由线程安全集合返回，例如*ConcurrentHashMap*、*CopyOnWriteArrayList*）创建它们迭代的结构的副本。它们保证并发修改的安全性。它们的缺点包括过多的内存消耗和在集合被修改的情况下迭代可能过时的数据。

 

### **Q9. 如何使用 Comparable 和 Comparator 接口对集合进行排序？**

Comparable接口是用于可以根据某种顺序进行比较的对象的接口*。*它的唯一方法是*compareTo*，它对两个值进行操作：对象本身和相同类型的参数对象。例如，*Integer*、*Long*和其他数字类型实现此接口。*String*也实现了这个接口，它的*compareTo*方法是按照字典顺序比较字符串。

Comparable接口允许使用*Collections.sort()*方法对相应对象的列表进行排序*，并支持实现**SortedSet*和*SortedMap*的集合中的迭代顺序。如果您的对象可以使用某种逻辑进行排序，则它们应该实现*Comparable*接口。

*Comparable*接口通常使用元素的自然排序来实现。例如，所有*整数*都是从小到大排列的。但有时您可能想要实现另一种排序方式，例如，按降序对数字进行排序。Comparator接口在这里可以提供*帮助*。

您要排序的对象的类不需要实现该接口。您只需创建一个实现类并定义接收两个对象并决定如何对它们进行排序的*比较方法。*然后，您可以使用此类的实例来覆盖*Collections.sort()*方法或*SortedSet*和*SortedMap*实例的自然排序。

由于*Comparator*接口是一个函数式接口，您可以将其替换为 lambda 表达式，如下例所示。它显示了使用自然排序（*Integer*的*Comparable*接口）和自定义迭代器（*Comparator<Integer>*接口）对列表进行排序。

```java
List<Integer> list1 = Arrays.asList(5, 2, 3, 4, 1);
Collections.sort(list1);
assertEquals(new Integer(1), list1.get(0));

List<Integer> list1 = Arrays.asList(5, 2, 3, 4, 1);
Collections.sort(list1, (a, b) -> b - a);
assertEquals(new Integer(5), list1.get(0));
```