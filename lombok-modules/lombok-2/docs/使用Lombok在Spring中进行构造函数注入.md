## 1. 概述

Lombok是一个非常有用的库，可以减去大量样板代码。

在本文中，我们将演示它与Spring基于构造函数的依赖注入结合使用时的可用性。

## 2. 基于构造函数的依赖注入

在Spring中注入依赖项的一个好方法是使用基于构造函数的依赖项注入。这种方法迫使我们将组件的依赖项显式传递给构造函数。

与基于字段的依赖注入相反，它还提供了许多优点：

+ 无需创建特定于测试的配置组件 - 依赖项被显式注入到构造函数中。
+ 一致性设计 - 所有必需的依赖都被构造函数的定义强调和查找。
+ 简单的单元测试 - 减少Spring框架的开销。
+ 重新获得使用final关键字的自由。

然后，由于需要编写构造函数，它会导致代码明显变多。考虑GreetingService和FarewellService的两个例子：

```java

@Component
public class GreetingService {

    @Autowired
    private Translator translator;

    public String greet() {
        return translator.translate("hello");
    }
}

@Component
public class FarewellService {
    private final Translator translator;

    public FarewellService(Translator translator) {
        this.translator = translator;
    }

    public String farewell() {
        return translator.translate("bye");
    }
}
```

基本上，这两个组件都做相同的事情 - 它们使用特定于任务的词调用可配置的Translator。

但是，第二种方式更加模糊，因为构造函数的多余代码并没有真正为代码带来任何价值。

**在最新的Spring版本中，它的构造函数不需要使用@Autowired注解进行标注**。

## 3. Lombok构造函数注入

使用Lombok，可以为所有类的字段(使用@AllArgsConstructor)或所有final类的字段(使用@RequiredArgsConstructor)生成构造函数。
此外，如果你仍然需要一个空参构造函数，你可以添加一个额外的@NoArgsConstructor注解。

让我们创建第三个组件，类似于前两个：

```java

@Component
@RequiredArgsConstructor
public class ThankingService {
    private final Translator translator;

    public String thank() {
        return translator.translate("thank you");
    }
}
```

上面的注解会导致Lombok为我们生成一个构造函数：

```java

@Component
public class ThankingService {

    private final Translator translator;

    public String thank() {
        return translator.translate("thank you");
    }

    /* Generated by Lombok */
    public ThankingService(Translator translator) {
        this.translator = translator;
    }
}
```

## 4. 多构造函数

只要组件中只有一个构造函数，就不必对构造函数使用@Autowired进行标注，并且Spring可以明确地选择它作为实例化新对象的正确构造函数。
一旦有多个构造函数，你就需要标注将由IoC容器使用的那个。

以ApologizeService示例：

```java

@Component
@RequiredArgsConstructor
public class ApologizeService {

    private final Translator translator;
    private final String message;

    @Autowired
    public ApologizeService(Translator translator) {
        this(translator, "sorry");
    }

    public String apologize() {
        return translator.translate(message);
    }
}
```

上面的组件可以选择配置message字段，该字段在创建组件后无法更改(因此不需要setter)。
因此，它要求我们提供两个构造函数，一个具有完整配置，另一个具有message的隐式默认值。

除非使用@Autowired、@Inject或@Resource标注其中一个构造函数，否则Spring将抛出错误：

```
Failed to instantiate [...]: No default constructor found;
```

如果我们想标注Lombok生成的构造函数，我们必须使用@AllArgsConstructor的onConstructor参数传递注解：

```java

@Component
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class ApologizeService {
    // ...
}
```

onConstructor参数接收一个注解数组(或本例中的单个注解)，这些注解将放在生成的构造函数上。
由于向后兼容性问题，引入了双下划线习惯用法。根据文档：

> 语法怪异的原因是为了让这个特性在javac 7编译器中工作； @__ 类型是对实际不存在的注解类型__(双下划线)的注解引用；
> 这使得javac 7由于错误而延迟中止编译过程，因为注解处理器稍后可能会创建__类型。

## 5. 总结

在本文中，我们说明了在增加样板代码方面，没有必要偏向基于字段的DI而不是基于构造函数的DI。

多亏了Lombok，可以在不影响运行时性能的情况下自动生成通用代码，将冗长、模糊的代码缩写为使用单个注解。