## 1. 简介

是的，**我们也可以在Kotlin中进行按位运算**。尽管通常的符号，如<<、>>、| , & , 和^都不见了，但我们可以在C中做我们能做的一切，但使用类Int和Long的函数。

十年来，Kotlin社区一直在[争论位运算符](https://youtrack.jetbrains.com/issue/KT-1440)，那些支持这个想法的人说这是他们低级领域的要求-通常是声音或视频处理。那些反对它的人将其他事情放在更重要的位置，并且还指出有时代码中挤满了位符号的代码在允许它们的语言中是完全不可读的。

现在，让我们回顾一下如何在Kotlin中使用函数进行按位运算。

## 2. Kotlin按位运算及其Java对应物

我们大多数人以前都遇到过位运算，让我们重温一下Kotlin和Java语法的对比：

| 操作名称   | Java运算符    | Kotlin整数/长函数 |
| ---------- | ------------- | --------------------- |
| 连词(和) | a & b | a and b            |
| 析取(或) | a & b | a or b   |
| 异或 (xor) | a ^ b    | a xor b              |
| 反转       | ~ a       | a.inv()             |
| 左移       | 	a << bits  | a shl bits         |
| 右移       | a >> bits    | a shr bits        |
| 无符号右移 | a >>> bits| a ushr bits            |

 

Java还包括使用每个按位运算符修改的赋值运算符，如|=。在Kotlin中，我们将不得不重复自己：a = a or b。

## 3. 按位运算的工作原理

现在我们知道如何编写按位运算，让我们讨论一下它们如何处理它们的操作数。

### 3.1 合取、析取和反转

**按位合取、析取和反转与其逻辑对应物的工作方式类似**，但它们分别**影响其操作数的每一位**。因此，对于按位连接，这意味着：

```kotlin
val a = 0b10011 // 19
val b = 0b11110 // 30
assert(a and b == 0b10010) // 18
```

在这里，为了清楚起见，我们使用了一种以二进制表示法记录数字文字的方法。

对于析取：

```kotlin
val a = 0b101001 // 41
val b = 0b110011 // 51
assert(a or b == 0b111011) // 59
```

对于异或，如果相应的操作数位均为0或均为1，我们将得到0：

```kotlin
val a = 0b110101
val b = 0b101010
assert(a xor b == 31) // 11111
```

反转是最简单的-所有0都变成1，反之亦然。但是，我们必须记住Int类型有32个字节，而Long有64个字节。这意味着，为了获得较短二进制数的正确结果，我们必须用and屏蔽它们：

```kotlin
assert(0b101100.inv() and 0b111111 == 0b010011)
```

### 3.2 二进制转换

二进制移位就是这样：我们取一个二进制数并将其**向左或向右移动指定数量的位置**：

```kotlin
assert(0b110011 shl 2 == 0b11001100)
```

只有一个左移位，但我们有**两个右移位：signed和unsigned**。**无符号右移将零复制到数字的左侧并删除最右边的位**。无符号移位的结果始终是正数，即使我们移位负数也是如此：

```kotlin
assert(-0b1100110011 ushr 22 == 0b1111111111)
```

然而，**带符号的右移位会复制数字中最左边的任何位**，这意味着数字的符号将保持不变：

```kotlin
assert(0b1100110011 shr 2 == 0b11001100) // the first 22 bytes are zeroes
assert(0b11111111111111111111110011001101 shr 2 == 0b111111111111111111111100110011)
// the first bit is 1, it means that the number is negative
```

## 4. 位运算的应用

那么，为什么我们仍然需要这些操作呢？它们非常基础，在大多数CPU上，它们只需要一个周期即可计算。右移代表整数除以2位，左移代表整数乘以2位。让我们看看它们的实际效果：

```kotlin
assert(12 shr 2 == 3) // 12 / 2^2 == 12 / 4
assert(3 shl 3 == 24) // 3 * 2^3 == 3 * 8
```

与按位运算符不同，实际的乘法和除法可能需要一个以上的周期。

然后，就可以真正紧密地打包信息，每一位都意味着特定的东西。然后我们可以使用一个掩码和一个and运算符来检查这个特定的属性：

```kotlin
val SKY_IS_BLUE_MASK = 0b00000000000001000000000000

fun isSkyBlue(worldProperties: Int): Boolean = 
    worldProperties and SKY_IS_BLUE_MASK != 0

assert(isSkyBlue(0b10011100111101011101010101))
```

使用or，我们可以将各种标志组合在一起：

```kotlin
val SKY_IS_BLUE = 0b00000000000001000000000000
val SUN_IS_SHINING = 0b00000000000000100000000000
val skyIsBlueAndSunShines = SKY_IS_BLUE or SUN_IS_SHINING // 0b00000000000001100000000000
```

## 5. 总结

**按位运算在Kotlin中可用**，就像在其他主要语言(如C/C++、Python和Java)中一样。除了反转inv()之外，它们被实现为Int和Long类型的中缀函数。按位运算在信号处理、高性能计算和创建紧密压缩的数据结构中非常有用。