## **一、简介**

今天有多个可用的 AOP 库，这些库需要能够回答许多问题：

-   它与我现有的或新的应用程序兼容吗？
-   我在哪里可以实现 AOP？
-   它与我的应用程序集成的速度有多快？
-   什么是性能开销？

在本文中，我们将着眼于回答这些问题并介绍 Spring AOP 和 AspectJ – 两个最流行的 Java AOP 框架。

## **2.AOP概念**

在我们开始之前，让我们对术语和核心概念进行快速、高层次的回顾：

-   方面——分散在应用程序多个位置的标准代码/功能，通常不同于实际的业务逻辑（例如，事务管理）。每个方面都侧重于特定的横切功能
-   连接点——它是执行程序（如方法执行、构造函数调用或字段分配）期间的一个特定点
-   建议——方面在特定连接点中采取的行动
-   切入点——匹配连接点的正则表达式。每次任何连接点与切入点匹配时，都会执行与该切入点关联的指定建议
-   编织——将方面与目标对象联系起来以创建建议对象的过程

## **3.Spring AOP和AspectJ**

现在，让我们跨多个轴讨论 Spring AOP 和 AspectJ——例如功能、目标、编织、内部结构、连接点和简单性。

### **3.1. 能力和目标**

简单来说，Spring AOP 和AspectJ 的目标不同。

Spring AOP 旨在提供一个跨 Spring IoC 的简单 AOP 实现，以解决程序员面临的最常见问题。**它并不是一个完整的 AOP 解决方案**——它只能应用于由 Spring 容器管理的 beans。

另一方面，**AspectJ是原始的AOP技术，旨在提供完整的AOP解决方案。**它比 Spring AOP 更健壮，但也复杂得多。还值得注意的是，AspectJ 可以应用于所有领域对象。

### **3.2. 编织**

AspectJ 和 Spring AOP 都使用不同类型的编织，这会影响它们在性能和易用性方面的行为。

AspectJ 使用三种不同类型的编织：

1.  **编译时编织**：AspectJ 编译器将我们方面的源代码和我们的应用程序作为输入，并生成编织类文件作为输出
2.  **编译后编织**：这也称为二进制编织。它用于将现有的类文件和 JAR 文件与我们的切面编织在一起
3.  **加载时编织**：这与之前的二进制编织完全一样，不同之处在于编织被推迟到类加载器将类文件加载到 JVM 时

有关 AspectJ 本身的更多深入信息，[请转至本文](https://www.baeldung.com/aspectj)。

由于 AspectJ 使用[编译时](https://www.baeldung.com/cs/compile-load-execution-time)和类加载时织入，**Spring AOP 使用运行时织入**。

通过运行时编织，方面在应用程序执行期间使用目标对象的代理编织——使用 JDK 动态代理或 CGLIB 代理（将在下一点中讨论）：

[![springaop 进程](https://www.baeldung.com/wp-content/uploads/2017/10/springaop-process-300x148.png)](https://www.baeldung.com/wp-content/uploads/2017/10/springaop-process.png)

### **3.3. 内部结构及应用**

Spring AOP 是一个基于代理的 AOP 框架。这意味着要实现目标对象的方面，它将创建该对象的代理。这是通过以下两种方式之一实现的：

1.  JDK动态代理——Spring AOP的首选方式。只要目标对象实现了一个接口，就会使用 JDK 动态代理
2.  CGLIB 代理——如果目标对象没有实现接口，那么可以使用 CGLIB 代理

[我们可以从官方文档](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-proxying)中了解更多关于 Spring AOP 代理机制的知识。

**另一方面，AspectJ 在运行时不做任何事情，因为类是直接用方面编译的。**

因此与 Spring AOP 不同，它不需要任何设计模式。为了将方面编织到代码中，它引入了称为 AspectJ 编译器 (ajc) 的编译器，通过它我们可以编译我们的程序，然后通过提供一个小型（< 100K）运行时库来运行它。

### **3.4. 连接点**

在 3.3 节中，我们展示了 Spring AOP 基于代理模式。因此，它需要对目标 Java 类进行子类化，并相应地应用横切关注点。

但它有一个限制。**我们不能跨“最终”类应用横切关注点（或方面），因为它们不能被覆盖，因此会导致运行时异常。**

这同样适用于静态和最终方法。Spring 方面不能应用于它们，因为它们不能被覆盖。因此 Spring AOP 由于这些限制，仅支持方法执行连接点。

但是，**AspectJ 在运行时之前将横切关注点直接编织到实际代码中。**与 Spring AOP 不同，它不需要对目标对象进行子类化，因此也支持许多其他连接点。以下是支持的连接点的摘要：

| 连接点             | 支持Spring AOP | 支持AspectJ |
| ------------------ | -------------- | ----------- |
| 方法调用           | 不             | 是的        |
| 方法执行           | 是的           | 是的        |
| 构造函数调用       | 不             | 是的        |
| 构造器执行         | 不             | 是的        |
| 静态初始化程序执行 | 不             | 是的        |
| 对象初始化         | 不             | 是的        |
| 现场参考           | 不             | 是的        |
| 现场分配           | 不             | 是的        |
| 处理程序执行       | 不             | 是的        |
| 建议执行           | 不             | 是的        |

还值得注意的是，在 Spring AOP 中，方面不会应用于在同一类中调用的方法。

这显然是因为当我们在同一个类中调用方法时，我们并没有调用 Spring AOP 提供的代理方法。如果我们需要这个功能，那么我们必须在不同的 bean 中定义一个单独的方法，或者使用 AspectJ。

### **3.5. 简单**

Spring AOP 显然更简单，因为它不会在我们的构建过程之间引入任何额外的编译器或编织器。它使用运行时编织，因此它与我们通常的构建过程无缝集成。虽然它看起来很简单，但它只适用于由 Spring 管理的 bean。

然而，要使用 AspectJ，我们需要引入 AspectJ 编译器 (ajc) 并重新打包我们所有的库（除非我们切换到后编译或加载时织入）。

当然，这比前者更复杂——因为它引入了 AspectJ Java 工具（包括编译器 (ajc)、调试器 (ajdb)、文档生成器 (ajdoc)、程序结构浏览器 (ajbrowser)），我们可以使用这些工具需要与我们的 IDE 或构建工具集成。

### **3.6. 表现**

就性能而言，**编译时织入比运行时织入快得多**。Spring AOP是一个基于代理的框架，所以在应用启动的时候就存在代理的创建。此外，每个方面还有一些方法调用，这会对性能产生负面影响。

另一方面，与 Spring AOP 不同，AspectJ 在应用程序执行之前将切面编织到主代码中，因此没有额外的运行时开销。

由于这些原因，[基准测试](https://web.archive.org/web/20150520175004/https://docs.codehaus.org/display/AW/AOP+Benchmark)表明 AspectJ 几乎比 Spring AOP 快 8 到 35 倍。

## **4.总结**

这张快速表总结了 Spring AOP 和 AspectJ 之间的主要区别：

| 春季面向对象编程                           | 看点J                                                        |
| ------------------------------------------ | ------------------------------------------------------------ |
| 纯Java实现                                 | 使用 Java 编程语言的扩展实现                                 |
| 无需单独的编译过程                         | 除非设置了 LTW，否则需要 AspectJ 编译器 (ajc)                |
| 仅运行时编织可用                           | 运行时编织不可用。支持编译时、编译后和加载时编织             |
| 不太强大——只支持方法级编织                 | 更强大——可以编织字段、方法、构造函数、静态初始化器、最终类/方法等…… |
| 只能在Spring容器管理的bean上实现           | 可以在所有领域对象上实现                                     |
| 仅支持方法执行切入点                       | 支持所有切入点                                               |
| 代理由目标对象创建，并且方面应用于这些代理 | 在应用程序执行之前（在运行时之前），方面被直接编织到代码中   |
| 比 AspectJ 慢得多                          | 更好的性能                                                   |
| 易于学习和应用                             | 相对于 Spring AOP 更复杂                                     |

## **5. 选择合适的框架**

如果我们分析本节中提出的所有论点，我们将开始理解根本不是一个框架比另一个框架好。

简而言之，选择在很大程度上取决于我们的要求：

-   框架：如果应用程序没有使用 Spring 框架，那么我们别无选择，只能放弃使用 Spring AOP 的想法，因为它无法管理任何超出 Spring 容器范围的东西。但是，如果我们的应用程序完全使用 Spring 框架创建，那么我们可以使用 Spring AOP，因为它易于学习和应用
-   灵活性：鉴于有限的连接点支持，Spring AOP 不是一个完整的 AOP 解决方案，但它解决了程序员面临的最常见问题。尽管如果我们想更深入地挖掘并最大限度地利用 AOP 并希望获得广泛可用连接点的支持，那么 AspectJ 是不二之选
-   性能：如果我们使用有限的方面，那么就会有微不足道的性能差异。但有时应用程序的方面会超过数万个。我们不想在这种情况下使用运行时织入，因此最好选择 AspectJ。AspectJ 比 Spring AOP 快 8 到 35 倍
-   两全其美：这两个框架彼此完全兼容。我们总是可以尽可能地利用 Spring AOP，并且仍然使用 AspectJ 来获得前者不支持的连接点的支持

## **六，结论**

在本文中，我们在几个关键领域分析了 Spring AOP 和 AspectJ。

我们比较了两种 AOP 方法的灵活性以及它们与我们的应用程序相适应的难易程度。