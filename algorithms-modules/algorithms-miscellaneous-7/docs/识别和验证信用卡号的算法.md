## 1. 简介

[在本文中，我们将学习如何使用正则表达式](https://en.wikipedia.org/wiki/Regular_expression#Syntax)从信用卡号识别信用卡类型。

然后，我们将了解[Luhn 算法](https://en.wikipedia.org/wiki/Luhn_algorithm)以及如何使用它来检查信用卡号是否有效。

## 2. 卡号的前导数字告诉我们什么？

主帐号 (PAN) 是信用卡号的另一个名称。

PAN 的长度通常为 16 位，但位数可能因发卡机构而异。

目前，发行人标识号 (IIN) 是 PAN 的前六位数字。它由一位前导数字组成，后跟五位数字。

重要的是要强调这是目前的情况，因为它可能会在未来发生变化。早在 2015 年就开始了将 IIN 增加到前八位数字的工作。

让我们看看如何仅通过查看 IIN 来确定信用卡的类型。

### 2.1. 前导数字告诉我们什么？

主要行业标识符是卡号的第一位数字。

顾名思义，我们可以通过看卡号的第一位来判断这张卡所属的行业：

-   1、2 – 航空公司(以及其他)
-   3 – 旅游和娱乐
-   4、5 – 银行业
-   6 – 零售和银行业
-   7 – 燃料工业
-   8 – 医疗保健和电信
-   9 – 国家当局
-   0 – 其他，为将来保留

现在，让我们看看如何使用 IIN 识别发卡机构。

### 2.2. 我们如何根据 IIN 确定卡类型？

自 1989 年以来，就有[一个国际标准](https://en.wikipedia.org/wiki/ISO/IEC_7812#Individual_account_identification)定义了 PAN 的分配方式。IIN 的官方登记册不公开。

幸运的是，大多数领先的发卡机构都有广为人知的 IIN 范围，因此我们可以使用正则表达式将 IIN 与发卡机构相匹配。

在我们查看正则表达式之前，让我们记住IIN 范围列表是不断变化的。

如果我们正在编写一个应用程序来执行此操作，我们将需要考虑我们计划如何使其保持最新。

或者，我们可以选择导入几个可用的开源库之一，这些库包含更多的卡片类型并且经过更彻底的测试，我们可能无法自行管理。例如，使用[Stripe API](https://www.baeldung.com/java-stripe-api)意味着卡片处理由我们代为管理。

### 2.3. 使用正则表达式识别发卡机构

让我们尝试识别一张 Visa 卡。

Visa 卡号以 4 开头，因此识别 Visa 卡的简单正则表达式为`^4[0-9]{0,}$`.

请注意，在我们的示例中，我们没有检查数字的长度。到目前为止，我们假设卡号是有效的，所以长度不是我们在这里验证的。

可以应用类似的模式来识别其他发卡机构。例如，美国运通卡以 34 或 37 开头，因此我们可以使用`^3[47][0-9]{0,}$`.

一些发卡机构的 IIN 范围更广。

我们发现万事达卡的卡片通常以 51-55 开头，但在过去十年中，他们推出了 BIN 范围为 222100-272099 的卡片。

这给了我们一个正则表达式`^(5[1-5]|222[1-9]|22[3-9]|2[3-6]|27[01]|2720)[0-9]{0,}$`。

我们可以使用类似的模式来识别 IIN 范围已知的任何发卡机构的卡。

## 3. 卡号的中间数字告诉我们什么？

完整的 PAN 由 3 部分组成：发行标识号 (IIN)、个人帐户标识号和校验和数字。

在 IIN 和最后一位数字之间，我们有个人账户识别号。

发行人定义了这些中间数字的含义，因此它们在不同的发行人中具有不同的含义。

它们指示信息，例如与卡号关联的帐户类型。

## 4. 卡号的最后一位数字告诉我们什么？

校验和数字是卡号的最后一位。

有用的是，校验和数字允许我们使用[Luhn 算法](https://en.wikipedia.org/wiki/Luhn_algorithm)快速识别无效的卡号。

Hans Peter Luhn 在 1950 年代后期开发了 Luhn 算法。

它用于生成我们今天使用的每个现代信用卡号，确保每个卡号共享一个特定的属性。

Luhn 算法使用卡号中的每一位数字，这意味着我们可以使用它轻松确定给定卡号何时无效——即使只是输入错误的一位数字。

这样做意味着我们可以限制不必要的卡处理功能的数量。如果我们按要求的每笔交易收费，这一点尤为重要！

让我们看看如何在Java应用程序中使用 Luhn 算法。

### 4.1. 我们如何使用 Luhn 算法来验证卡号？

让我们来看看使用 Luhn 算法验证给定卡号所涉及的步骤。

我们需要获取完整的信用卡号，包括 IIN。

从最右边的数字开始，我们会将所有数字加在一起，每隔一个数字执行一个特殊步骤。

当我们从右边开始时，我们需要通过卡号向后循环，识别每隔一个数字：

```java
for (int i = cardNumber.length() - 1; i >= 0; i--) {
    int digit = Integer.parseInt(cardNumber.substring(i, i + 1));

    if ((cardNumber.length() - i) % 2 == 0) {
        digit = doubleAndSumDigits(digit);
    }

    sum += digit;
}
```

对于每第二个数字，我们必须将其加倍，然后对剩余数字求和。

让我们看看这对于 4 位数字(而不是通常的 16 位数字)的简短示例是如何工作的——让我们检查数字 8642 是否是有效的卡号。

从最右边的数字开始，我们将每第二个数字加倍：

-   所以对于 2(右起第一个数字)，没有变化。
-   接下来，我们将第二个数字 4 加倍得到 8。
-   之后，第三个数字 6 没有变化。
-   最后，我们将第四位数字 8 加倍得到 16。

如果将数字加倍得到两位数，那么我们需要做一个额外的步骤来回到一位数——我们将把这些数字加在一起产生一位数，所以对于 16，这将是 1+6=7。

这一步和减9是一样的，所以我们可以在代码中实现为：

```java
private static int doubleAndSumDigits(int digit) {
    int ret = digit  2;

    if (ret > 9) {
        ret = digit - 9;
    }

    return ret;
}

```

最后，为了完成我们的示例，让我们将每个数字相加：2 + 8 + 6 + 7 = 23。

如果 Luhn 算法的结果可以被 10 整除，则卡号可能有效。

我们将返回这个作为我们的检查结果：

```java
return sum % 10 == 0;
```

在我们的例子中，23 不能被 10 整除，因此 8642 不是有效的卡号。

在我们的示例中，最后一位数字 2 将是校验和数字。

对于真实的卡号，校验和数字是使用 Luhn 算法计算的。

例如，如果我们将校验和数字更改为 9 得到 8649，那么 Luhn 算法的结果是 30，可以被 10 整除，所以 8649 将通过我们上面的 Luhn 校验。

### 4.2. Luhn 算法有任何局限性吗？

当然，我们的检查并不意味着 8649 肯定是有效的卡号。虽然它通过了我们的检查，但它可能不是由相关发卡机构发行的实际卡。

我们可以明确确认卡号真实性的唯一方法是询问发卡机构。

Luhn 算法仍然为我们提供了一种有用的方法来确认给定的卡号何时绝对无效。

然而，在一些边缘情况下，我们的 Luhn 检查无法检测到卡号中的拼写错误。

幸运的是，这些边缘案例很少见，我们不太可能在现实生活中遇到过。

最后，Luhn 算法没有考虑卡号的长度。

实际上，我们知道即使 8649 通过了我们的 Luhn 检查，它也太短了，不可能是真正的信用卡号。

我们可以对卡号的长度进行额外检查，但必须记住每个发卡机构的卡号长度可能不同。

## 5.总结

在本文中，我们研究了卡号的每个部分可以告诉我们有关信用卡帐户的信息。

首先，我们学习了如何通过匹配前导数字上的正则表达式模式来识别发卡机构。接下来，我们看到我们需要发卡机构的特定信息来了解卡号中间告诉我们的关于账户的信息。最后，我们研究了 Luhn 算法的工作原理并实现了一些代码来验证给定的卡号。