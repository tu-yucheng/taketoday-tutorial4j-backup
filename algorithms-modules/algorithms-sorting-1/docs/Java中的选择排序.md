## 1. 简介

在本教程中，我们将学习选择排序，查看其在Java中的实现，并分析其性能。

## 2. 算法概述

选择排序 从未排序数组的第一个位置的元素开始，然后扫描后续元素以找到最小的元素。一旦找到，最小的元素将与第一个位置的元素交换。

该算法然后移动到第二个位置的元素并扫描后续元素以找到第二个最小元素的索引。一旦找到，第二小的元素将与第二个位置的元素交换。

这个过程一直持续到我们到达数组的第 n-1个元素，这会将第 n-1个最小的元素放在第 n-1个位置。在第 n-1次迭代中，最后一个元素自动落到位，从而对数组进行排序。

我们找到最大的元素而不是最小的元素来对数组进行降序排序。

让我们看一个未排序数组的例子，并按升序对其进行排序，以直观地理解算法。

### 2.1. 一个例子

考虑以下未排序的数组：

int[] arr = { 5 , 4 , 1 , 6 , 2 }

迭代 1

考虑到算法的上述工作原理，我们从第一个位置的元素- 5 - 开始，扫描所有后续元素以找到最小元素 - 1。然后我们将最小元素与第一个位置的元素交换。

修改后的数组现在看起来像：

{1, 4, 5, 6, 2}

进行的总比较：4

迭代 2

在第二次迭代中，我们移动到第二个元素 – 4 – 并扫描后续元素以找到第二小的元素 – 2。然后我们将第二小的元素与第二个位置的元素交换。

修改后的数组现在看起来像：

{1, 2, 5, 6, 4}

进行的总比较：3

类似地继续，我们有以下迭代：

迭代 3

{1, 2, 4, 6, 5}

进行的总比较：2

迭代 4

{1, 2, 4, 5, 6}

进行的总比较：1

## 3. 实施

让我们使用几个for循环来实现选择排序：

```java
public static void sortAscending(final int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int minElementIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[minElementIndex] > arr[j]) {
                minElementIndex = j;
            }
        }

        if (minElementIndex != i) {
            int temp = arr[i];
            arr[i] = arr[minElementIndex];
            arr[minElementIndex] = temp;
        }
    }
}
```

当然，要扭转它，我们可以做一些非常相似的事情：

```java
public static void sortDescending(final int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int maxElementIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[maxElementIndex] < arr[j]) {
                maxElementIndex = j;
            }
        }

        if (maxElementIndex != i) {
            int temp = arr[i];
            arr[i] = arr[maxElementIndex];
            arr[maxElementIndex] = temp;
        }
    }
}
```

再加上更多的努力，我们可以使用 [Comparator s](https://www.baeldung.com/java-comparator-comparable)将它们组合起来。

## 4. 性能概述

### 4.1. 时间

在我们之前看到的示例中，选择最小的元素需要总共进行(n-1) 次比较，然后将其交换到第一个位置。类似地，选择下一个最小的元素需要进行总共(n-2) 次比较，然后在第二个位置进行交换，依此类推。

因此，从索引 0 开始，我们执行n-1、n-2、n-3、n-4 …。1比较。由于先前的迭代和交换，最后一个元素自动落到位。

在数学上，前n-1 个 自然数的总和将告诉我们需要多少次比较才能使用选择排序 对大小为n的数组进行排序。

n 个自然数之和的公式为n(n+1)/2。

在我们的例子中，我们需要前n-1 个 自然数的总和。因此，我们将上式中的n替换为n -1得到：

(n-1)(n-1+1)/2 = (n-1)n/2 = (n^2-n)/2

由于n^2随着n的增长而显着增长，我们将n的更高次幂作为性能基准，使得该算法的时间复杂度为O(n^2)。

### 4.2. 空间

在辅助空间复杂度方面，选择排序需要一个额外的变量来临时保存值以进行交换。因此，选择排序的空间复杂度为O(1)。

## 5.总结

选择排序是一种非常容易理解和实现的排序算法。不幸的是，它的二次时间复杂度使其成为一种昂贵的排序技术。此外，由于算法必须扫描每个元素，因此最佳情况、平均情况和最坏情况的时间复杂度是相同的。

[插入排序](https://www.baeldung.com/java-insertion-sort)和[Shell 排序](https://www.baeldung.com/java-shell-sort)等其他排序技术也具有二次最坏情况时间复杂度，但它们在最佳和平均情况下表现更好。