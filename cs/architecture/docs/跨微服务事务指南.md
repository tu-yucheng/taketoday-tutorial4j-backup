## 1. 概述

在本文中，我们将讨论跨微服务实现事务的选项。

我们还将检查分布式微服务场景中事务的一些替代方案。

## 2. 避免跨微服务的事务

分布式事务是一个非常复杂的过程，有很多可能会失败的活动部分。此外，如果这些部分在不同的机器甚至不同的数据中心运行，提交事务的过程可能会变得非常漫长且不可靠。

这可能会严重影响用户体验和整体系统带宽。所以解决分布式事务问题的最好方法之一就是完全避免它们。

### 2.1. 需要事务的架构示例

通常，微服务的设计方式是独立且有用的。它应该能够解决一些原子业务任务。

如果我们可以将我们的系统拆分成这样的微服务，那么我们很有可能根本不需要在它们之间实现事务。

例如，让我们考虑一个用户之间的广播消息传递系统。

用户微服务将关注具有以下基础域类的用户配置文件(创建新用户、编辑配置文件数据等)：

```java
@Entity
public class User implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private long id;

    @Basic
    private String name;

    @Basic
    private String surname;

    @Basic
    private Instant lastMessageTime;
}复制
```

消息微服务将与广播有关。它封装了实体Message及其周围的一切：

```java
@Entity
public class Message implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private long id;

    @Basic
    private long userId;

    @Basic
    private String contents;

    @Basic
    private Instant messageTimestamp;

}复制
```

每个微服务都有自己的数据库。请注意，我们没有从实体Message引用实体User ，因为无法从消息微服务访问用户类。我们仅通过 id 引用用户。

现在User实体包含lastMessageTime字段，因为我们想在她的个人资料中显示有关上次用户活动时间的信息。

但是，要向用户添加新消息并更新她的lastMessageTime，我们现在必须跨微服务实现事务。

### 2.2. 没有事务的替代方法

我们可以改变我们的微服务架构并从用户实体中删除字段lastMessageTime。

然后我们可以通过向消息微服务发出单独的请求并找到该用户所有消息的最大messageTimestamp值来在用户配置文件中显示这个时间。

很可能，如果消息微服务处于高负载甚至宕机状态，我们将无法在她的个人资料中显示用户最后一条消息的时间。

但这比仅仅因为用户微服务没有及时响应而未能提交分布式事务来保存消息更容易接受。

[当我们必须跨多个微服务](https://www.baeldung.com/cs/microservices-cross-cutting-concerns)实现业务流程时，当然还有更复杂的场景，我们不想让这些微服务之间存在不一致。

## 3. 两阶段提交协议

[两阶段提交协议](https://en.wikipedia.org/wiki/Two-phase_commit_protocol)(或 2PC)是一种跨不同软件组件(多个数据库、消息队列等)实现事务的机制

### 3.1. 2PC的架构

分布式事务的重要参与者之一是事务协调器。分布式事务包括两个步骤：

-   准备阶段——在此阶段，事务的所有参与者准备提交并通知协调者他们已准备好完成事务
-   提交或回滚阶段——在此阶段，事务协调器向所有参与者发出提交或回滚命令

2PC 的问题在于，与单个微服务的运行时间相比，它非常慢。

协调微服务之间的事务，即使它们在同一个网络上，也确实会减慢系统速度，因此这种方法通常不会在高负载场景中使用。

### 3.2. XA标准

XA[标准](https://en.wikipedia.org/wiki/X/Open_XA)是跨支持资源进行2PC分布式事务的规范。任何符合 JTA 标准的应用程序服务器(JBoss、GlassFish 等)开箱即用地支持它。

参与分布式事务的资源可以是，例如，两个不同微服务的两个数据库。

但是，要利用此机制，必须将资源部署到单个 JTA 平台。这对于微服务架构并不总是可行的。

### 3.3. REST-AT 标准草案

另一个提议的标准是[REST-AT](https://github.com/jbosstm/documentation/tree/master/rts/docs)，它已经由 RedHat 进行了一些开发，但仍未退出草案阶段。但是，开箱即用的 WildFly 应用程序服务器支持它。

该标准允许使用应用程序服务器作为事务协调器，使用特定的 REST API 来创建和加入分布式事务。

希望参与两阶段事务的 RESTful Web 服务也必须支持特定的 REST API。

不幸的是，要将分布式事务桥接到微服务的本地资源，我们仍然必须将这些资源部署到单个 JTA 平台，或者解决自己编写此桥的重要任务。

## 4.最终一致性和补偿

到目前为止，处理跨微服务一致性的最可行模型之一是[最终一致性](https://en.wikipedia.org/wiki/Eventual_consistency)。

此模型不强制跨微服务执行分布式 ACID 事务。相反，它建议使用一些机制来确保系统在未来的某个时刻最终保持一致。

### 4.1. 最终一致性的案例

例如，假设我们需要解决以下任务：

-   注册用户资料
-   做一些自动背景检查，以确保用户可以实际访问系统

例如，第二项任务是确保该用户未因某种原因被禁止访问我们的服务器。

但这可能需要时间，我们希望将其提取到单独的微服务中。让用户等待这么久只是为了知道她注册成功是不合理的。

解决它的一种方法是使用消息驱动的方法，包括补偿。让我们考虑以下架构：

-   负责注册用户个人资料的用户微服务
-   负责进行背景调查的验证微服务
-   支持持久队列的消息传递平台

消息传递平台可以确保微服务发送的消息被持久化。然后，如果接收器当前不可用，它们将在稍后交付

### 4.2. 幸福的情景

在这个架构中，一个愉快的场景是：

-   用户微服务注册一个用户，将她的信息保存在本地数据库中

-   用户微服务用一个标志标记这个用户。它可能表示该用户尚未经过验证并且无权访问完整的系统功能

-   向用户发送注册确认，并警告用户并非系统的所有功能都可以立即访问

-   用户微服务向验证微服务发送消息以对用户进行背景检查

-   验证微服务运行后台检查并向用户微服务发送一条包含检查结果的 

    消息

    

    

    

    -   如果结果是肯定的，则*用户*微服务解除对用户的阻止
    -   如果结果是否定的，则*用户*微服务删除用户帐户

在完成所有这些步骤后，系统应该处于一致状态。但是，在一段时间内，用户实体似乎处于不完整状态。

最后一步，当用户微服务删除无效帐户时，是一个补偿阶段。

### 4.3. 失败场景

现在让我们考虑一些失败场景：

-   如果无法访问验证微服务，则具有持久队列功能的消息传递平台可确保验证微服务稍后会收到此消息
-   假设消息传递平台出现故障，则用户微服务会尝试在稍后的某个时间再次发送消息，例如，通过对所有尚未验证的用户进行计划的批处理
-   如果验证微服务收到消息，验证用户但由于消息传递平台故障无法发送回答案，验证微服务也会在稍后重试发送消息
-   如果其中一条消息丢失，或发生其他故障，用户微服务会通过预定的批处理找到所有未验证的用户，并再次发送验证请求

即使某些消息被多次发出，也不会影响微服务数据库中数据的一致性。

通过仔细考虑所有可能的故障场景，我们可以确保我们的系统满足最终一致性的条件。同时，我们不需要处理代价高昂的分布式事务。

但我们必须意识到，确保最终一致性是一项复杂的任务。它没有适用于所有情况的单一解决方案。

## 5.总结

在本文中，我们讨论了一些跨微服务实现事务的机制。

而且，我们还探索了一些替代方案来首先进行这种类型的交易。