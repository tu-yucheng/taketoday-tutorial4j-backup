## 1. 概述

哈希广泛用于[算法](https://www.baeldung.com/cs/category/algorithms)、[数据结构](https://www.baeldung.com/cs/category/data-structures)和[密码学](https://www.baeldung.com/java-cipher-class)。

在本教程中，我们将详细讨论散列及其应用领域。

首先，我们将讨论散列的核心概念和原则。

其次，我们将分析加密哈希函数。

然后，我们将定义一些散列算法和对它们的可能攻击。

最后，我们将查看常见的基于散列的数据结构。

## 2.散列

### 2.1. 哈希函数

哈希函数采用可变长度的输入数据并产生固定长度的输出值。我们通常将其称为散列码、摘要、散列值，或简称为散列。哈希函数有几个重要的特性：

-   散列是一个单向过程。因此，我们无法从其哈希中检索原始数据。
-   哈希函数是确定性的。因此，当我们将相同的输入传递给散列函数时，它总是会生成相同的输出散列码，例如 SHA-1 散列的长度为 160 位。
-   均匀性——哈希值应该均匀分布在可能的值中。
-   特定的哈希函数总是产生固定大小的输出。
-   它应该足够复杂，以尽量减少碰撞的风险。

作为例子，让我们分析一下Java的String类中使用的哈希函数：

```java
public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;
        for (int i = 0; i < value.length; i++) {
            h = 31  h + val[i];
        }
        hash = h;
    }
    return h;
}
```

在[Effective Java](https://www.oracle.com/java/technologies/effectivejava.html)中，Joshua Bloch 解释说值 31 是有意选择的，因为它是一个奇素数。使用偶数会导致信息丢失，因为乘以 2 类似于移位。简而言之，使用具有多个除数的值会导致更多的冲突。因此，使用除数较少的数字更安全。

让我们看看实际的 [hashcode()](https://www.baeldung.com/java-hashcode) 方法：

```java
public static void main(String[] args) {
    String anotherTest = "java";
    String test = "test";
    String oneMoreTest = "dev";
    System.out.println(test.hashCode()); // output: 3556498
    System.out.println(test.hashCode()); // output: 3556498
    System.out.println(anotherTest.hashCode()); // output: 3254818
    System.out.println(oneMoreTest.hashCode()); // output: 99349
}
```

分析结果，我们可以看到上述哈希函数的一些特性。

首先，调用hashcode()是一个单向过程。我们无法从生成的散列 ( int ) 中检索原始字符串。

其次，方法是确定性的。我们在一个测试变量上调用它两次，我们获得了相同的哈希值。

最后，它总是生成固定长度的哈希码，因为 Java 的int类型是固定大小的，正如我们在[Java VM 文档](https://docs.oracle.com/javase/specs/#22239)中所读到的那样。

### 2.2. 密码哈希函数

密码哈希函数是一组专门的哈希函数。它们提供更高级别的安全性。因此，它们被用于密码学目的，如密码验证、数据完整性验证、[区块链](https://www.baeldung.com/java-blockchain)(加密货币)。

除了标准哈希函数的属性外，它们还可以满足以下条件，具体取决于它们的用途：

-   抗碰撞性：加密哈希函数必须完全抗碰撞。我们已经知道标准的哈希函数应该将冲突的风险降到最低。但是，最小化并不意味着它们不会发生。之前，我们分析了一个hashcode() 函数。因为它返回一个int值，所以哈希值的变化受到 int 范围 -2147483648 到 2147483647 的限制。因此，当我们用完所有可能的值时，就会发生冲突(在某些情况下，它们甚至可能在此之前发生)。因此，在加密哈希函数中，不可能有任何可能发生冲突的情况。
-   Preimage resistance：对于任何![H](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-a7cedbc00aa5531f310166df85e3a9bb_l3.svg)具有摘要的加密哈希函数，![H](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-2ce27f7d2d82e3b238176ec7e7ee9118_l3.svg)不应该有任何快速的方法来找到消息![高(米)=小时](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-9cd733259a3fe2ac47190db722047248_l3.svg)。
-   Second preimage resistance：如果一个给定的函数是抗碰撞的，它总是抗第二原像的，但它不能是抗原像的。缺乏原像抗性的散列函数被认为出于加密目的是不安全的。
-   “Indifferentiability from random oracles”：用两个稍微不同的哈希来查找消息(输入值)应该是不可能的。
-   计算任何消息的散列应该很快。
-   如果一条消息发生了变化，即使是微小的变化，新的散列值也应该与旧的散列值有很大不同。换句话说，我们不应该能够找到新旧哈希码之间的任何关联。
-   伪随机性。

简而言之，密码哈希函数应该是安全、有效和可靠的。

### 2.3. 哈希算法

让我们描述一些流行的哈希算法。

[Message-Digest 算法 5](https://www.baeldung.com/java-md5) (MD5) 由 Ron Rives 于 1991 年引入。MD5 为任何长度的输入生成 128 位长度的摘要。不幸的是，MD5 中的冲突可以在几秒钟内被发现。因此，它不应再用于加密目的。它通常用作数据完整性验证的校验和。

安全哈希算法 2 (SHA-2) 由几个哈希函数组成，即 SHA-224、[SHA-256](https://www.baeldung.com/sha-256-hashing-java)、SHA-384、SHA-512。国家安全局 (NSA) 设计了 SHA-2，然后美国国家标准与技术研究院 (NIST) 于 2001 年将其作为联邦信息处理标准 (FIPS) 发布。一些现代安全应用程序和协议使用 SHA-2，包括 TLS、SSL、SSH、比特币。

[BLAKE3](https://github.com/BLAKE3-team/BLAKE3)是我们列表中最新的一个，发布于 2020 年 1 月 9 日。该算法生成 256 位长的摘要，可任意扩展。

BLAKE3 是单一算法，内部使用 Markle Tree 构建。它还是通用的、快速的和并行的。这些属性使其成为检查文件完整性、加密签名输入、消息身份验证的理想选择。但是，GitHub 上的官方文档声明不建议将其用于密码散列。

## 3. 密码攻击

在本节中，我们将看到一些可以影响散列函数的密码攻击。

### 3.1. 蛮力

正如我们所知，哈希函数是单向的，因此无法从其摘要中检索原始消息。它们也是统一的，因此给定的算法总是为特定消息(例如密码)生成相同的散列。另一方面，一致性使得猜测给定散列的消息成为可能。

可以通过暴力攻击来利用此属性，该攻击正在检查所有可能的消息以找到适合给定哈希的消息。理论上，所有哈希函数都容易受到此类攻击。实际上，暴力攻击的计算复杂度非常高。因此，使用足够长的散列几乎不可能找到适合特定散列的消息。

### 3.2. 生日袭击

另一种方法，生日攻击，依赖于称为生日悖论的统计问题。让我们简单描述一下。第一个问题是：我们应该在一个房间里聚集多少人才能获得至少 50% 的概率找到一个在特定日期(例如 1 月 1 日)出生的人？答案是 253。

第二个问题，也是问题的核心：我们必须在一个房间里聚集多少人才能获得至少 50% 的概率，我们会找到至少两个在特定日期(例如 1 月 1 日)出生的人？答案是惊人的：23. 23个人组成253对不同的人

因此，对于 128 位长的散列，我们需要检查 2^128 条消息以找到适合特定散列的消息。但是，只需 2^64 次检查即可找到碰撞。
为了说明这一点，我们假设我们有一台机器，在该机器上查找特定哈希值的消息需要 60 万年。在同一台机器上，查找冲突(具有相同散列的第二条消息)只需要一个小时！

为什么碰撞如此危险？例如，某些算法通过将输入的密码与其存储在数据库中的[哈希值进行比较(即在注册期间)来验证用户。](https://www.baeldung.com/java-password-hashing)如果有一种简单快捷的方法来查找冲突，则可以将冲突的短语用作密码，而不是原来的密码。

### 3.3. 拒绝服务

拒绝服务是一种流行的加密攻击，用于使服务器过载。散列函数也可以用于数据结构。

简而言之，在发生碰撞之前，它们中的许多都有效地工作。添加大量冲突数据(具有相同散列的输入)可能会略微影响此类数据结构上操作的时间复杂度。因此，它会使服务器无法执行所需的功能。

这在负责防火墙或 SSH 等安全功能的服务器上尤其危险。

## 4.哈希表

使用哈希的最常见的数据结构之一是哈希表。这将数据存储为键值对，当我们需要快速访问数据时特别有用。

访问存储在哈希表中的元素的[时间复杂度](https://www.baeldung.com/java-algorithm-complexity)是恒定的，因此它不依赖于表大小或元素的位置。在特定编程语言中实现哈希表的一个很好的例子是 Java 的[HashMap](https://www.baeldung.com/java-hashmap)。

在本节中，我们将详细讨论哈希表。

### 4.1. 散列条目

正如我们所提到的，哈希表中的条目是键值对。在内部，哈希表将数据存储在桶数组中。键在哈希表中必须是唯一的。如果我们尝试使用已经存在的密钥添加新值会发生什么？这取决于实现，但在大多数情况下，该值将被覆盖。

让我们解释一下如何向哈希表添加条目。给定一个条目，哈希表中实现的哈希函数根据键计算摘要。应用的散列算法是任意的。在前面的部分中，我们定义了一个有效的哈希函数应该具有的属性。生成的哈希码是一个索引，指示条目在存储桶数组中的值位置。

我们可以使用相应的键访问该值。在查找期间，将计算传递的键的哈希值并找到相应值的位置(因为摘要是值的索引)。传递未用于存储任何值的键将不会产生任何结果(在大多数编程语言中为null )。

使用不可变数据类型作为键很重要。例如，假设我们使用可变对象作为键。例如，我们使用了一个包含两个属性的对象：name 和 surname。向哈希表添加值后，我们更改了哈希表之外的键状态。例如，我们将名字从 Peter 更改为 John。

如果我们在更改其状态后使用此键来访问存储值，会发生什么情况？具有新状态的密钥的摘要将与原始摘要不同。因此，我们无法获得任何东西或一个不同的值，该值可能具有该不同的散列作为索引(因为例如我们之前添加了它)。

### 4.2. 碰撞

我们已经知道，对于两个不同的消息，哈希函数可以计算出相同的哈希值，我们将其称为冲突。这种情况在哈希表中也会发生。有多种方法可以处理哈希表中的冲突。介绍几个常见的吧。

第一个称为单独链接。在这种技术中，冲突的元素存储在同一个桶中的单独数据结构中。大多数情况下，单独的数据结构是一个列表。在这种情况下，哈希表操作的总时间复杂度是桶查找所需的时间(常数)+单独数据结构操作的时间。

例如，访问链表中元素的时间复杂度是![在)](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-f8d599809b2f7987726c648086c1981d_l3.svg)。因此，在发生冲突的情况下，访问元素的哈希表常数时间可以减少到![在)](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-f8d599809b2f7987726c648086c1981d_l3.svg)。因此，桶中使用的数据结构越高效越好。有时会使用不同种类的树来代替列表。

第二种方法是开放寻址。在此策略中，哈希表将冲突的元素存储在单独的桶中，就像正常的桶一样。区别在于计算摘要。当散列函数在计算散列期间发现冲突时，增量函数的结果值将![p(i)](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-20f4458a9f541ef66967ca1904d8d390_l3.svg)被添加到散列函数结果中，其中![一世](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-31318c5dcb226c69e0818e5f7d2422b5_l3.svg)是探测编号。

在发生冲突的查找过程中，将比较传递的密钥，直到找到正确的密钥。因此，最坏情况下的时间复杂度为![在)](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-f8d599809b2f7987726c648086c1981d_l3.svg)。根据使用的增量函数，开放式寻址有不同的变体：

-   线性探测，对于![p(i) = i](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-3b8d1d98f4eafd7c38f1925f0f3a709c_l3.svg)
-   二次探测，对于![p(i) = i^2](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-2df43a107464c5afa8544ae0f6d1f696_l3.svg)
-   双重哈希，for ![p(i) = i  h` (K)](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-09882dfe90778494d25ce3179eddaa34_l3.svg)，其中![h`](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-6bc7c84733e73ba3f31c70897da61a4e_l3.svg)是 key 的附加增量函数![钾](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-7fb8d8d37cb2b48aee9e97aee7728d8f_l3.svg)

## 5.总结

在本文中，我们深入探讨了散列主题。

首先，我们描述了哈希函数和加密哈希函数。其次，我们列举了其中的几个例子。然后，我们展示了几个密码攻击的例子。接下来，我们介绍了哈希表数据结构。

最后，我们分析了哈希表是如何处理碰撞的。