## 1. 概述

在本教程中，我们将介绍最长递增子序列 (LIS) 问题。

## 2.问题陈述

给定一个未排序元素的数组，其思想是找到元素按升序(从最低到最高)排列的最长子序列的长度。

子序列中的元素不一定要出现在初始数组的连续位置，LIS 的解并不总是唯一的。

### 2.1. 例子

对于元素 {-3、10、5、12、15}，我们确定了以下递增子序列。

-   -3, 10, 12, 15
-   -3, 5, 12, 15
-   10, 12, 15
-   5, 12, 15
-   12, 15

正如我们从列表中看到的，最长的递增子序列是长度为 4 的 {-3, 5, 12, 15}。但是，这不是唯一的解决方案，因为 {-3, 10, 12, 15} 也是最长的等长递增子序列。

## 3. 简单的实现

LIS 的简单实现是首先考虑给定数组的所有可能子序列。然后，我们检查每个递增的子序列并存储它的长度。完成此过程后，我们可以返回找到的最长的长度：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-5a1b3f4a1c4f0489028b2baf1cb585da_l3.svg)

这种方法的复杂度为O(2^n) ，因为大小为n的数组包含2^n个子集。例如[1,2,3]包含子集{}、{1}、{2}、{3}、{1,2}、{1,3}、{2,3}、{1,2,3 }。

## 4.动态规划实现

我们可以使用动态编程方法来提高我们的性能。回想一下，动态规划是一种涉及将问题分解为多个较小的子问题并使用这些解决方案构建更大问题的技术。

具体在这种情况下，我们可以使用制表：

1.  最初，我们假设数组arr[]的每个索引i的LIS 都是 1。
2.  从左到右解析数组，我们查看索引i处的每个元素。
3.  对于直到i的每个元素j(其中j<i)，如果索引i处的元素大于索引j处的元素并且lis[i] <= lis[j]则lis[i] = lis[j] + 1个
4.  我们选择所有 LIS 值中的最大值

该算法背后的直觉是，我们可以通过查看所有先前的数字直到i-1找到索引i处数字的所有递增子序列， 最终找到最长的一个：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-48d424870ce7367ab45f5efe9f2335b9_l3.svg)

这个的复杂度是O(n^2)因为我们在外层循环中遍历了一次数组，产生了O(n)的复杂度，然后对于每个元素i ，我们从1向上对所有元素j进行线性搜索我。_

## 5.总结

在本教程中，我们介绍了最长递增子序列问题。

我们还查看了一个简单的实现和一个使用动态编程的实现。