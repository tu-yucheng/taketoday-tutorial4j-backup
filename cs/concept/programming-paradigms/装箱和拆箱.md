## 一、简介

在本教程中，我们将学习计算机编程中的装箱和拆箱操作。

## 2.数据类型

我们通常有三大类[数据类型](https://www.baeldung.com/cs/data-type-vs-data-structure)：

1.  本机数据类型
2.  包装数据类型
3.  用户定义的数据类型

让我们首先在以下小节中回顾一下关于每种数据类型的一些概念。

### 2.1. 本机数据类型

每种编程语言都有一些在其核心中提供的本机数据类型。我们称它们为原始数据类型。系统直接在语言实现的最低级别(机器级别)映射原始数据类型。此外，基元是不可变的(我们不能改变它们的类型)和标量。

例如，在 Java 语言中，我们将int作为原始数据类型来表示定点值(整数值)。在这种情况下，底层机器架构决定了数据类型的大小。特别是，int数据类型的大小通常为 4 字节(32 位)。

本机数据类型类别包括基本类型(例如，有符号和无符号整型、[浮点型](https://www.baeldung.com/cs/floating-point-numbers-inaccuracy)、特殊类型 bool、数据结构和基本类型的[静态分配](https://www.baeldung.com/cs/static-dynamic-linking-differences) [数组。](https://www.baeldung.com/cs/search-unpaired-element-arrays)

### 2.2. 包装数据类型

许多编程语言(例如 [Java ](https://www.baeldung.com/cs/max-int-java-c-python))提供 [包装类](https://www.baeldung.com/cs/private-vs-protected-access-modifiers)来存储本机或原始数据类型。我们称这些数据类型为包装器。

例如，Java 使用 Integer 数据类型来包装本机数据类型 int。

包装数据类型为底层原始数据类型提供额外的功能(例如，转换为字符串)。此外，它们将原始类型的值包装到对象中，使参数传递更容易。

### 2.3. 用户数据类型

用户定义的数据类型 (UDT) 是我们从现有数据类型构建的数据类型。因此，我们使用 UDT 来扩展本机数据类型或创建我们的自定义数据类型。例如，我们可以使用一个[类](https://www.baeldung.com/cs/class-object-differences)来模板化员工记录：

![出去](https://www.baeldung.com/wp-content/uploads/sites/4/2023/03/UDT-1.png)

## 3. 拳击

在回顾了必要的背景之后，我们现在研究拳击操作。

### 3.1. 概念

[从计算机编程的角度来看，我们可以将装箱理解为将基本类型转换为对象](https://www.baeldung.com/cs/class-object-differences)(包装数据类型)的包装操作。

装箱通常使用对象指针在堆上存储值。一旦我们装箱了一个数据类型，我们就得到了一个对象。该对象占用内存较多，相对复杂。之后，系统将这个对象存储在堆上。因此，我们消耗了更多内存并增加了查找时间。

为什么增加查找时间？因为我们进行了两次内存查找来访问装箱值。第一次访问将我们带到装箱对象指针，第二次访问将我们带到原始值。因此，使用盒装值往往会减慢软件程序的执行速度。

### 3.2. 例子

让我们通过一个例子来理解装箱操作。

假设我们使用变量age 来存储员工的年龄。因此，年龄值是一个原始整数( Java 中的 int)。然后，我们可以将它装箱到特定类型的对象( Java 中的Integer )：

![拳击](https://www.baeldung.com/wp-content/uploads/sites/4/2023/03/Boxing-1.png)

因此，装箱数据类型提供了多种函数来操作原始值。其中，我们可以引用值到字符串的转换。所以我们可以把它打印在屏幕上。

### 3.3. 优点

许多 [编译器](https://www.baeldung.com/cs/compiler-linker-assembler-loader)执行自动装箱作为优化措施。因此，我们不必将原始数据类型显式转换为其等效的包装类型。这样，我们不仅减少了代码占用空间，而且降低了复杂性。

此外，盒装值具有我们的原始数据类型所没有的额外元数据和结构组织：因为它们是对象，所以它们可以具有多个字段、方法和行为。

### 3.4. 拳击比赛 铸件

装箱和 [转换](https://www.baeldung.com/cs/type-safety-programming)都具有相似的功能，但我们可以发现一个细微的区别：我们通常对数据类型执行装箱操作，而我们对表达式执行转换。

因此，在转换中，我们将表达式结果显式转换为给定类型。但是，由于从较高精度类型转换为较低精度类型，它可能会导致信息丢失。

例如，我们可以对涉及浮点型变量Salary的表达式进行强制转换以获得另一个变量，即定点(整数)类型的salary 。因此，如果变量Salary为 1000.5，那么在转换之后，我们的新变量age将为 5002(而不是 5002.5)。

![铸件](https://www.baeldung.com/wp-content/uploads/sites/4/2023/03/Casting.png)

## 4. 开箱

下面，我们就来了解一下开箱操作吧！

### 4.1. 概念

拆箱是装箱的逆向改造。因此，我们从对象的包装器对象中提取对象的原始值。

### 4.2. 例子

我们在 3.2 节的例子中看到了一个装箱操作。在这里，我们可以将对象Age拆箱回我们的原始类型int：

![开箱](https://www.baeldung.com/wp-content/uploads/sites/4/2023/03/Unboxing-1.png)

## 5.总结

在本文中，我们研究了计算机编程领域中的装箱和拆箱数据。

装箱是将原始数据类型转换为对象包装器数据类型的过程，拆箱是将值从对象[包装器类型](https://www.baeldung.com/cs/inheritance-aggregation)转换回原始原始值的过程。更进一步，我们可以说装箱和拆箱操作都是类型转换的一个子集。

我们可以得出总结，与使用本机数据类型相比，装箱和拆箱会使我们的程序变慢并且占用更多内存。但是它们为我们提供了额外的功能，并使我们的代码更加健壮和灵活。