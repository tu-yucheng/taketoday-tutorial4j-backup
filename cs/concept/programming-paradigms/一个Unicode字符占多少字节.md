## 1. 概述

[Unicode](https://www.baeldung.com/java-char-encoding#unicode)是一种在我们的程序中表示字符的方法。它支持大量字符。从[Unicode 15.0](https://unicode.org/faq/basic_q.html#2a)开始，它代表 149,186 个不同的字符。然而，表示这么多选项意味着我们需要能够将它们全部存储起来，这意味着它们需要在内存中表示。

在本教程中，我们将探讨 Unicode 字符的不同表示方式以及每种方式占用的空间。

## 2.ASCII编码

在 Unicode 出现之前，有几种不同的字符编码可供使用。其中，ASCII 是比较常见的一种。

官方 ASCII 标准以 7 位表示字符，允许 128 个字符。但是，这包括一些特殊的控制字符——用于表示制表符、换行符和早期终端控件使用的一些特殊结构等内容。这使我们能够表示 96 个字符。显然，这远不及 Unicode 支持的那么多。事实上，它只支持英语就足够了。

然后对 ASCII 进行了各种扩展，添加了一些额外的字符。例如，ISO-8859-1，也称为 Latin-1，增加了 128 个字符并支持来自西欧语言的大部分字符。

到目前为止，所有这些都适合一个字节，这使得在内存中表示、在磁盘上存储或在系统之间传输非常方便。然而，它的字符数量非常有限——224 只占 Unicode 可以表示的字符的 0.1%！特别是，它只能支持西欧语言，不支持阿拉伯语、西里尔语、泰米尔语等不同的文字。

## 3. 什么是统一码？

Unicode 是表示字符的另一种方式。在这里，角色和他们的表现方式之间有明显的区别。Unicode 规范中的每个字符都分配了一个代码点，范围从 U+000000 到 U+10FFFF。在此范围内，我们支持大量字符，涵盖大量来自当前和历史语言的不同脚本，以及许多其他内容，例如表情符号、数学符号、音乐、盲文等。

显然，不可能在一个字节中表示这么多字符。事实上，Unicode 目前需要 21 位来表示每个可能的字符，这反过来意味着我们需要 3 个字节。然而，这将意味着所有文本内容突然需要三倍的空间来存储，这并不理想。因此，我们可以使用几种不同的编码。这些在不同情况下使用有不同的好处。

Unicode 也有特殊情况，多个 Unicode 字符在屏幕上生成一个字形。这些通常被称为“组合字符”。在某些情况下，这些只是稍微调整其他字符的方法——例如，组合字符以向其他字符添加重音。在其他情况下，这些可以在屏幕上产生全新的字形——例如，可以通过这种方式修改一些表情符号字符以产生全新的符号。

在下面的所有讨论中，我们只考虑单个字符。不讨论由多个字符组成的字形，但可以假设这些单独的字符每个都以正确的方式处理以用于适当的编码方案。

## 4.UTF-32编码

最明显的编码是 UTF-32。这只是一个 32 位编码方案，它将以相同的方式表示每个可能的 Unicode 字符。

每个字符都有一个固定的编码长度可以使一些操作变得更容易。例如，我们总是通过简单地计算字节数来知道字符串的长度。我们还可以轻松地跳转到字符串中的任何字符，因为我们可以轻松计算每个字符的偏移量。

然而，这也意味着每个字符将占用 4 个字节(32 位)的空间来表示。这意味着任何使用它来表示文本的内容所占用的内存、存储空间、带宽等都是 ASCII 等效内容所需的四倍。对于 ASCII 可以表示的任何内容，这显然是非常低效的。

我们还必须注意[字节](https://www.baeldung.com/cs/big-endian-vs-little-endian)的字节顺序。不知道这一点，就不可能知道字节的实际含义。UTF-32 表示为单个 32 位整数。例如，字符“扑克牌黑桃王牌”(🂡)是代码点 U+1F0A1。以 UTF-32 表示，这将是 0x000001F0A1。但是，这将在大端系统中存储为“00 01 F0 A1”，在小端系统中存储为“A1 F0 01 00”。

请注意，使用 4 个字节而不是 3 个字节的决定是在 Unicode 被正式限制为 21 位方案之前做出的。但是，使用 4 个字节还有一些其他好处。许多计算机都针对处理 32 位数字进行了优化，并且可以比处理其他结构更有效地执行此操作。因此，一个 24 位数字(3 个字节)实际上对计算机来说处理效率较低，尽管它们可以节省存储空间。

## 5.UTF-8编码

可能最流行的 Unicode 字符编码系统是 UTF-8。这是一个可变长度编码系统，我们用 8 到 32 位来表示每个字符。值得注意的是，任何字符的 UTF-8 编码永远不会比同一字符的 UTF-32 编码占用更多的字节，但可能占用更少的字节。

UTF-8 的编码系统通过在第一个字节上使用前缀位的编码长度来指示字符使用的字节数：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-168de4243f9b80d19b2317a1db450094_l3.svg)

同一个字符中的所有后续字节都有不同的前缀——“10xx xxxx”——因此我们可以看出它们位于字符的中间，而不是新字符的开头。反过来，这意味着如果我们随机地在一个字符的中间结束，我们就知道足以找到下一个字符的开头或开头。

### 5.1. 实例

这听起来很复杂，让我们看一个真实的例子。我们的“扑克牌黑桃 ACE”字符是代码点 U+1F0A1。这将其置于“32 位”类别中。这反过来意味着我们知道字节模式将是：

-   第一个字节 – 1111 0xxx
-   第二个字节 – 10xx xxxx
-   第三个字节——10xx xxxx
-   第四个字节——10xx xxxx

所以这给了我们 21 位，我们需要将我们的 Unicode 代码点放入其中。结果为“0 0001 1111 0000 1010 0001”。

如果我们将这些放入我们的位模式中，那么我们最终得到的 UTF-8 编码为“1111 0 000 ”、“10 01 1111 ”、“10 00 0010 ”、“10 10 0001 ”。这又是“F0 9F 82 A1”。

我们也可以反其道而行之，将一组 UTF-8 字节转换成一个字符。例如，让我们以字节 E2 88 9A 为例。我们的第一个字节是“1110 0010 ”，因此我们立即知道这是一个 24 位字符。我们的第二个字节是“10 00 1000 ”，第三个字节是“10 01 1010 ”，它们都有我们预期的前缀“10”。

如果我们随后将我们的模式应用于这些字节，我们将得到位序列“0010 0010 0001 1010”，即 U+221A，或“平方根”(√)。

### 5.2. 好处

这一切看起来很复杂，何必呢？这个计划有什么好处？

由于可变长度编码，字符将占用比 UTF-32 更少的存储空间。事实上，它保证了字符永远不会占用更多的空间，所以它保证在存储方面它总是与 UTF-32 一样或更高效。

然而，不止于此。前 128 个 Unicode 代码点有意映射到 128 个 ASCII 代码点。这意味着所有 ASCII 字符在 UTF-8 中的编码完全相同。这反过来意味着任何存储在 ASCII 中的文本数据都可以像在 UTF-8 中一样毫无问题地处理。请注意，这不适用于各种版本的扩展 ASCII，仅适用于基本字符。

这意味着大多数英语文本都以 UTF-8 可能的最有效形式存储。无论我们谈论的是散文还是源代码、HTML、JSON 和 XML 文档等，这都适用。

然而，许多其他语言因此而受到影响。例如，泰米尔语使用代码点 U+0B80 – U+0BFF。这些在 UTF-8 编码中总是 3 个字节。

## 6.UTF-16编码

我们看到的另一种常见编码系统是 UTF-16。例如，这就是 Java 表示字符串的方式。这是通过将代码点介于 U+0000 和 U+FFFF 之间的大多数 Unicode 字符表示为单个 16 位数字来实现的。代码点高于此范围的任何字符都将存储为两个 16 位数字，称为“代理对”。

这意味着 UTF-16 永远不会像 UTF-32 那样为同一字符占用更多字节。事实上，大多数字符将占用更少的字节。这也意味着大多数字符在 UTF-16 中占用的字节数不会比在 UTF-8 中占用的字节数多，事实上，许多字符占用的字节数更少：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-feab11fc3dee1d651e89c37497474955_l3.svg)

因此只有前 128 个字符在 UTF-16 中的效率低于 UTF-8。然而，这些恰好又是我们的 ASCII 字符。这意味着在这种编码中，ASCII 字符的表示方式不同——因此我们不能像使用 UTF-8 那样将 ASCII 文本文件视为 UTF-16——而且它们将占用两倍的存储空间。

### 6.1. 代理对

大多数 Unicode 字符在 UTF-16 中准确表示为它们的代码点，因此无需转换。例如，我们的“SQUARE ROOT”字符是 U+221A，它在 UTF-16 中被简单地表示为“22 1A”。

但是，当我们到达上限范围内的 Unicode 字符时，即 U+10000 及以上的任何字符，这将不再有效。在这种情况下，我们有代理对的概念。这些字符被编码为来自特殊范围的两个不同的 Unicode 字符 – [U+D800 – U+DFFF](https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates)。因此，这些字符将占用 4 个字节的存储空间，但碰巧，它们在 UTF-8 和 UTF-32 中也占用 4 个字节，因此这里的空间效率并不低。

那么这是如何工作的呢？

1.  从我们的代码点中减去 0x10000，因为我们以这种方式编码的事实暗示了这一点。
2.  通过将此数字右移 10 位并将结果数字添加到 0xD800 来生成高代理项对。
3.  通过获取较低的 10 位并将其添加到 0xDC00 来生成低位代理对。

例如，让我们再看看我们的“扑克牌黑桃王牌”角色。这是 U+1F0A1，所以我们：

1.  从我们的代码点中减去 0x10000，留下 0xF0A1。
2.  将 0xF0A1 右移 10 位，得到 0011 1100 (0x3C)，并将其添加到 0xD800 得到 0xD83C。
3.  取 0xF0A1 的低 10 位，00 1010 0001 (A1)，并将其添加到 0xDC00 中，得到 DCA1。

因此，我们的角色在 UTF-16 中表示为 0xD83C 0xDCA1。

一如既往，我们也可以往另一个方向走。如果我们在0xD800 – 0xDBFF范围内看到一个字符，那么我们知道这是一个高代理对，而 0xDC00 – 0xDFFF 是一个低代理对。只要我们拥有这两个，那么我们就可以确定编码的字符：

1.  从高代理对中减去 0xD800，从低代理对中减去 0xDC00。
2.  将剩余的高代理对值向左移动 10 位。
3.  将剩余的低代理对值添加到此。
4.  为此添加 0x10000。

所以，对于我们上面的例子，我们有：

1.  从 0xD83C 中减去 0xD800，从 0xDCA1 中减去 0xDC00。这给了我们 0x3C 和 0xA1。
2.  将 ox3C 向左移动 10 位，得到 0xF000。
3.  将 0xA1 添加到此以获得 0xF0A1。
4.  将 0x10000 添加到此以获得 0x1F0A1。

我们可以看到这又是我们原来的角色。

### 6.2. 优点和缺点

UTF-16 与 UTF-8 和 UTF-32 相比有一些明显的优势。它的空间效率绝不会比 UTF-32 低，而且空间效率也很少比 UTF-8 低。对于大多数字符，它也比 UTF-8 更容易使用。

那么，为什么 UTF-8 是事实上的标准而不是 UTF-16？UTF-16 相对于 UTF-8 有两个明显的缺点：

-   我们需要再次考虑字节序。因为我们将值表示为 16 位数字，所以我们需要知道我们是将它们存储为大端还是小端。UTF-8 通过始终使用 8 位数字来避免这种情况
-   ASCII 字符不会像映射到 UTF-8 那样直接映射到 UTF-16 字节。这意味着我们不能像使用 UTF-8 一样将存储在 ASCII 中的任何内容视为 UTF-16

## 七、总结

我们已经研究了 Unicode 字符集的一些主要编码系统，并了解了它们在存储到磁盘、内存、通过网络传输等时如何表示字符。

我们也看到了这些方案的一些缺点。具体来说，我们获得了运行时复杂性作为更高效存储空间的回报。

下次你需要存储和传输文本时，请考虑哪种编码系统最适合你的需求。