## 1. 概述

在本教程中，我们将讨论错误处理。

## 2.错误

假设我们编写了一个从 Excel 文件中读取一些值的计算机程序。

第一步，程序将尝试打开文件。如果文件存在于指定路径，程序将打开它并读取值。但是，如果文件不存在怎么办？我们遇到错误，或者换句话说，我们的代码应该能够处理而不会中断的异常事件。

## 3.运行时错误

当我们编写[程序](https://www.baeldung.com/cs/category/core-concepts/programming)、编译并运行它时，我们可能会遇到错误。其中一些在编译时是可检测的。这些错误的示例是主要由拼写错误引起的语法错误。因此，此类错误称为[编译时](https://www.baeldung.com/cs/runtime-vs-compile-time)错误。例如，我们可以键入“Syste”而不是“System”，然后得到：

![编译错误的打印输出](https://www.baeldung.com/wp-content/uploads/sites/4/2022/12/CompiletimeError-1-1024x122.png)

另一方面，有些错误只能在程序运行时才能检测到。我们称它们为[运行时](https://www.baeldung.com/cs/runtime-vs-compile-time)错误。例如，我们可能会尝试在不存在的索引处访问数组的元素，例如 4 元素数组中的元素 15：

![运行时错误的打印输出](https://www.baeldung.com/wp-content/uploads/sites/4/2022/12/RuntimeError-1024x117.png)

### 3.1. 一些运行时错误的案例

当程序正在运行并因此读取输入数据、进行计算和写入输出数据时，会发生运行时错误。

读/写运行时错误的示例是：

-   试图访问丢失的文件
-   等待无响应网络的时间过长(超时错误)
-   访问超出数组边界的数组元素

计算错误的例子：

-   将一个值除以零
-   生成超出特定类型值范围的值。这称为溢出。

我们无法完全避免此类错误，因为它们是由于运行时条件而发生的，我们无法控制它们。我们能做的最好的事情就是通过指定它在检测到错误时应该做什么来使我们的代码具有弹性。

### 3.2. 检测运行时错误

计算机系统包括硬件和软件。我们可能会将软件组件进一步划分为[操作系统](https://www.baeldung.com/cs/os-basic-services)和应用程序。当正在运行的程序(应用程序)需要访问计算机硬件时，它会通过操作系统进行访问。或者，更具体地说，它调用为应用程序运行的操作提供的[库函数：](https://www.baeldung.com/cs/system-call-vs-system-interrupt)

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-6262062531c79eaf720ab4922fd95212_l3.svg)

发生错误时，前面提到的组件之一可能会检测到它：

-   硬件，例如[CPU](https://www.baeldung.com/cs/cpu-guide)，可以检测计算错误，例如被零除。
-   例如，操作系统的库函数可以检测文件访问错误。
-   应用程序中的函数可以检测输入错误，例如，用户输入字符串而不是数字。

当然，取决于硬件/软件的设计，可以以各种方式进行检测。在硬件层面，数字电路负责检测。计算机 CPU 的算术逻辑单元 (ALU) 可能具有检测某些类型错误的逻辑电路。例如，在除法指令中，Motorola 的 68000 处理器检查除数的值是否为零。其他一些处理器可能不执行此检查。因此，在这些处理器上运行的软件将负责检测被零除。

在软件层面，我们可以通过测试某些[表达式](https://www.baeldung.com/cs/expression-vs-statement)的值来检测错误。因此，执行除法的函数必须测试除数的值以检查它是否为零。

检测到错误的组件应该宣布错误的发生。通过这样做，它会通知其他组件，然后这些组件可能会采取一些行动。

### 3.3. 宣布运行时错误

如果 CPU 检测到错误，它会通过设置相应的寄存器位或产生中断来通知错误。例如，Intel x86 处理器有一个名为 EFLAGS的[寄存器。](https://www.baeldung.com/cs/registers-and-ram)如果算术运算导致溢出，则该寄存器的一位设置为 1。

在软件层面，当一个函数检测到错误时，有两种选择来宣布它：

-   返回一个值，指示错误的发生。
-   引发(抛出)异常。

作为第一个选项的示例，函数在检测到错误时可能会返回值 -1。当然，这意味着该函数在正常情况下永远不会返回值 -1。

第二种选择是抛出异常。支持[异常](https://www.baeldung.com/java-errors-vs-exceptions)的编程语言提供以下机制：

-   引发或抛出异常，从而宣布检测到错误。
-   查明是否引发了任何异常。
-   如果发现引发的异常，则执行某些操作。

上面的最后一步称为处理引发的异常。

### 3.4. 处理异常

让我们考虑一个函数，该函数执行某些操作同时还检查可能的错误。它有什么作用？

1.  首先，通过测试某些表达式的值来检查是否发生了错误。
2.  如果发生错误，函数应该通过抛出异常来宣布错误。
3.  调用者应该检查是否确实抛出了异常。
4.  然后，它应该通过执行异常处理程序来处理它，异常处理程序是指定在抛出异常时应该做什么的代码片段。

我们调用第 3 步和第 4 步捕获异常。这是抛出和捕获异常的流程：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-922da76ef3e4927a8e3c45f7831d653f_l3.svg)

## 4.异常的层次结构

异常是内置的或用户定义的。

某些语言(如 Java)的运行时系统定义了几[类](https://www.baeldung.com/java-classes-objects)异常。我们可以使用它们而不必担心它们的内部工作原理。但是，我们也可以通过对任何预定义的异常进行子类化来定义我们自己的异常。因此，通常存在异常层次结构。

### 4.1. 匹配异常

我们可以使用异常的类型来选择正确的处理程序。假设我们有多个 throw 语句，其中异常是不同类型的。如果我们需要以不同方式处理每个异常，我们将在多个 catch 块中有多个处理程序。上图说明了这一点，其中异常的类型可能是 n 种类型之一。

然后使用类型完成异常和处理程序之间的匹配。T类型的异常将由形参为 T 类型的 catch 块或异常类层次结构中T的任何父(祖先)块处理。

## 5.嵌套函数调用异常

一个函数可能有一个 throw 语句，但没有匹配的异常处理程序。在这种情况下，它无法处理抛出的异常。因此，异常将转义该函数，该函数将终止。这在上图的底部进行了说明。然后，运行时系统需要释放分配给该函数的栈帧。然而，异常本身可能会传播到其他函数以搜索处理程序。

### 5.1. 例子

假设我们有一个函数F调用函数G，函数 G 又调用函数H，依此类推，直到我们结束某个函数K。现在，让我们假设这个序列中的最后一个函数，即函数K，抛出一个异常。由于以下两个原因之一，此异常可能不会在 K 中处理：

-   K 仅包含一个没有异常处理程序的 throw 语句。
-   K 中有多个异常处理程序，但没有一个与此特定异常的类型相匹配。

在这种情况下，函数 K 终止，运行时系统将异常向上传播到调用序列以搜索处理程序：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-0281adf0117ed8df719dde1bf7fce278_l3.svg)

在序列中的每个函数中，运行时系统都会尝试将异常与处理程序相匹配。如果找到，它将被执行。如果不是，则异常会转义此函数。运行时系统将终止该函数并释放其跟踪框架。然后异常将进一步向上传播到调用序列。如果没有函数可以处理异常，则整个程序将终止。

## 六，总结

在本文中，我们讨论了使用异常进行错误处理。我们已经了解了如何引发、检测和处理异常。它们应该允许我们的代码能够从各种运行时错误中恢复，而不仅仅是检测它们。