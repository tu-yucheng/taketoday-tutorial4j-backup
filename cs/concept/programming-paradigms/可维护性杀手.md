## 一、简介

在本教程中，我们将讨论可维护性杀手，并探讨气味和启发式方法在避免可维护性杀手中的作用。

气味和启发式是软件开发中用来提高可维护性的两种工具。气味是系统设计或实现问题的代码级指标，可导致可维护性问题。另一方面，启发式是设计和实现软件的一般原则，这些软件已知会导致可维护的系统。

## 2.可维护性和可维护性杀手

软件开发涉及创建可靠、高效和可维护的程序。可维护性是软件系统的特征，允许轻松修改或更新以适应不断变化的需求。

可维护性对于软件系统的长期成功至关重要。如果系统不可维护，修改起来就会变得困难且代价高昂，从而导致[技术债务](https://www.baeldung.com/cs/technical-debt)、可靠性降低和效率下降。

### 2.1. 可维护性杀手

可维护性杀手是指软件开发中随着时间的推移对维护和更新软件系统的难易程度产生负面影响的因素或元素。这些因素会使修改、调试或扩展软件变得具有挑战性，从而导致成本增加和效率降低。最终，可维护性杀手会威胁到软件项目的长期成功。

常见的可维护性杀手包括：

1.  代码质量差：写得不好的代码缺少[适当的注释](https://www.baeldung.com/cs/clean-code-comments)，不遵循编码标准导致难以维护和更新
2.  缺乏文档：文档不足或过时会使理解软件的功能和设计变得困难
3.  意大利面条代码：具有许多相互依赖性的复杂且紧密耦合的代码使其难以修改或调试
4.  技术债务：通过捷径或快速修复累积技术债务会导致软件系统随着时间的推移越来越难以维护
5.  测试不足：随着软件的发展，糟糕或不充分的测试会使识别和修复问题变得具有挑战性
6.  [设计模式](https://www.baeldung.com/creational-design-patterns)不足：使用不适合问题的设计模式会使修改或扩展软件变得困难
7.  缺乏[模块化](https://www.baeldung.com/java-9-modularity)：紧密耦合和单一的软件系统通常更难以在不引起意外副作用的情况下更新或修改

## 3.软件开发中的气味

代码气味是软件系统设计或实现中的警告标志，表明存在潜在问题。它们通常表明系统不可维护，如果不加以解决，可能会导致技术债务或其他问题。
代码气味是次优、有问题或有缺陷的代码的指标，可能表明更深层次的问题。

我们必须注意，代码气味是主观的，并且会因编程语言、开发方法和团队文化而异。但是，识别和解决代码异味有助于提高软件的质量、可维护性和可读性。

### 3.1. 代码味道的例子

一些常见的代码味道包括：

1.  重复代码：重复的代码块应该重构为可重用的函数或方法。
2.  长方法：过于复杂且难以理解、维护和测试的函数或方法。
3.  大类：过于复杂的类，具有太多的方法、属性和依赖项。
4.  开关语句：难以维护和测试的复杂控制结构。
5.  原始痴迷：使用低级数据类型，如整数、字符串或布尔值，而不是更合适的抽象。
6.  注释：不能准确反映代码的过多或过时的注释。
7.  幻数：在多个地方使用的硬编码数值，以后很难更改它们。
8.  上帝对象：过于复杂的对象，具有太多的职责和依赖性。
9.  Feature envy：频繁使用另一个对象的属性的方法，表明该方法应该是那个对象的一部分。
10.  死代码：未被执行的未使用或不必要的代码，但仍会增加软件的大小和复杂性。

### 3.2. 如何识别和修复代码异味

可以通过多种方式识别和修复代码异味，包括：

1.  代码审查：让经验丰富的开发人员审查代码以识别代码异味并提出改进建议
2.  自动化工具：使用静态分析工具，例如 linters 或代码质量检查器，来识别代码异味并提出修复建议。例如[SonarQube](https://www.sonarsource.com/products/sonarqube/)、PMD、ESLint——一种 JavaScript linter、[RuboCop](https://rubocop.org/)
3.  [重构](https://www.baeldung.com/cs/refactoring)：重构代码以提高其质量、可维护性和可读性，例如将大型方法分解为较小的方法或重构重复的代码
4.  结对编程：让两名开发人员一起处理同一代码，以提高其质量并识别代码异味
5.  [清洁代码](https://www.baeldung.com/java-clean-code)实践：遵循编写清洁和可维护代码的最佳实践。这包括遵循[封装条件](https://www.baeldung.com/cs/conditionals)编码标准、使用描述性变量名称和编写注释良好的代码等实践
6.  设计模式：使用完善的设计模式来构建代码并提高其模块化和可维护性
7.  [测试驱动开发](https://www.baeldung.com/cs/unit-testing-vs-tdd)：在编写代码本身之前为代码编写测试。这有助于识别代码气味并提高代码的整体质量

### 3.3. 重构长方法的示例

让我们考虑一个函数，它获取数值数据并计算所有大于零的值，将它们相加，最后计算并打印出它们的平均值。

重构前：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-dd0d92e223fe7bf8df42c630dc7a3eb1_l3.svg)

重构后：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-0a5199c278ba7c527226143d257310c3_l3.svg)

在此示例中，long 方法(初始![处理数据](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-0fb9e4bbe6eb431a494197da67f0c1f4_l3.svg)函数)已重构为三个独立的函数(或方法)：![处理数据](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-0fb9e4bbe6eb431a494197da67f0c1f4_l3.svg)、![获取正值总和](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-1749c73e482cf533f664c844eec825ed_l3.svg)和![getCountOfPositiveValues](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-fc747ec76a6fa35211cd1b450170d3bf_l3.svg)。这使得代码更易于理解、测试和维护，因为每个功能现在都有明确的职责，并且可以独立于其他功能进行修改。

## 4. 可维护软件的启发式

启发式是用于指导软件开发和提高软件系统可维护性的经验法则。

### 4.1. 可维护软件的启发式示例

可维护软件的启发式示例包括：

-   KISS(Keep It Simple, Stupid)：这种启发式建议软件应该简单易懂，而不是复杂且难以维护
-   DRY(不要重复自己)：这种启发式建议尽可能避免代码重复并提高代码的可重用性
-   SOLID(单一职责、开放-封闭、Liskov 替换、接口隔离和依赖倒置)：这是一组五个原则，对可维护软件系统的设计很有帮助
-   YAGNI (You Ain't Gonna Need It)：这种启发式建议开发人员不要添加不是立即需要的功能
-   单一职责原则 (SRP)：这种启发式指出软件组件应该只有一个更改原因，使其更易于理解和维护
-   Boy Scout Rule：这个启发式建议代码应该保持比被发现时更好的状态，鼓励干净和有组织的代码
-   [奥卡姆剃刀](https://en.wikipedia.org/wiki/Occam's_razor)：这种启发式建议最简单的解决方案通常是最好的，只有在必要时才应使用复杂的解决方案

## 5. 气味和启发式方法在避免可维护性杀手方面的作用

首先，让我们总结一下气味和启发式的作用：

![气味、启发式和可维护性](https://www.baeldung.com/wp-content/uploads/sites/4/2023/02/smells_heurisitcs_maintainatability.png)

在软件开发中，关注可维护性对于确保项目的长期成功至关重要。气味和启发式方法通过帮助开发人员及早发现潜在问题并采取措施纠正它们，在避免可维护性杀手方面发挥着关键作用。

这些工具使开发人员能够专注于编写干净、可读且结构良好的代码。这可以提高代码库的整体质量和可维护性。通过定期使用这些工具，开发人员可以确保他们的代码随着时间的推移保持可维护性，即使代码库在增长和发展。

最后，我们的目标是构建可以扩展和适应不断变化的业务需求的软件，同时最大限度地减少维护它所需的时间和资源。因此，气味和启发式的使用可以被视为避免可维护性杀手和促进软件既健壮又可扩展的关键步骤。

## 六，总结

在本文中，我们讨论了软件开发中的三个重要术语——可维护性杀手、气味和启发式。

可维护性杀手是代码中难以维护的严重问题。虽然代码气味是代码中指示潜在问题的模式。另一方面，启发式是用于识别这些问题并提高代码可维护性的指南。