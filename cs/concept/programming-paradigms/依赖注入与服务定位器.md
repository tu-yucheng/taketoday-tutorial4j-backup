## 一、概述

在本教程中，我们将回顾两种模式：[依赖注入和服务定位器](https://martinfowler.com/articles/injection.html)。他们以不同的方式解决同一个问题，并且经常使用可以同时适用于两者的术语。目标是找出它们的本质区别以及每种方法的优缺点。

## 2.工作示例

假设我们有一组具有依赖关系的类。让我们概述一下初始布局：

![初始布局](https://www.baeldung.com/wp-content/uploads/sites/4/2023/02/initial_layout-e1675290636360.png)

该图仅显示了类之间的依赖关系。但是，它没有解释这些类是如何使用依赖项填充的。让我们使用一种简单的方法并直接在每个类中实例化所需的依赖项：

![与新的依赖](https://www.baeldung.com/wp-content/uploads/sites/4/2023/02/dependency_with_new-1-e1675290955327.png)

允许类定义其依赖项会破坏单一职责原则并使其变得僵化和脆弱。另一个问题是new运算符，它显式地为具体实现创建依赖关系，如上图所示。因此，我们有两个问题：类负责定义它们的依赖关系，而依赖关系在具体实现上。

## 3.服务定位器

服务定位器的主要思想是创建一个包含所有依赖项的注册表，并在我们需要时从中获取组件。每个需要来自该注册表的对象都将与其交互，而不是尝试实例化依赖项本身。这样，我们就可以从组件中删除对具体实现的所有依赖：

![服务定位器](https://www.baeldung.com/wp-content/uploads/sites/4/2023/02/service_locator-1.png)

但是，该对象仍然会有依赖性，但仅限于服务定位器本身，它会透明地为我们提供所需的实现。不幸的是，太透明了，因为它会向客户端隐藏所有依赖项。从技术上讲，它[打破了封装](https://blog.ploeh.dk/2015/10/26/service-locator-violates-encapsulation/)，因为与对象的任何交互都需要查看组件内部，尤其是在测试时。

另一个问题是服务定位器将编译时错误推迟到运行时。直接在方法中使用服务定位器会产生更严重的问题。因为服务定位器注册表是在运行时填充的，所以很难判断当我们请求它们时所需的类是否存在。依赖注入容器可能会为应用程序生命周期后期创建的动态部分引入相同的问题。

此外，服务定位器被指控[违反了](https://blog.ploeh.dk/2014/05/15/service-locator-violates-solid/)接口隔离原则。然而，这是有争议的，因为“注册表”本身可能被认为是元编程的一部分，应该谨慎应用通常的设计原则。[与](https://blog.ploeh.dk/2010/11/01/PatternRecognitionAbstractFactoryorServiceLocator/)服务定位器不同， [抽象工厂](https://www.baeldung.com/java-abstract-factory-pattern)和[工厂](https://www.baeldung.com/java-factory-pattern)更明确地声明它们的依赖关系。

此外，人们指出了可测试性的问题，但如果服务定位器的实现足够灵活，这就不是真正的问题。[在大多数情况下，如果服务定位器作为单例](https://www.baeldung.com/java-singleton)实现或不允许使用简单的方法来配置注册表，就会出现问题。

服务定位器需要一个专门的地方来用组件填充注册表。这样，我们就可以将创建逻辑与将使用它们的类分开。这种分离是必不可少的，尤其是当我们有一个复杂的依赖图时。

## 4.依赖注入

这是针对同一问题的另一种方法，非常直观和直接。如果我们不想在类内部创建依赖项，让我们请其他人为我们提供它们。这种方法创建了一个合同。该类的功能需要一定数量的依赖项传递给它：

![的](https://www.baeldung.com/wp-content/uploads/sites/4/2023/02/di-1.png)

依赖注入解决了我们之前讨论的两个问题。但是，我们仍然有一个专门的类来配置和创建所有需要的依赖项。依赖注入通常与依赖注入容器结合使用，如果使用不当，可能会导致服务定位器部分讨论的所有问题。

有几种实现方式：constructor 和setter injection(也有接口注入，但是使用不广泛，比较繁琐。)总的来说还是constructor injection的方式更可取。同时，setter注入也有它的好处，也可以使用。最主要的是要记住 setter 注入可能允许非完全构造的对象和循环依赖；因此，应该明智地使用它。

## 5.依赖注入与服务定位器

这些方法之间的主要区别之一是它们对引入的依赖项的透明度。依赖注入对于类内部使用的所有内容都是明确的，并且通过构造函数注入，它清楚地显示在类 API 中。虽然服务定位器将所有内容都隐藏在里面，并且很难说出哪些类依赖于哪些，但唯一清楚的是它们都依赖于服务定位器。使用隔离接口实现服务定位器是可能的，但它可能会导致接口爆炸。尽管现代 IDE 可以显示依赖关系图并构建清晰的 UML 图，但 API 并不知道依赖关系。

另一点是依赖注入的侵入性较小并且允许重用。这些类直接依赖于其他类，从而使它们能够正常运行。使用服务定位器，重用类的唯一方法是将它们与服务定位器本身一起重用；因此，他们成群结队。尽管这两种模式都依赖于构造和配置应用程序对象的类，但依赖注入允许更好的可重用性和更直接的测试。

总的来说，依赖注入是实现松耦合和允许组件重用的常用方法。它非常直观，允许我们更明确地声明依赖关系。服务定位器可以允许更多的灵活性，而且通常太多了。这种广泛的灵活性可以打破组件之间的所有界限并鼓励不良做法，因为所有组件始终可用，只要我们需要它们。服务定位器通常被认为是一种反模式，因为它带来的问题和代码异味多于好处。

## 六，总结

服务定位器和依赖注入是试图解决相同问题的模式。然而，它们有截然不同的方法，每个都有其优点和缺点。虽然在某些特定情况下服务定位器通常更适用，但依赖注入提供了更多的灵活性和可扩展性。依赖注入是在应用程序中实现松散耦合的最常见方法。