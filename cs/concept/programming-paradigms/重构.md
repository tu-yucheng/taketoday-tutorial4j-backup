## 1. 概述

作为开发人员，我们经常听到有人重构了他们的代码。很可能，我们也进行了多次重构。

这是一个如此常见的术语，以至于我们通常甚至不考虑它的含义。不幸的是，有些人并没有清楚地理解它的真正含义。因此，他们将活动标记为重构，这与它关系不大。

在本教程中，我们将消除重构的疑虑。

## 2.什么是重构？

Martin Fowler 有一本很棒的书叫做[Refactoring](https://martinfowler.com/books/refactoring.html)。因为我们不想比他更聪明，所以我们将坚持他提供的定义：

>   重构是在不改变代码的外部行为但改进其内部结构的情况下更改软件系统的过程。这是一种规范的清理代码的方法，可以最大限度地减少引入错误的机会。本质上，当你重构时，你是在改进代码编写后的设计。

这句话很好地描述了重构的本质。下面说说它的要点。

### 2.1. 行为

最重要的特征是重构“不会改变代码的外部行为”。这意味着我们不会添加或删除任何功能，也不会更改它们的工作方式。对于相同的输入，软件产生相同的输出。因此，从用户的角度来看，软件并没有改变。除了性能，但让我们暂时把它放在一边。澄清一下：用户可以是最终用户(使用软件的人)或其他开发人员(例如，当我们编写 API 或低级组件时)。

请注意，我们没有提及任何有关内部行为的信息。这是因为从外部的角度来看它并不重要。假设我们需要一个从字符串中删除双空格的函数。我们可以通过使用正则表达式查找和替换或实现一个简单的状态机和一个循环来实现它。如果该函数删除了双空格，它就达到了它的目的。因此，实现细节并不重要。

### 2.2. 结构

如果不改变代码的功能，那么重构有什么意义呢？重构软件“改进其内部结构”。“这是一种规范的清理代码的方法，可以最大限度地减少引入错误的机会。” 它不为最终用户提供直接价值。那我们为什么还要打扰呢？再次，Martin Fowler 说得最好：“任何傻瓜都可以编写计算机可以理解的代码。优秀的程序员编写出人类可以理解的代码。”

换句话说：它影响可维护性。例如，查找和修复错误或添加新功能会更快。因此，它通过使软件更易于修改来为最终用户提供价值。此外，这意味着开发人员的头痛和倦怠更少。

### 2.3. 定时

最后但同样重要的是，“当你重构时，你是在改进代码编写后的设计”。这句话的实质是，首先，我们应该让软件工作。如果不满足要求，代码写得再好也没关系。一旦我们在那里，我们就可以提高它的可维护性。

## 3. 什么不是重构？

既然我们定义了重构，就更容易识别不满足此定义的活动。

例如，我们经常可以听到这样一句话：“我重构了代码并实现了 X 功能。”

如果开发人员的意思是她同时更改了结构并添加了新行为，则前面的陈述是错误的。我们应该记住这个定义：重构不会改变外部可观察到的行为。一项新功能根据定义改变了它。

重构和向软件添加新行为应该是正交活动。当然，有时我们需要重构代码以改变行为。例如，当我们意识到一个类是不够的时，我们需要一个继承层次结构。首先，我们将通用的东西提取到一个类或接口中。这不会改变行为，只会改变结构。接下来，我们添加第二个类并使其成为类层次结构的一部分。这不会更改现有结构，但会添加一个新元素。

如果她反复进行这些活动，上面的句子可能是正确的。重组时没有新的能力。添加新行为时无需重组。

## 4.先决条件

我们确定了重构的三个主要特征：

1.  它不会改变外部行为
2.  改变代码的内部结构
3.  代码满足要求后完成

我们如何确定第三点？另外，我们如何执行第一个？幸运的是，两者都有一个简单的解决方案：测试。

我们应该编写自动化测试来断言每个业务案例。当所有这些都是绿色时，我们就知道我们的软件满足要求。因此，我们准备重构。请注意，测试也可以成功，因为它们丢失了。或者，它们可能有问题，因为它们始终是绿色的。但让我们假设这些都不是这种情况，并且我们进行了测试，这些测试工作正常。

第一点呢？因为我们用测试覆盖了业务案例，所以很简单：我们在每个重构步骤后运行整个测试套件。如果每个测试都是绿色的，我们就没有改变行为。如果其中一些坏了，有两种可能。

首先是我们在重构的时候改了对外的接口，在测试的时候忘记修改了。例如，重命名类或删除函数的参数。在这种情况下，我们必须更改测试代码并重新运行测试。我们永远不应该忘记在更改代码时维护测试。

第二种情况是，在重组过程中，我们不小心也改变了行为。由于我们的测试清楚地说明了哪些场景出现问题，因此修复代码应该很容易。

请注意，我们可以根据需要在添加新功能和重构之间切换。在我们开始重构之前，我们不必(也不应该)等待软件满足所有需求。重要的是测试应该覆盖我们想要重构的部分。

## 5.例子

在本节中，我们将看到一些重构示例。请注意，有大量的重构技术。我们使用这些小例子的唯一目的是让它更容易想象。

[Martin Fowler](https://martinfowler.com/books/refactoring.html)的重构包含重构技术的完整列表。此外，[refactoring.guru](https://refactoring.guru/)也有一个不错的[重构目录](https://refactoring.guru/refactoring/techniques)。

### 5.1. 一个(看似)简单的案例

最简单的重构之一是重命名变量。例如，当我们的 Web 应用程序启动时，我们想要更改应用程序启动的标题和日志。我们使用以下 JavaScript 代码实现它：

```javascript
title = 'Refactoring';

function logStart() {
  message = 'started';
  console.log(message);
}

logStart();
document.title = title;
```

它按预期工作。但是，我们决定title是logStart()中变量的更具描述性的名称。修改后的函数如下所示：

```javascript
function logStart() {
  title = 'started';
  console.log(title);
}
```

但是，代码与以前不同：标题将是“开始”而不是“重构”。原因很简单。我们已经在全局范围内定义了一个名为title的变量。我们没有在logStart()函数中声明它。因此，我们覆盖变量的值。

重点是：即使在最简单的情况下，运行测试以防止不可预见的副作用也很重要。

### 5.2. 一个更复杂的案例

假设我们以一种非常有效的方式实现了平方根计算。但是，我们仍然需要验证我们是否得到了有效的输入。我们想出了这个解决方案：

```javascript
function sqrt(value) {
  if (typeof value !== 'number' || value < 0) {
    return NaN;
  }

  // the magic happens here
}
```

然而，我们并不满足于此。验证条件的typeof部分可能更具可读性。我们决定创建一个包含检查的函数，并从条件中调用它：

```javascript
function sqrt(value) {
  if (isNotNumber(value) || value < 0) {
    return NaN;
  }

  // the magic happens here
}

function isNotNumber(value) {
  return typeof value !== 'number';
}
```

这种重构称为[提取方法](https://refactoring.guru/extract-method)。

请注意，我们可以使用已经存在的Number.isNaN()而不是!isNumber(value)。我们想提供一个易于理解的示例。

### 5.3. 一个有点高级的案例

假设我们有以下 Java 类：

```java
class Animal {
  static final int TYPE_DOG = 1;
  static final int TYPE_CAT = 2;
  
  int type;
  
  void makeSound() {
    switch (type) {
      case TYPE_DOG:
        System.out.println("woof");
        break;
      case TYPE_CAT:
        System.out.println("meow");
        break;
    }
  }
}
```

但是，我们不喜欢这种实现。当我们向类引入新的职责时，我们也必须在其他方法中switch语句。此外，如果我们想为其他动物建模，我们必须向每个switch语句添加新的案例。这使代码变得脆弱。

相反，我们决定摆脱类型代码并为每种动物创建单独的子类：

```java
interface Animal {
  void makeSound();
}

class Dog implements Animal {
  @Override
  void makeSound() {
    System.out.println("woof");
  }
}

class Cat implements Animal {
  @Override
  void makeSound() {
    System.out.println("meow");
  }
}
```

如果我们想添加一个新的责任，我们向Animal接口添加一个方法。除非我们不在每个子类中实现它，否则代码不会编译。如果我们想添加一个新动物，我们创建一个实现Animal接口的类。同样，在我们实现每个方法之前，我们会得到一个编译错误。

为什么我们喜欢编译错误？因为那样我们就不会错过我们忘记办案的事实。当然，我们是否用测试覆盖所有可能的情况并不重要。但我们知道，通常情况下，我们的测试并不涵盖所有内容。

这种重构称为[用子类替换类型代码](https://refactoring.guru/replace-type-code-with-subclasses)。

## 6. 我们应该重构什么？

### 6.1. 识别问题

至此，我们定义了重构(它是什么)，看到了它的先决条件(什么时候做)，看到了三个简单的例子(怎么做)。但是我们怎么知道我们应该重构什么？

每当我们看到可以提高可读性的代码时，就该进行重构了。但这仍然不是一个确切的定义。我们无法提供。但是，我们可以在代码中识别出我们应该重构的常见标志。有时，这些迹象几乎是在尖叫我们应该做点什么。例如，考虑这段代码：

```javascript
function calculatePrice(user, product, amount) {
  // loyalty discount
  const a = user.orders.length > 10 ? 0.9 : 1;
  // amount discount
  const b = amount > 100 ? 0.9 : 1;
  // discounted price
  const c = product.price  a  b;

  return c  amount;
}
```

不要在变量上方写注释，我们应该给它们起有意义的名字：

```javascript
function calculatePrice(user, product, amount) {
  const loyaltyDiscount = user.orders.length > 10 ? 0.9 : 1;
  const amountDiscount = amount > 100 ? 0.9 : 1;
  const discountedPrice = product.price  loyaltyDiscount  amountDiscount;

  return discountedPrice  amount;
}
```

有时它不太明显，例如上一节中的Animal类。

然而，当我们查看有问题的代码时，我们会觉得有些地方不对劲。它闻起来臭臭的。事实上，我们称这些标志[为代码气味](https://www.baeldung.com/cs/code-smells)。除了代码气味，Bob 大叔还称它们为启发式。[他在他的优秀著作Clean Code](https://www.oreilly.com/library/view/clean-code-a/9780136083238/)中提供了一份代码气味和启发式列表。

### 6.2. 表现

我们之前简要提到了应用程序性能。微优化代码通常更难阅读。但如果它是一个关键的优化，我们应该只在不降低性能的情况下重构它以使其更具可读性。

另一方面，优化可读代码要容易得多。这不足为奇，因为如果我们无法理解代码的作用，我们也无法对其进行优化。

许多重构引入了新的抽象级别。例如，新方法调用、新类或整个类层次结构。这些抽象伴随着计算成本。因此，应用程序的性能略有下降。然而，这种减少是如此微不足道，以至于我们甚至没有注意到它。

即使影响很明显，我们通常也会使用速度较慢但可读性更好的代码。原因是通常情况下，购买性能更高的硬件比开发人员的额外成本要便宜得多，因为代码更难维护。

当然，也有例外的情况。例如，嵌入式系统往往资源有限，我们无法改进。或者，当我们构建一个每秒处理数百万个请求的全局应用程序时，这些额外的性能要求会产生重大影响。但这些都是相对罕见的情况。大多数时候，可读性是决定因素。

## 7.测试驱动开发

我们已经提到我们需要测试才能重构。在 TDD 中，我们在编写代码之前编写测试以实现它。它提出了一个问题：TDD 和重构如何相互关联？

答案是TDD 和重构有着非常密切的关系。TDD 分为三个步骤：

1.  我们写了一个失败的测试
2.  我们通过编写生产代码使测试通过
3.  最后，我们重构代码和/或测试以使其更具可读性

我们称之为红-绿-重构循环。红色，因为测试失败；因此，它们是红色的。当我们让它们通过时，它们会变成绿色。

这是 TDD 很棒的另一个原因。它不仅保证你将拥有高测试覆盖率。它还认为我们应该让我们的代码更具可读性，同时我们仍然知道它的作用。毕竟，没有比我们上周编写的代码更未知的了。

## 八、总结

重构是软件发展过程中自然而重要的一部分。

在本教程中，我们了解了它是什么以及何时以及如何进行。我们讨论了代码气味和性能影响。我们还看到重构是 TDD 的基本组成部分。

有了这一切，是时候让我们的代码更具可读性了！