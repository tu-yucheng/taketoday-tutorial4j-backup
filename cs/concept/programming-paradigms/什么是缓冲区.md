## 1. 概述

在本教程中，我们将讨论计算机编程中的[缓冲区](https://www.baeldung.com/cs/advanced-data-structures)。

## 2.缓冲器

缓冲区是一个通用术语，在不同的上下文中有不同的含义。一般来说，我们可以说缓冲是一种减轻供需波动影响的工具。

在计算机科学中，缓冲区是我们在一个组件向另一个组件提供数据时使用的临时存储，但它们的速度并不相同。可以有多个生产者和消费者，但我们将重点关注单个生产者和只有一个消费者的情况，以更好地解释这些概念。

大多数操作系统都带有用于各种目的的预定义缓冲区。例如，在快速[CPU](https://www.baeldung.com/cs/cpu-guide)和慢速外部设备之间没有缓冲区就不可能进行数据传输。

我们还可以在开发应用程序时制作自定义缓冲区。

## 3. 生产者和消费者之间的缓冲

假设我们有一个由生产者和消费者组成的系统。生产者程序正在生成消费者程序正在使用的数据。

现在，生产者生成数据的速度可能比消费者处理数据的速度快。在那种情况下，后者会生成一些数据，从而生成次优甚至不正确的结果。为了避免这种情况，我们在两者之间使用了足够大的缓冲区：

![生产者消费者流程中的缓冲区](https://www.baeldung.com/wp-content/uploads/sites/4/2022/10/producer_consumer.jpg)

因此，缓冲区充当中间存储。生产者将生成的数据项放入缓冲区。消费者以其可以处理的速度一次拿走一件物品。如果它的处理速度比数据生成慢，他们将等待消费者挑选它们。同时，生产者会不断将数据放入缓冲区，因此不会丢失任何项目。

当数据生成和数据处理速率不匹配时，缓冲区很有用。但是，我们需要正确设置它的[大小](https://www.baeldung.com/linux/restrict-size-buffer-cache)。

## 4.缓冲区大小

缓冲区的大小会影响整体性能。如果我们预留了比必要更多的空间，就会导致未充分利用。相反，如果设置较小的大小，我们将遇到数据丢失并得到不准确的结果。

只有通过涵盖所有可能场景的严格测试，我们才能确定应用程序缓冲区的最佳大小。然而，在系统设计阶段，我们可以通过考虑几个重要因素来合理估计缓冲区大小。

### 4.1. 应用程序的工作环境

我们的应用程序将在其中工作的环境和指定的要求可以帮助我们估计缓冲区的大小。 

例如，如果我们的应用程序使用网络连接它们，我们需要在发送器和接收器端都有一个大缓冲区。这是因为它们之间的介质(有损无线信道)可能有损耗和延迟。因此，缓冲区可以在不影响服务质量的情况下减轻这些错误。

一个典型的例子是视频流服务。在这里，客户端的视频播放器通常将缓冲区大小设置为网络特性的函数。它通过介质从服务器预取媒体内容并将其存储在缓冲区中，以便最终用户不会体验到抖动或延迟。

### 4.2. 数据生成和接收速率

我们通常选择的缓冲区大小是数据生成率和消费率之差的倍数，以避免缓冲区溢出。例如，如果数据以每秒 2 项的速度生成，但以每秒 1 项的速度消耗，我们可以设置缓冲区的大小![1000 times item 大小 times (2 - 1)](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-d745996b11eea2ef21ca1cb7cbce2ddf_l3.svg)以避免溢出。

### 4.3. 缓冲区位置

这也决定了缓冲区的大小。如果我们使用系统磁盘空间作为缓冲区，与 RAM 中的缓冲区相比，读写操作会更慢。

大多数文件系统以 4096 或 8192 字节(2 的大幂)的块为单位进行读写。因此，我们需要将缓冲区的大小设置为磁盘块大小的倍数。这样，我们就可以使读写操作非常高效。

## 5.缓冲区问题

缓冲区有两个问题：

1.  溢出
2.  下溢

### 5.1. 溢出

当生产者程序生成数据的速度远远高于消费者程序即使借助缓冲区也能处理它们的速度时，就会发生缓冲区[溢出](https://www.baeldung.com/cs/call-stack)或有界缓冲区问题。在这种情况下，缓冲区变满，新数据要么替换旧数据，要么丢失。

例如，假设我们的制作人以每秒 10 个字母的速度生成句子。缓冲区可以容纳 8 个字母，消费者每 2 秒可以读取一个字母。因此，缓冲区溢出发生在第一秒：

![溢出](https://www.baeldung.com/wp-content/uploads/sites/4/2022/10/overflow.jpg)

我们如何处理这个问题？

例如，我们可以使用更大的缓冲区。它最终仍会被填充，但如果我们的应用程序完成所需的时间少于填充缓冲区的时间，我们就可以避免溢出。

我们还可以加快消费者的速度或减慢生产者的速度。但是，如果生产者比消费者慢，我们就会遇到相反的问题，缓冲区下溢。

### 5.2. 下溢

当生产者填充缓冲区的速度比消费者处理数据的速度慢得多时，就会发生缓冲区下溢。结果，缓冲区总是被部分填满，消费者大部分时间都处于空闲状态。结果是整个系统在空闲时间和浪费的内存方面表现不佳：

![下溢](https://www.baeldung.com/wp-content/uploads/sites/4/2022/10/underflow.jpg)

我们有几种方法可以解决这个问题。

第一种方法是使用较小的缓冲区。在任何时间点，它的数据都会多于空闲空间。这样，更少的内存将被未充分利用。

其次，我们还可以加快生产者的速度或减慢消费者的速度。但是，如果消费者比生产者慢，我们会得到相反的效果。在这种情况下，我们会遇到缓冲区溢出。

## 6.同步

如果我们确保生产者在缓冲区已满时不生产数据，我们就可以避免上溢和下溢问题。我们还需要让消费者在缓冲区为空时不获取数据。换句话说，我们需要同步它们。

总体思路是让生产者在生成数据项时检查缓冲区。如果它已满，生产者将进入[休眠状态](https://www.baeldung.com/cs/os-busy-waiting)。否则，它将像往常一样向缓冲区添加新数据。

消费者在准备好处理新数据时也会检查缓冲区。如果缓冲区为空，消费者将进入休眠状态。如果不是，它将从缓冲区中取出最早的未处理项目：

![缓冲区同步](https://www.baeldung.com/wp-content/uploads/sites/4/2022/10/Buffer-Synchronization-1.jpg)

[在这里，我们用独占锁](https://www.baeldung.com/cs/deadlock-livelock-starvation)保护对公共缓冲区的读写操作。由于生产者和消费者的检查是[互斥](https://www.baeldung.com/cs/exclusive-or)的，在检查后都释放锁，如果测试失败则进入休眠状态，我们确保不会发生竞争条件。因此，每次运行此类应用程序时，我们都会获得一致的行为。

## 7. 缓冲区与缓存

尽管缓冲区和[高速缓存](https://www.baeldung.com/cs/cache-friendly-code)的临时内存存储用途相似，但它们并不相同。

当我们生成和处理数据的速率不匹配时，我们使用缓冲区。另一方面，缓存的目的是存储最频繁和最近使用的数据以加快处理速度。

此外，缓存通常比缓冲区小得多，并且读取和写入数据的速度更快。此外，所有进程共享缓存，而每个程序都可以有自己的缓冲区。最后，缓存大小是固定的。相反，缓冲区的大小可以是可配置的或固定的，具体取决于实现。

## 八、总结

在本文中，我们了解了缓冲区及其在计算机编程中的重要作用。当生成数据的应用程序或软件组件比使用数据的应用程序或软件组件快或慢时，我们使用缓冲区。