## 1. 概述

在本教程中，我们将讨论缓存友好代码并解释其在计算机编程中的重要性。

## 2.缓存

“缓存”一词非常通用，在不同的上下文中有不同的含义。它可以表示 CPU 缓存、磁盘缓存、数据库缓存或[浏览器缓存](https://www.baeldung.com/cs/caching-vs-cdn)。

通常，[缓存](https://www.baeldung.com/cs/caching-cold-cache-vs-warm-cache)是临时存储，提供比保存我们数据的原始数据源更快的检索。因此，我们可以说当应用程序从远程服务器请求和下载远程文件时，本地磁盘充当远程文件的缓存。类似地，对于在本地文件系统上执行许多读取操作的应用程序，我们将最常访问的文件缓存在 CPU 缓存和 RAM 中。

有时，我们的应用程序的性能非常关键，以至于我们需要以充分利用缓存的方式编写代码。如果是这样的话，我们说我们想要编写缓存友好的代码。

## 三、代码分类

在许多情况下，代码或数据不适合我们的缓存。因此，数据传输发生在系统内存之间，这使得执行速度变慢。例如，具有数百万条记录的字典可能对于任何 CPU 缓存来说都太大了。

关于缓存，有两种类型的代码：

1.  缓存友好和
2.  缓存不友好

## 4.缓存友好的代码

如果一段代码最佳地使用了缓存，那么它就是缓存友好的。缓存友好代码通过提高命中率来优化使用缓存，如下图所示：

![缓存命中](https://www.baeldung.com/wp-content/uploads/sites/4/2022/09/Cache_hit.jpg)

有几种方法可以使我们的代码缓存友好。

### 4.1. 连续内存

为了使代码缓存友好，我们应该将大部分数据保存在连续的内存位置。这样，当我们的代码发送第一个访问请求时，将在前面使用的大部分数据将被缓存。例如，在读取第一个数组元素时，我们可以缓存整个数组。

这与数据结构的选择密切相关。

例如，我们可以使用矩阵(二维数组)代替链表来对计算机网络[图建模。](https://www.baeldung.com/cs/graphs)列表中的链接项可以遍布整个内存，而矩阵元素则靠得很近。

### 4.2. 避免复杂循环

为了使代码缓存友好，我们需要避免使用大[循环](https://www.baeldung.com/cs/loop-invariant)。相反，我们应该将一个大循环分成更小的循环。

原因是如果循环体访问大量数据，迭代开始时缓存的项目可能会在迭代结束时从缓存中删除。之后，当迫害流回到(下一次迭代的)开始时，将出现缓存未命中。

### 4.3. 保持函数堆栈小

我们可以通过使函数堆栈尽可能小来为我们的代码添加缓存友好性。我们通过避免不必要的[递归](https://www.baeldung.com/cs/recursion-looping)来做到这一点。

例如，如果递归调用的参数占用大量空间，系统将很难将它们放入高速缓存。这导致更多的数据传输操作。

### 4.4. 缓存友好设计

我们应该为我们所有的应用程序采用缓存友好的设计。我们可以通过选择适合缓存块的数据结构来做到这一点。此外，我们应该调整我们的算法以读取和处理大小与缓存块大小相对应的传染块中的数据。缓存友好的数据结构适合缓存行并与内存对齐，以便它们最佳地使用缓存行。

缓存友好数据结构的一个常见示例是二维[矩阵](https://www.baeldung.com/cs/common-data-structures)。我们可以将其行维度设置为适合缓存大小的块以获得最佳性能。

因此，假设![米次n](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-d3092c2ccb641337ab4175c8d604df91_l3.svg)矩阵![图片](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-60905eb9afe60d25c85d00b64adb315c_l3.svg)存储图像的位图。在这里，我们知道一行中相邻的元素在内存中也存储为相邻的。因此，我们按顺序访问它们，以便缓存可以将一整行作为一个连续的内存块：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-a83ab357eeeb233c163a23e535230507_l3.svg)

如果我们按列读取元素怎么办？这将是缓存不友好的，因为同一列中的元素在内存中不相邻。一个一个地访问它们将导致缓存未命中和后续的数据传输操作。结果，我们的代码运行缓慢。

### 4.5. 缓存友好构造

我们可以通过使用语言的本地缓存友好结构而不是缓存不友好的结构来使代码缓存友好。

例如，数组[比哈希表](https://www.baeldung.com/cs/hash-tables)和链表表现得更好。原因是数组占用连续的内存，因此对缓存更友好。其他两个结构不是这种情况。

### 4.6. 避免乱序跳转

我们应该避免有许多 if-then-else 分支，即代码中的条件跳转使其执行非线性。它不仅使代码难以理解，而且使任何编译器都难以对其进行性能优化。条件跳转可能会因为分支而导致速度减慢。

例如，假设我们正在检查某个单词列表是否存在英语或法语。为此，我们需要加载目标语言的词典。即使列表已排序，无论执行的分支如何，所需的数据都不会在缓存中。所以，我们在这两种情况下都有缓存未命中：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-115b6cc50d885ae8c24ae85d79b110d0_l3.svg)

解决这个问题的一种方法是预加载更频繁使用的语言的字典，以最大限度地减少缓存未命中。但是，这需要比必要更多的内存。

### 4.7. 使用编译器优化标志

我们还可以通过设置适当的编译器标志使二进制代码对缓存更友好。我们的编译器可以通过使用展开循环、优化函数调用和填充数据结构等技巧来生成更小、更快的二进制代码。

例如，GNU C Compile (GCC) GCC 提供了一个调整标志。该标志优化了底层 CPU 架构代码的内存管理部分。这样，它降低了缓存未命中率。

## 5.缓存不友好的代码

如果一段代码没有充分利用缓存，那么它就是缓存不友好的。

一些可以使代码缓存不友好的特性如下：

-   [乱序跳跃](https://www.baeldung.com/cs/minimum-jumps-to-reach-array-end)太多
-   带有大量参数的函数调用过多
-   高层次的递归
-   即使在最后一次使用后也没有释放内存
-   随机内存访问

### 5.1. 缓存未命中

缓存不友好程序的连续数据访问调用分布在内存中。这会增加缓存未命中率，因此代码需要更长的时间来执行：

![缓存未命中](https://www.baeldung.com/wp-content/uploads/sites/4/2022/09/Cache_miss-1.jpg)

让我们了解这里的流程。CPU 探测缓存中的数据项。缓存没有它导致缓存未命中。然后缓存从系统内存(RAM)中获取相同的内容。如果该项目不在 RAM 中，我们需要从辅助存储中获取它。RAM 从系统磁盘中获取它，将其存储在其页表中，然后将其传输到缓存中。缓存将其存储并转发给 CPU。

一个例子是上面的位图矩阵。如果我们逐列迭代它，我们会得到很多缓存未命中。

## 6.缓存友好代码的特点

缓存友好代码的主要特征是什么？

### 6.1. 参考地点

这是使代码缓存友好的最重要标准。当计算机程序在很短的时间内访问同一组内存位置时，它就实现了。

该地区有两个组成部分：

1.  空间和
2.  颞

空间局部性意味着我们的程序访问地址彼此靠近的指令。

我们可以通过做两件事来实现空间参考。首先，我们密集地打包我们的信息，以便最佳地利用内存。其次，我们将传染性位置分配给可能一起处理的数据项。

这就是当输入[数组](https://www.baeldung.com/cs/counting-inversions-array)不大时[线性搜索](https://www.baeldung.com/cs/linear-search-vs-binary-search)比[二分搜索更快的原因，因为在前者的情况下，我们可以在第一次加载时将整个数组存储在缓存中。](https://www.baeldung.com/cs/hash-lookup-vs-binary-search)

Temporal reference locality 意味着对加载的数据立即进行所有操作。目标是不将中间结果刷新出缓存。

例如，让我们考虑对大浮点数进行算术运算的情况。对于下面的代码，我们将所有的向量计算一个接一个地进行。这样，就没有缓存刷新，我们的代码执行得非常快：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-6a85cbcb6f0b4d7b594893bc49d8cf49_l3.svg)

现在，如果我们在它们之间执行其他指令怎么办？![结果_1](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-3b0289e60f920ff9799f2735fb66fad7_l3.svg)和的值![结果_2](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-a80648c4132846af817a4b0b47f0f3ee_l3.svg)可以在计算之前从缓存中清除![结果_2](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-206b88ad1872605331e045a19afe91c4_l3.svg)：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-5d797c381cf6a743844a0077533c3b07_l3.svg)

当我们开始计算时![C](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-276a76eafbebc4494deafceec7cc4ddd_l3.svg)也是如此。![d](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-b7950117119e0530b9b4632250a915c5_l3.svg)![结果_2](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-a80648c4132846af817a4b0b47f0f3ee_l3.svg)

### 6.2. 预取

影响缓存友好性的另一个因素是预取的使用。大多数现代处理器都有预取指令，用于通知硬件有关即将使用的数据项。在应用程序请求数据之前预取数据可加快其执行速度。

现代处理器有几个硬件预取器，它们分析程序的访问模式并决定预取。例如。基于 Intel 的处理器具有 L2 硬件预取器，可自动检测内存访问并自行发出预取请求。

## 七、总结

在本文中，我们已经了解了编写优化使用缓存的代码的重要性。在我们的设计中有几个好的实践可以使我们的代码缓存友好以获得最佳性能。