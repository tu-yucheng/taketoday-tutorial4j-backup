## 1. 概述

在本文中，我们将研究一些可以在不同代码区域之间安全地共享相同数据的方法，既可以通过字面上共享确切的内存，也可以通过适当地它。

## 2.参考与价值

在许多语言中，例如 Java，我们的大多数变量不存储实际值，而是存储对值的引用或指针：

![截图 2022-03-21-at-07.36.22](https://www.baeldung.com/wp-content/uploads/sites/4/2022/03/Screenshot-2022-03-21-at-07.36.22-300x227.png)

以这种方式工作有一些显着的好处。例如，当我们传递变量时，我们只传递小引用而不是传递大值。

这也可以允许许多不同的变量指向内存中完全相同的值：

![截图 2022-03-21-at-07.38.25](https://www.baeldung.com/wp-content/uploads/sites/4/2022/03/Screenshot-2022-03-21-at-07.38.25-300x150.png)

这可能很有用，因为这意味着两个变量将看到完全相同的数据。然而，这也意味着如果其中一个发生变化，那么另一个将自动同时看到相同的变化。这两个变量总是相同的。

请注意，这仅适用于使用对象时。基元——如int 和byte—— 总是作为准确的值而不是对值的引用来存储和传递。这很好，因为最大的原语——long——通常与引用的内存量相同，而且原语总是不可变的，所以它们无论如何都不能改变。

## 3. 什么是浅拷贝？

在某些情况下，我们可能希望创建一个值的副本，以便两段不同的代码看到相同值的不同副本。例如，这允许一个人以不同于其他人的方式被操纵。

最简单的方法是制作对象的浅表副本。这意味着我们创建一个新对象，其中包含与原始对象相同的所有字段，并具有相同值的副本：

![截图 2022-03-21-at-08.42.03](https://www.baeldung.com/wp-content/uploads/sites/4/2022/03/Screenshot-2022-03-21-at-08.42.03.png)

对于相对简单的对象，这很好用。但是，如果我们的对象包含其他对象，则只会对这些对象的引用。反过来，这意味着这两个副本包含对内存中相同值的引用，这具有优点和缺点：

![截图 2022-03-21-at-08.40.05](https://www.baeldung.com/wp-content/uploads/sites/4/2022/03/Screenshot-2022-03-21-at-08.40.05.png)

在这个例子中，我们的原件和我们的副本都有一个字段“def”指向相同的数字列表。如果其中一个更改列表，另一个将看到相同的更改。然而，因为我们已经制作了原始数据的副本，底层数据仍然在它们之间共享可能会令人惊讶，这可能会导致我们的代码出现意想不到的错误。

## 4.什么是深拷贝？

替代方法是执行对象的深拷贝。这是我们将每个字段从原始字段到副本的地方，但是当我们这样做时，我们执行这些字段的深层，而不是仅仅引用：

![截图 2022-03-21-at-08.39.28](https://www.baeldung.com/wp-content/uploads/sites/4/2022/03/Screenshot-2022-03-21-at-08.39.28.png)

这将意味着新副本是原始副本的精确副本，但没有任何联系，因此对一个副本的更改不会反映在另一个副本中。

## 5.不变性与

制作数据副本的主要好处是，两段不同的代码可以不受干扰地作用于它。如果我们有两段代码，每段代码都给出了完全相同的列表，并且其中一段从中删除了一个项目，那么另一段也会看到该更改。制作列表的副本意味着对一个列表的更改不会在另一个列表中看到。

但是，对象可能代价高昂。对象结构越复杂，它的成本就越高。在某些情况下，可能是不可能的——例如，如果对象表示物理资源，如网络套接字或文件句柄，而不仅仅是一些计算机内存。

但是，还有另一种选择。如果我们的对象是不可变的——也就是说，值永远不会改变——那么在不同代码段之间共享完全相同的值的风险就会小得多。如果我们将我们的列表传递给不同的代码片段，但我们可以保证它永远不会改变，那么我们知道这将是安全的。

然而，编写不可变代码并不总是那么容易，尤其是对于嵌套结构。例如，我们可能有一个只有 getter 而没有 setter 的对象——因此它的字段永远无法更改。这个对象本身是不可变的，但是如果这些字段中的任何一个本身是可变的，那么就会出现同样的问题：

```java
class Immutable {
    private final List<String> names = new ArrayList<>();

    public List<String> getNames() {
        return names;
    }
}
```

在此示例中，不可能更改对象中的名称字段。它将始终指向同一个列表。然而，这里发生了什么？

```java
var immutable = new Immutable();
var immutable2 = immutable;

immutable.getNames().add("Baeldung");
```

即使我们的名称字段永远无法更改，我们仍然设法向其中插入一个新条目。并且这个条目会同时被immutable和immutable2看到，因为它们都指向同一个内存。

## 6. 写时

在某些情况下，我们希望拥有可变的值，但如果不需要，我们不想支付它们的成本。在这种情况下，我们可以使用一种称为 Copy-on-Write 的模式。在这种情况下，我们创建了指向原始对象的副本。但是，一旦我们想要对其进行任何更改，我们将立即原件：

```java
class Original {
    private String value;

    public String getValue() {}
    public String setValue(String value) {}
}

class CopyOnWrite {
    private Original value;
    private boolean copied;

    public String getValue() {
        return this.value.getValue();
    }

    public String setValue(String newValue) {
      if (!copied) {
          this.value = deepCopy(this.value);
          copied = true;
      }
      this.value.setValue(newValue);
    }
}
```

在这里，我们的CopyOnWrite类包装了我们的Original类的一个实例。这意味着可以廉价地共享完全相同的价值。但是，我们第一次在包装器上调用setValue()时，我们会立即停止并制作原始文件的本地副本。

在这一点上，我们正在支付执行深拷贝的成本，但这意味着我们的更改仅在该实例本地发生，在任何其他实例中都看不到。

## 七、总结

在这里，我们看到了一些可以在代码的不同区域之间共享数据的方法，并探索了一些可以做到这一点的方法，这样一个区域就不会无意中影响另一个区域。