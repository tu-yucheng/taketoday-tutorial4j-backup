## 1. 概述

今天最流行的编程语言是基于面向对象或函数式范例的。

在本教程中，我们将探索它们的特性并进行比较。

## 2. 面向对象程序设计

定义面向对象语言的最重要的构建块是对象本身。没有对象就谈不上面向对象。

面向对象有多种形式。例如，基于类的继承(如 Java 或 C#)或原型继承(如 JavaScript)。最重要的是，[对象包含许多核心概念](https://www.baeldung.com/cs/oop-modeling-real-world)。对我们来说，重要的是封装。

封装指出一个对象包含数据和对数据起作用的操作。此外，在纯面向对象的语言中，操作(函数)不能存在于对象之外。

简而言之，对象专注于数据。操作仅在之后进行。

例如，Java 是一种纯面向对象的语言。同时，JavaScript 或 C++ 不是。甚至 lambda 表达式和方法引用也没有改变 Java 纯面向对象的本质，因为它们只是定义类的语法糖。

由于原始值不是对象，因此这些值的存在在理论上使 Java 不纯。然而，摆脱原始值会使语言变得相当不方便。

## 3. 函数式编程

在[函数式编程](https://www.baeldung.com/cs/functional-programming)中，函数是一等公民。例如，它们可以作为参数传递给其他函数，或者我们可以将它们存储在变量中。

函数获取参数，对其进行操作，通常返回结果。函数也可能有副作用(例如，修改局部或全局状态、执行 I/O 操作等)。

然而，我们更喜欢纯函数，它有以下两个特点：

-   对于相同的输入，它们总是有相同的输出(因此，它们不依赖于任何状态，只依赖于输入)
-   他们没有副作用

由于这些属性，纯函数是确定性的、更可测试的，并且更容易与其他函数一起使用。

请注意，没有返回值的函数只有在有副作用时才有用。

从理论上讲，所有这些听起来都不错，但只有纯函数的应用程序不会有这样的用途。原因是如果没有副作用，它就无法产生任何有意义的输出，因为它需要 I/O 操作。

综上所述，函数式编程重在操作而不是数据。

函数式语言的一些例子有 Haskell、[Scala](https://www.baeldung.com/scala-intro)、Clojure 或 Erlang。

## 4.比较

面向对象和函数式编程有不同的基本概念，但这对我们意味着什么？他们有多不同？

事实证明它们非常不同。它们非常不同，因为我们只能像比较两条垂直线一样比较它们。事实上，我们经常说它们是正交范式。但是这是什么意思？

这意味着它们并不相互排斥。函数式语言可以具有面向对象的特性，而面向对象的语言可以具有函数式特性。我们称这些语言为多范式语言。

Java 被认为是一种面向对象的语言，它具有流 API，这有助于编写函数式代码。同样，C# 也有 LINQ。

另一方面，对象可以用作函数式语言中的数据结构。最重要的是，Scala 甚至还有类。

即使 OO 语言没有对函数式编程的一流支持，我们也可以通过单一方法使用不可变对象和模型函数作为辅助对象来模拟它。

同样，在函数式语言中，我们可以创建对封装数据进行操作的对象。如果语言允许变量重新分配，则对象可以是可变的。否则，我们只能拥有不可变的对象。

## 5.什么时候使用哪个？

由于 OO 专注于数据，因此它非常适合数据建模。另一方面，由于函数式编程侧重于操作，因此它应该用于处理数据。

事实上，Java 8 在其流 API 中使用了相同的理念。为了对数据建模，我们使用类，因此使用 OO 原则。要处理该数据，链式操作函数式。使它更具可读性的是定义我们想要做什么操作而不是我们想要如何进行处理。

## 6.接下来会出现什么范式？

[Robert C. Martin 在他的名著 Clean Architecture](https://www.pearson.com/us/higher-education/program/Martin-Clean-Architecture-A-Craftsman-s-Guide-to-Software-Structure-and-Design/PGM333762.html)中有一个范例概述的简短章节。它用以下句子总结了结构化、面向对象和函数式编程：

>   结构编程对控制的直接转移施加了纪律。
>
>   面向对象编程对间接控制转移施加了约束。
>
>   函数式编程在分配时强加纪律。

之后，他写道：

>   请注意我在介绍这三种编程范例时特意设置的模式：每种范例都从程序员身上移除了一些能力。它们都没有增加新的功能。每一个都强加了某种额外的纪律，而这在其意图上是消极的。范式告诉我们不该做什么，而不是告诉我们该做什么。
>
>   看待这个问题的另一种方法是认识到每种范式都会从我们身上夺走一些东西。这三个范例一起删除了 goto 语句、函数指针和赋值。还有什么东西可以带走吗？
>
>   可能不会。因此，这三种范式很可能是我们将看到的仅有的三种——至少是仅有的三种负面范式。进一步证明不再有此类范式的证据是，它们都是在 1958 年至 1968 年的十年内发现的。在随后的几十年中，没有添加新的范式。

## 七、总结

在这篇简短的文章中，我们看到面向对象和函数式编程并不相互排斥。他们都有自己的长处，通过结合这些，我们可以获得一个比两者都更好的工具。