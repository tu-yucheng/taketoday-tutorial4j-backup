## 1. 概述

在本教程中，我们将探讨哪些 API 和 ABI 与我们的软件有关，它们对其他消费者和我们意味着什么，以及我们在更改它们时需要考虑的事项。

## 2. 什么是API？

API 或“应用程序编程接口”定义了一个软件如何与另一个软件交互。

这可能发生在通过 Internet 交互的两个不同应用程序之间。例如，一个 HTTP API 可能使用[OpenAPI](https://www.baeldung.com/spring-rest-openapi-documentation)进行记录，这允许其他应用程序始终如一地与其交互。然后，这将定义发送到服务器的 HTTP 消息以及可以预期收到的响应。

或者，软件库也有 API。这些描述了应用程序如何与库交互。例如，构成库的可访问接口的类和方法被认为是 API。然后，这定义了应用程序——或者实际上是其他库——如何与它正确交互。

我们在应用程序的所有级别都有 API，但并不总是在我们期望看到它们的地方。例如，相对明显的是，我们的数据库驱动程序公开了我们用来与数据库通信的 API。

然而，我们的数据库模式也是一个 API——它描述了我们可以和不能放入数据库的内容，并确保数据保持一致和有效。对架构的更改将需要对访问它的软件进行更改，就像对驱动程序进行更改一样。

我们的 API 也不必总是同步的。放入消息队列的消息或通过电子邮件发送的文件内容可以构成一个 API，就像我们代码中的函数定义一样。这些都应该考虑在内，并且权衡更改它们的后果，因为它们可能会对我们的应用程序或依赖它们的应用程序产生意想不到的副作用。

## 3. 什么是 ABI？

ABI 或“应用程序二进制接口”类似于 API，但以编译代码而不是源代码表示。

例如，在 Java 应用程序中，库的 API 是库的源代码，而 ABI 是应用程序根据其工作的类文件。

通常，一个软件的 ABI 直接链接到 API。这并不奇怪，因为 ABI 只是 API，而是以编译形式表示。然而，两者的确切性质意味着有时对其中一个的更改不会导致另一个发生更改。

例如， Java 中的[类型擦除](https://www.baeldung.com/java-type-erasure)意味着特定的更改不会在编译的类文件中表达。以下两个函数定义在源代码中看起来不同，但在类文件中的表达方式相同，例如：

```java
public List<String> getStrings() {}

public List<Integer> getInts() {}
```

在这两种情况下，实际的类文件都是：

```java
public List getStrings() {}

public List getInts() {}
```

所以我们可以看到，更改返回值的泛型是 API 中的一个重要细节，但根本没有反映在 ABI 中。

相反，有可能在根本不更改 API 的情况下进行影响 ABI 的更改。这种情况很少见，但如果我们不小心，仍然会发生。一个关键示例是使用不同的编译器编译相同的源代码。如果我们将相同的类构建到 Java 8 或 Java 17 字节码中，那么 ABI 是不同的，即使输入 API 是相同的。

### 3.1. 没有 ABI 的 API

请注意，并非所有 API 都有对应的 ABI。例如，任何纯[解释性语言](https://www.baeldung.com/cs/compiled-vs-interpreted-languages)(如 JavaScript 或 Python)都不会将任何编译输出视为 ABI。

同样，并非所有 ABI 都是显而易见的。通过 HTTP 表达的 API 将有一个 ABI——在机器之间传输的文字字节——但在描述如何与远程系统交互时，这通常不被视为重要的细节。

在这种情况下，确切的细节通常对我们是隐藏的，因为我们使用其他软件层来执行我们的交互。当我们调用远程系统时，我们不需要关心 TCP/IP 数据包或 SSL 加密。我们依赖于 HTTP 客户端的 API，它会为我们完成所有这些工作。这意味着我们的远程服务的确切 ABI 对我们的应用程序不太重要。

## 4. API 和 ABI 兼容性

当任何依赖软件的 API 或 ABI 发生变化时，我们可能必须更改我们的软件以解决这个问题。我们需要进行的更改将取决于相关软件中发生的更改。

如果依赖库的 ABI 没有改变或仅以无关紧要的方式改变，那么我们甚至不需要重新编译我们的应用程序来处理这些变化。ABI 保持不变意味着更改可以用作直接替换。

如果依赖库的 ABI 发生了变化，但 API 没有变化，那么我们将需要重新编译我们的应用程序而不对其进行任何更改。API 保持不变意味着变化在功能上是相同的，但 ABI 不同意味着一些低级细节发生了变化——例如，某些结构的确切内存布局或某些常量的确切值。

如果 API 发生了重大变化，我们将不得不更进一步，更改我们的软件以使用新的 API。例如，如果方法添加或删除了参数。

### 4.1. 语义版本控制

为了让我们软件的消费者了解我们更改的后果，我们拥有一致的版本控制策略非常重要。 [语义版本控制](https://www.baeldung.com/cs/semantic-versioning)就是这样一种非常流行的策略。

请注意，如上所述，我们可能必须彼此独立地对 API 和 ABI 进行版本控制。但是，通常仅对 API 进行版本控制并允许消费者推断 ABI 兼容性就足够了。

使用语义版本控制时，我们的版本号具有三个关键组成部分——主要、次要和补丁：

如果主要版本发生变化，则表明 API 或 ABI 发生了不兼容的变化。这意味着消费者将不得不更改他们的代码以升级到这个新版本。

例如，删除方法，或向方法添加或删除参数将被视为重大版本更改。依赖于此方法的任何代码将不再编译或工作，必须进行更改。

如果主版本没有变化，而次版本发生了变化，这表明有功能上的变化，但不是向后不兼容。这通常意味着新功能已添加到 API，但现有功能未更改。通常，尽管并非总是如此，这意味着 ABI 已更改，但 API 与旧版本完全兼容。

例如，向 bean 添加一个新的可选字段将被视为次要版本更改。依赖于它的代码不需要更改，但内存中的 bean 布局已更改，因此可能需要重新编译代码才能继续工作。

如果只有补丁版本发生变化，则表明 API 未发生变化。这通常意味着 API 的实现略有变化，但 API 本身没有变化。这可能意味着 ABI 也没有变化，但并非总是如此。

例如，放宽哪些字段可以为空的规则可能算作补丁更改。API 或 ABI 中的任何内容都没有更改，所有旧代码将继续发挥相同的作用，无需进行任何必要的更改。

## 5.总结

在这里，我们简要概述了 API 和 ABI 的构成，以及何时需要考虑对它们进行更改——无论是我们自己进行的更改，还是我们所依赖的库或应用程序中的更改。

我们还研究了如何通过合理的版本控制策略向其他人表达这些更改。