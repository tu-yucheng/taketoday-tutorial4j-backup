## 1. 概述

尽管我们经常将微服务视为完全独立和自包含的单元，但情况并非总是如此。有时在系统级别思考并失去一些自主权会更方便。

让我们深入研究这些交叉问题并找出它们是什么。

## 2. 安全

首先要考虑的事情之一是这种架构风格如何涉及安全性。[微服务架构](https://www.baeldung.com/spring-microservices-guide)，就其本质而言，比其他模式更加分布式。组件之间的调用更大，我们必须特别注意旨在保护静态、传输和使用数据安全的策略。

鉴于这种性质，最脆弱的部分是 API。构建[API 网关](https://www.baeldung.com/spring-cloud-gateway)变得有利，因为它充当来自外部调用的单一入口点。通过这种方式，可以通过适当的白名单减少攻击面，从而防止恶意行为者的潜在攻击。

保护端点至关重要。出于这个原因，我们还必须探讨授权和身份验证的主题。如今，管理授权的事实标准是[OAuth / OAuth2 流程](https://www.baeldung.com/spring-security-oauth)。另一方面，双因素身份验证有助于防止和检测身份验证部分的不必要和恶意访问。

## 3.配置管理

微服务配置管理涉及微服务本身和使用它们的应用程序的变更跟踪过程。在微服务架构中，对单个微服务的更改可能会影响整个架构。这意味着它可能会影响每个消费者。

也就是说，我们必须跟踪所有微服务的部署及其配置。通过这种方式，通过添加所有周围元素(例如[Kubernetes](https://www.baeldung.com/ops/kubernetes)集群、与托管它们的基础设施相关的信息)，我们可以在游戏中获得完整的画面。

假设我们的集群中运行着数百或数千个微服务：我们需要一个集中的地方，所有微服务都可以根据它们运行的环境进行特定配置。

## 4. 日志聚合和分布式追踪

日志记录是软件应用程序的重要组成部分，让我们知道代码在运行时做了什么。它使我们能够看到事情何时按预期执行，也许更重要的是，它可以帮助我们在问题未按预期执行时进行诊断。

拥有微服务架构会导致在基础架构上运行多个微服务。我们也可能有同一个微服务的多个实例。每个微服务都以标准格式编写自己的日志，并包含信息、警告、错误和调试消息。

由于其天生的关注点分离，我们经常需要在这些类型的系统中涉及多个微服务来满足单个请求。
这就需要从所有微服务中收集和聚合日志，其次，需要一种机制来关联观察整个旅程请求所需的所有内部调用：

 

![日志聚合](https://www.baeldung.com/wp-content/uploads/sites/4/2021/07/Log-Aggregation.png)

 

这些日志聚合工具利用关联 ID (CID)，我们对一组相关的服务调用使用单个 ID。例如，可能因客户端请求而触发的调用链。通过将此 ID 作为每个日志条目的一部分进行记录，有助于隔离与给定呼叫流关联的所有日志，从而使故障排除变得更加简单。

## 5.服务发现和负载均衡

弹性和可靠性是微服务最能支持的两个特性。

基于微服务的应用程序通常在虚拟化或容器化环境中运行。服务实例的数量及其位置动态变化。这就是服务发现和负载平衡等策略发挥作用的地方。我们需要知道这些实例在哪里以及它们的名称，以便分发来自外部的传入呼叫。

[我们可以将服务发现](https://www.baeldung.com/spring-cloud-consul)想象成一个服务注册中心，它跟踪每个实例的位置和名称。简而言之，当一个新实例被提供并准备好接受请求时，它会将其准备就绪情况传达给指定的节点。后者监视所有实例的情况，例如，通过 ping/echo 或心跳策略。

另一方面，负载均衡是指我们需要根据算法将负载分配给多个实例中的一个，当实例不再健康时将其移除，并在它们恢复时将其重新打开。其他有用的功能可以是例如 SSL Termination，用于管理传入呼叫流量传输和微服务之间的数据安全：

 

![负载平衡 1](https://www.baeldung.com/wp-content/uploads/sites/4/2021/07/Load-Balance-1.png)

 

服务发现和负载均衡都是由[服务网格](https://www.baeldung.com/ops/istio-service-mesh)等工具或 Kubernetes 等编排系统提供的。

## 6. 共享库

DRY(不要重复自己)是引导我们创建可重用代码的原因。总的来说，这是有道理的。谈到微服务，一个常青的话题是是否使用共享库。当然，能做并不代表做就是对的。

第一点是，如果我们谈论共享代码，我们就会减少拥有异构技术的自由。Java 共享库可以影响我们构建其他基于 Java 的微服务。这不一定是骗局，但应该强调。

基本上，实施微服务意味着分担责任和减少耦合。引入共享库违背了这种架构风格的主要理念。了解我们为什么要引入共享库很重要。如果我们正确地应用了诸如[DDD](https://www.baeldung.com/java-modules-ddd-bounded-contexts)之类的技术，我们将拥有一个非常内聚和低耦合的架构。我们希望保留这些概念。

当我们的微服务中有一个共享库时，我们必须接受对其代码的更改迫使我们重新分发这些微服务，从而破坏微服务的基本属性之一：独立可部署性。
如果我们不想增加部署的复杂性，或者走极端，发现自己正在处理分布式单体，那么最好保留此属性。

在微服务中共享代码不一定总是错误的，但绝对是三思而后行的事情。

## 7.边车

Sidecar 模式可能是所有问题中最具交叉性的问题。当我们谈论微服务架构时，我们也谈论拥有多语言系统的可能性。换句话说，我们可以根据需要解决的任务自由选择语言、技术或框架。

这可能会导致拥有使用不同语言的微服务，从而使维护关注的横切库变得更加困难。
一种解决方案是边车模式。横切关注点的逻辑放在它自己的处理器容器(称为边车容器)中，然后链接到主要应用程序。类似于摩托车 sidecar 与摩托车的连接方式，sidecar 应用程序连接到主应用程序并与其一起运行：

 

![边车](https://www.baeldung.com/wp-content/uploads/sites/4/2021/07/Sidecar.png)

 

然后，sidecar 应用程序可以处理日志记录、监控、授权和身份验证等问题，以及其他横切问题。通过这种方式，每个微服务都将拥有与其他微服务相同的 sidecar 实例，从而增加了横切关注点的可维护性和管理性。

## 八、总结

本文讨论了一些与微服务架构相关的更有趣和有用的横切关注点。正如我们所见，我们可以决定创建可重用的实现以在许多微服务中使用或在每个微服务中实现此类关注点。对于前者，我们创建了微服务之间的耦合，而后者则需要一些额外的努力。根据我们系统的上下文，有必要选择正确的权衡。