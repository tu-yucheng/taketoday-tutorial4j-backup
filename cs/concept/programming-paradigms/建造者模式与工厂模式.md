## 1. 概述

在本教程中，我们将学习并强调 Builder 和 Factory 模式之间的主要区别。这两种特殊模式造成了严重的混淆，因为它们具有相似的意图并且经常一起工作，因此更难看出它们的主要区别。此外，它们有几种只会增加混乱的“味道”。

## 2. 广义解释

Factory 和Builder 是创建型模式，它们的主要职责是为对象创建提供一种方便且可扩展的方式。但是，它们有不同的意图和实现方式。同时，他们也有很多共同点。为了更好地理解这些差异和共性，让我们首先更详细地回顾一下这两种模式。

## 3.建造者

Builder 模式的主要目的是帮助创建复杂的对象。对象的复杂性需要一步一步的创建，不能或很难简化为参数列表。但是，此模式有两个版本，它们的目标和意图截然不同。

### 3.1. 简单的生成器

这个版本[的Builder](https://www.baeldung.com/creational-design-patterns#builder)模式主要是为了让对象的创建更加方便。当对象具有可选字段并且可能有太多组合时，此模式很有用。通常这个问题是由伸缩构造函数解决的，这会使代码混乱并使其更容易出错。让我们考虑以下使用伸缩构造函数的情况：

![img](https://www.baeldung.com/wp-content/uploads/sites/4/2023/01/User_telescopic.png)

构造函数的数量将呈指数增长，以涵盖所有可能的选项。此外，如果对象包含相同类型的字段，则可能无法创建所有变体，因为大多数语言的规则都是压倒一切的。最后一点是，如果我们混淆参数的顺序，可能会导致难以调试的问题：

![img](https://www.baeldung.com/wp-content/uploads/sites/4/2023/01/User-with-constructors-2-300x257.png)

在这种情况下，Builder 模式将是使此类更易于维护的合理方法。有时，创建一个基础对象并使用 setter 完成配置是可能的，这是解决问题的简单方法。但是，我们不能将其用于不可变对象。此外，如果对象包含特定的创建规则，我们可能无法检查它们，逐步创建对象：

![img](https://www.baeldung.com/wp-content/uploads/sites/4/2023/01/User-with-builder-1024x262.png)

UserBuilder是一个专用对象，它将存储所有元素并一次性创建一个对象。既然如此，我们就可以说说分步创建对象的错觉。虽然界面会造成这种错觉，但模式的主要力量是一次制作整个对象并确保所有规则和约束。

### 3.2. 经典生成器

这个版本的模式旨在提供一种分步创建复杂对象的方法。复杂性不是来自参数的数量，而是来自对象的结构，这在大多数情况下适用于[Composite](https://en.wikipedia.org/wiki/Composite_pattern)对象。内部结构复杂的对象往往不能用参数的个数来表达。具有[子部门的部门](https://www.baeldung.com/java-composite-pattern)是 Builder 的一个很好的应用程序。

这种模式非常灵活，可以用于复杂对象的整个层次结构。同时，它也可以用于层级之外但创建步骤相同的对象。例如，迷宫和迷宫地图都是非常复杂的对象，并且具有相同的创建步骤。但是，它们不属于同一层次结构。

创建对象的步骤或规则被提取到Director类中。此类包含对象创建的完整知识。通常，它涉及图形遍历逻辑。如果我们想将一个 HTML 网页转换成一个对象，我们将使用一个算法，通常是递归的，而不是一个包含几个步骤的方法：

![img](https://www.baeldung.com/wp-content/uploads/sites/4/2023/01/builder-overview-e1672143662351.png)

### 3.3. 概括

因此，我们有两种类型的这种模式。但是，它们的目标和实现方式不同。我们可以区分这些模式，因为第一个模式仅用于更容易地创建具有多个字段的对象。第二个用于复合对象，以提供一种逐步创建它们的方法。我们将使用第二种实现来与本文中的工厂模式进行比较。

## 4.工厂

工厂模式也有两种实现方式和一种习语，它不被视为一种模式，但被广泛使用。让我们找出它们之间的区别。

### 4.1. 工厂成语

我们想要使用这个习惯用法有两个原因：单一责任原则和代码重复。如果创建和选择实现的代码在我们的业务逻辑中，这就打破了单一责任原则。将实例化逻辑移动到单独的方法或类中可以使代码更简洁。

使用这个习惯用法的另一个原因是为了避免代码重复。在我们的代码库中保持创建对象的代码一致是一个好主意。这也将提供一种在一个地方更改它的便捷方法。从技术上讲，对象本身可以提供方便构造的方法。因此，没有必要为此创建专用类。

可以通过将代码移至单独的方法或类中来实现此习惯用法。因为它只是使用干净代码的原则，而不创建工厂层次结构，所以这被认为是一种编程习惯用法。这种技术对于只有一个工厂就足够的简单情况很有帮助。

### 4.2. 工厂模式

[工厂模式](https://www.baeldung.com/java-factory-pattern)类似于[模板](https://en.wikipedia.org/wiki/Template_method_pattern)模式。但是，它创建一个对象而不是包含业务逻辑。与前面的习惯用法的主要区别在于此模式使用多态性：

![img](https://www.baeldung.com/wp-content/uploads/sites/4/2023/01/factory-overview.png)

此模式有两个目标，允许一种方便的方式来更改工厂和创建对象。此外，它还可以封装普通对象的创建。此外，工厂可以接受参数，以便在创建对象时非常灵活，并且表现得像构造函数的包装器。

### 4.3. 抽象工厂

[抽象工厂](https://www.baeldung.com/java-abstract-factory-pattern)的主要目的是为不在同一层次结构中的对象创建一个完整的家族。为不同风格或不同型号的家具创建在风格上相互契合的 UI 元素就是这种模式的好例子：

![img](https://www.baeldung.com/wp-content/uploads/sites/4/2023/01/abstracto-factory-overview-e1672145039737.png)

## 5.先决条件和意图

这两种模式都是为了让对象的创建更加灵活方便。但是，它们有不同的先决条件和意图。

建造者的先决条件：

-   结构复杂的对象
-   对象的层次结构遵循相同的步骤或算法

工厂的先决条件：

-   对象创建非常简单
-   利用多态性提供所需类型的对象

这些模式的主要混淆是它们有不同的实现，而且，这些模式可以一起工作，并且在某些情况下可以互换使用。

## 6.总结

本文重点介绍了工厂模式和构建器模式之间的异同。这些模式有时很难区分，因为它们有多个可以合并的实现。但是，它们的主要区别在于主要目标和解决的问题。工厂提供了一种解决不同相关对象创建的方法。相反，Builder 有助于创建具有复杂内部结构的对象。 