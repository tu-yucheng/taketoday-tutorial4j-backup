## 1. 概述

在本教程中，我们将使用两个队列来实现堆栈数据结构。

## 2. 栈和队列基础

在继续算法之前，我们先来了解一下这两个数据结构。

### 2.1. 堆

在堆栈中，我们以 LIFO(后进先出)顺序添加元素。这意味着最后插入堆栈的元素将是第一个被移除的元素。栈的基本操作是：

-   push — 在顶部插入一个元素
-   pop — 从顶部移除一个元素

### 2.2. 队列

在队列中，我们以 FIFO(先进先出)顺序添加元素，这意味着第一个插入的元素是第一个被移除的元素。队列的基本操作是：

-   enqueue — 在后面插入一个元素
-   dequeue — 从前面移除一个元素

## 3.算法

要使用两个队列( q1，q2 )构造堆栈，我们需要使用队列操作来模拟堆栈操作：

-   推

    (

    E

     

    元素

    )

    -   如果q1为空，则将E入队 到q1
    -   如果q1不为空，则将q1到q2的所有元素排入队列，然后将E排入q1，并将q2的所有元素排回q1

-   流行音乐

    -   从q1中取出一个元素

如我们所见，q1充当堆栈的主要来源，而q2只是我们用来保留堆栈预期顺序的辅助队列。

push和pop操作的伪代码是：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-34b21b420c42f68cec6f25a8984cf54b_l3.svg)

---------------------------------------------------------------------------------

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-8eba4e8d12e4a2b50dc18c96cbc234b5_l3.svg)

pop操作的时间复杂度为O(1)。对于推送操作，我们的时间复杂度为O(n)，因为我们必须将n -1 个元素从q1传输到q2并从q2传输回q1。

## 4。总结

在本教程中，我们介绍了使用两个队列构造堆栈的算法。

请注意，即使这样做没有真正的优势，它也教会了我们实际的编程经验，并向我们展示了我们可以组合和重用数据结构来实现我们的目标。在我们关于[常见和有用的数据结构](https://www.baeldung.com/cs/common-data-structures#stacks-queues)的文章中更详细地介绍了堆栈和队列。