## 1. 概述

变量是内存中的占位符，用于存储值和计算结果。变量有五种类型：常量、全局变量、类变量、实例变量和局部变量。每种变量类型都有不同的作用域、用途和生命周期。

在本教程中，我们将解释全局变量。

## 2. 什么是全局变量？

全局变量是在任何函数外部声明的变量，我们程序中的所有例程都可以访问它。所以，它的作用域是全局的：它在我们运行我们的软件时被初始化，并在程序运行时持续存在。

我们主要在模块文件的顶部声明全局变量。我们在程序中任何时候定义的任何函数都可以更改任何全局变量。

例如，在下面的 Python 代码片段中，companyName是一个全局变量：

```python
companyName = "My Company"

def printName(): 
    print(companyName)
```

函数printName()可以访问全局变量companyName，即使它是在函数外部声明的。

## 3. 为什么要使用全局变量？

我们可以将全局变量用于许多目的，例如用于存储常量文字，因为这可以提高我们程序的一致性。

此外，由于我们可以从程序中的任何函数访问全局变量，我们只需要声明一次，从而缩短了我们的代码。

因此，全局变量使编码更容易，并减少了生产时间。

## 4. 全局变量有什么问题？

然而，它们并非没有缺点。

### 4.1. 无意的改变

它们的主要问题是它们值的任何变化都会传播到整个程序。这种更改通常是错误完成的，或者是某些其他操作的副作用。反过来，这可能会导致细微的编程错误，从而导致意外行为。

例如，假设我们有一个更新全局变量用户名的函数storeUsername ()和另一个使用全局变量用户名来检查用户对资源的访问权限的函数checkAccess() 。此外，假设用户使用我们使用的语言集以外的语言集输入他们的用户名，并且函数storeUsername () 不检查它。然后，我们可能会得到意想不到的结果，因为checkAccess () 可能会或可能不会失败：

```python
username = "Admin"

def storeUsername(name):
    username = name
def checkAccess(resource):
    if username = 'Admin':
        return True
    else:
        return False
```

我们会发现追踪此类错误极其困难。相反，我们可以很容易地追踪到涉及局部变量的类似错误。这是因为局部变量只有局部作用域。

### 4.2. 全局变量降低了模块化和灵活性

当我们使用全局变量时，我们会降低代码的模块化程度、灵活性和[可扩展性。](https://www.baeldung.com/cs/scalability-vs-elasticity)

例如，如果两个模块共享一个全局变量，我们不能在不考虑这对另一个的影响的情况下修改一个。

此外，全局变量通常会隐藏设计缺陷，因为它们使我们能够快速交付代码。出于这个原因，我们通常不对全局变量执行任何检查，这可能会导致我们代码生命周期后期出现许多无法预料的错误。

缩放还可能导致引入错误的全局变量的意外更改。由于全局范围，我们会发现很难追溯代码中的错误。这可能会导致代码泄漏、停机和生产力损失。

## 5.如何避免全局变量

让我们检查一些全局变量的替代方法。

### 5.1. 功能齐全的方法

我们可以编写函数，让它们在输入端接收所有必需的信息，并将所有结果返回给调用者，而不是使用全局变量在函数与其调用者之间共享数据。这样，我们就提供了函数运行所需的所有输入。并且没有其他实体可以以任何方式更改此功能的任何输入。这样，我们就可以追踪任何错误的来源。

例如，假设我们有一个全局变量a和函数func1()、func2()和func3()。此外，函数func1()和func2()更新a，func3()将其输入除以它。如果前两个函数中的任何一个将a设置为 0，我们将在func3()中得到一个被零除错误，但不确定是什么原因造成的：

```python
a=1

def func1(x):
    a = x
	
def func2(x):
    a = x

def func3(b):
    return b / a
```

相反，如果我们将所有变量(包括a)作为参数传递，我们就会知道任何被零除错误都是由于func3()将零作为其第二个参数：

```python
def func1(a, x):
    a = x

def func2(a, x):
    a = x

def func3(b, a):
    return b / a
```

### 5.2. 依赖注入

我们可以使用对函数的显式输入来桥接任何[依赖关系。](https://www.baeldung.com/scala/play-di)例如，让我们考虑一个在某些处理后将消息发送到队列的函数。我们可以将它们传递给输入端的函数，而不是将队列凭证保存为全局变量。这样，我们就可以在执行之前满足此函数的所有依赖关系，从而使其完全按照预期运行。

### 5.3. 封装

我们应该尽可能地[封装](https://www.baeldung.com/cs/oop-modeling-real-world)数据。这意味着我们应该在该类内部定义一个类所需的所有属性，并使用显式方法来访问或修改它们。

如果我们将一些数据存储在全局变量中，我们将面临无意更改的风险，这些更改会导致难以追踪的错误。

### 5.4. 单例设计模式

此外，我们可以只初始化一次对象，然后只在上下文中使用它们。我们可以使用单例设计模式来实现这一点，其中，我们可以声明一个[单例类](https://www.baeldung.com/java-singleton) 并确保只有一个对象被创建和初始化一次。

## 六，总结

在本文中，我们讨论了全局变量。我们应该谨慎使用它们，因为它们会引入错误并降低我们代码的模块化程度。但是，我们可以安全地使用全局变量来跨函数共享常量。