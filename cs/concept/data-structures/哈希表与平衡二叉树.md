## 1. 概述

在本教程中，我们将研究计算机科学中两个非常重要的数据结构——[哈希表](https://www.baeldung.com/cs/hashing)和[二叉搜索树](https://www.baeldung.com/cs/binary-search-trees)(BST)，特别是它的自平衡变体。我们将分析它们之间的主要区别，并根据手头的问题找出使用哪个。

## 2.概述

### 2.1. 哈希表

哈希表(也称为哈希映射)是一种数据结构，用于以未排序的方式将键映射到值。这里的键是指指向我们正在存储的值的唯一标识符。

该概念的一个简单示例是电话簿。想象一下，我们将联系人姓名字符串作为键，并将其对应的电话号码作为我们存储的数据。然而，计算机不能直接将字符串与数据相关联，而是使用数字。

这就是为什么哈希表电话簿中的每个新条目都需要通过计算索引的哈希函数。然后使用该索引指向我们所有联系人数据数组中的一个桶。

稍后，当我们需要给电话簿中的某人打电话时，我们可以通过散列他们的名字并找到相应的值来轻松检索他们的号码。

这个概念非常有效，但也非常依赖于散列函数的选择。一个完美的函数会将每个键分配给一个唯一的桶，但实际上，哈希表实现使用了一个不完美的哈希函数，这可能会导致两个不同的输入产生相同的索引。

在我们的例子中，这意味着两个名字不同的人会指向同一个电话号码。这也称为冲突，通常使用开放寻址或链接等方法来解决。

### 2.2. 自平衡 BST

如果一棵树的每个节点最多有两个孩子，称为左孩子和右孩子，则称这棵树为二叉树。

二叉搜索树是一种二叉树，其内部节点每个存储一个键，每个节点都有两个不同的子树，通常再次表示为左 和 右。 此外，每个节点中的键大于该节点左子树中的所有键并小于其右子树中的所有键。

这种特殊的结构允许以整齐有序的方式存储数字等数据，但对其进行的大多数操作所花费的时间与树的高度成正比。因此，为了使树的高度尽可能小，可以应用树旋转例程。如果存在这样的例程，则该树称为自平衡树。典型的变体包括 AVL 树、[B 树](https://www.baeldung.com/cs/b-trees-vs-btrees)、[红黑树](https://www.baeldung.com/cs/red-black-trees)等。

## 三、注意事项

### 3.1. 速度注意事项

哈希表的速度主要取决于哈希函数的选择，因为碰撞会减慢对所需元素的访问。哈希表上的操作(如插入、删除和搜索)速度极快且![O(1)](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-66c97a4dfb9f2e2983629033366d7018_l3.svg)平均。

然而，如果我们有一个非常糟糕的哈希函数，它总是指向同一个桶，我们能得到的最糟糕的是![在)](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-f8d599809b2f7987726c648086c1981d_l3.svg)。在这种情况下，我们遍历数组或链表中的所有元素：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-d4f2e8f6234417e07f3ada5f2577ae5d_l3.svg)

哈希表需要线性时间的另一种情况![在)](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-f8d599809b2f7987726c648086c1981d_l3.svg)是表增长大于最初分配的大小。然后它必须将自己重新创建到一个更大的表中并重新散列其中的每个元素。这使得哈希映射在处理不断增长的实时数据时不太适合。

自平衡二叉搜索树中相同的插入、查找和删除操作的时间复杂度是![O(日志(n))](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-b15503718d0ccc0cf4cf9137e087efc0_l3.svg)平均的。当我们只考虑这三个操作时，与哈希表相比，这要慢得多。

也就是说，如果应用程序需要更复杂的任务，例如查找最接近数字的较低或较大元素或进行范围查询，那么相比之下，BST 的排序结构会更快地进行搜索。

### 3.2. 内存注意事项

二叉搜索树通常是内存高效的，因为它们不会保留比他们需要的更多的内存。另一方面，如果我们不知道要存储的元素的确切数量，哈希表可能会要求更高一些。

通常，哈希表会分配一个数组，并通过按这个数组的大小统一哈希来避免冲突。因此，如果我们有一个最初为 100 个元素保留内存的哈希表，但只使用了 20 个，剩余的内存将被浪费。

## 4。总结

在本文中，我们回顾了哈希表和自平衡二叉搜索树，研究了它们各自的细节，并在不同的场景中对它们进行了比较。

哈希表相对于自平衡二叉搜索树的主要优势是访问速度恒定。当最大条目数已知时，它是部分有效的，因此底层桶数组可以分配一次并且永远不会调整大小。

另一方面，如果我们正在处理需要大量调整大小和复杂查询的动态数据，那么利用自平衡 BST 的排序结构会更有效。