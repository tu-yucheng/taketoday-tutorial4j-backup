## 1. 概述

有效管理数据的技术是计算机科学中的传统热点话题。除了存储数据，高效地从存储中恢复数据是另一个相关问题。

即使使用执行某些特定数据处理的最佳算法，如果不优化数据管理，我们的性能也会很差。因此，恢复和向算法提供数据以及保存其输出成为性能瓶颈。

随着时间的推移，已经提出了几种保存和管理数据的技术。 例如 [数组](https://www.baeldung.com/cs/common-data-structures#arrays)、 [链表](https://www.baeldung.com/cs/linked-list-data-structure)、 [树](https://www.baeldung.com/cs/tree-examples)和 [图](https://www.baeldung.com/cs/graphs)。这些数据结构非常适合多种用途。但是，在其中查找和恢复存储数据的时间复杂度通常高于另一种数据结构：哈希表。

因此，本教程探讨了与哈希表最相关的概念。首先，我们将简要回顾一下散列。因此，我们将研究哈希表及其工作原理。接下来，我们将看到如何解决有关哈希冲突的一些潜在问题。最后，我们将在数据管理的复杂性方面将哈希表与其他数据结构进行比较。

## 2. 哈希基础

在具体研究哈希表之前，我们需要了解 [哈希](https://www.baeldung.com/cs/hashing)。 总之，散列是采用可变长度输入并产生固定长度输出值的过程，称为散列码或散列。

散列函数负责将可变长度输入转换为散列。没有标准的哈希函数。这意味着我们可以根据数据输入的一般预期特征来开发哈希函数。

下图在较高层次上描述了哈希机制的工作原理：

![哈希](https://www.baeldung.com/wp-content/uploads/sites/4/2022/04/Hashing.png)

值得注意的是，哈希函数既可以增加也可以减少可变长度输入的字节数。 因此，如果输入大于散列码，字节数将减少。否则，它会增加。

简而言之，哈希在计算机科学中有多种应用，例如[存储和验证密码](https://www.baeldung.com/cs/simple-hashing-vs-salted-hashing)、[创建消息签名](https://www.baeldung.com/cs/encoding-vs-signing-asymmetric-encryption#signing-data-with-asymmetric-encryption)以及提供数据管理结构(本教程的主题)。

## 3.哈希表

哈希表是将特定键与相应值相关联的数据结构。这些表通常使用关联数组来存储数据。此外，他们使用散列函数来计算数据应该存储在数组的哪个点(索引)。

因此，我们可以将哈希表理解为键值查找。因此，给定一个与值(数据)关联的键，我们可以通过快速查找表来恢复相应的值。

例如，我们可以通过哈希表将人名与他们的个人信息相关联。这样，人们的名字就是我们的原始密钥。哈希函数处理这些原始密钥以确定它们在哈希表中的相应索引，从而提供对个人信息的直接访问。

下图描述了上一段中描述的哈希表及其过程：

![哈希表 3](https://www.baeldung.com/wp-content/uploads/sites/4/2022/04/HashTable3.png)

随着时间的推移，哈希表在计算场景中变得非常流行。 因此，不同的编程语言努力在本地或通过内置库提供这种数据结构。

开发结构的示例有[Java 中的 HashMaps、](https://www.baeldung.com/java-hashmap) Python 中的 dict 类(字典)、c++ 中的 map 类和 Lisp 中的 alist。

哈希表是时空权衡的好例子。如果可用的时间是无限的，我们只能将所有的键都链接到同一个索引上，执行二分查找来恢复特定的数据。

另一方面，如果空间是无限的，我们可以使用完整的键作为索引本身，拥有尽可能多的独立内存桶来存储与键对应的数据。

然而，我们在现实世界中并没有无限的时间或空间。因此，我们最终将处理散列冲突和索引共享，如以下小节所述。

### 3.1. 哈希表中的冲突

由于散列函数将可变长度的键映射到固定长度的索引，因此它们实际上将无限集映射到有限集。这样，最终会发生碰撞。

在哈希表中，冲突意味着哈希函数将多个必需的键映射到同一个索引，从而映射到表的同一个内存桶。

因此，提出了许多技术来解决碰撞。 我们将对最相关的内容进行简要说明：

-   分离链接：分离链接技术通过在哈希表的内存桶中支持链表来解决冲突。所以，映射到同一个内存桶(key产生相同索引)的数据被追加到链表中
-   线性探测：也称为开放寻址，该技术处理冲突，找到第一个索引到已确定的索引，该索引具有空闲内存桶以插入数据
-   调整大小和：一种简单的技术，可在发生冲突时调整哈希表的大小并重新分配其上的数据。此过程旨在解决当前的碰撞问题并避免在不久的将来发生其他碰撞

## 4.数据管理的复杂性

哈希表在数据管理方面是一种很好的结构。这种数据结构采用的key-value方案很直观，能很好地适应不同场景的多种数据。

此外，在哈希表中搜索、插入和删除数据的平均复杂度为 O(1)——一个常数时间。 这意味着，平均而言，无论目标操作如何，单次哈希表查找就足以找到所需的内存桶。

然而，这些操作的最坏情况通常是 O(n) — 线性时间。当哈希表中的所有数据都具有映射到同一索引的键时，就会发生这种情况。

在这种情况下，哈希表会不断执行一种技术来解决冲突。其中一些技术，例如分离链接和线性探测，需要额外的时间来扫描列表或表本身，从而增加了时间复杂度的最坏情况。

但是，设计良好的哈希表通常不会出现冲突。因此，这种数据结构仍然是保存和提供数据的通用且灵活的选择。

### 4.1. 比较哈希表和其他数据结构

自然地，除了哈希表，我们还有其他的数据结构来管理数据。 一个传统的例子是无序列表。对于我们的讨论，让我们考虑一个双链循环列表实现。

在链表中，插入和删除给定元素非常简单。最简单的插入是追加操作。通过定义的操作次数，我们可以在常数时间内将一个新元素添加到列表中——O(1)。类似地，给定一个要删除的元素，我们可以在恒定时间内执行该操作 — O(1)。

需要强调的是，这里我们认为指向元素的指针已经可用于从列表中追加或删除它。

然而，链表最具挑战性的是搜索特定元素。在这种情况下，平均复杂度为 O(n)。发生这种情况是因为我们需要检查每个列表元素，直到找到一个特定的元素。

我们可以通过使用其他技术来降低搜索的复杂性，例如二分查找。但是，在这种情况下，我们需要一个有序链表，这会增加向列表中插入元素的复杂性。

让我们考虑一个有序的双链循环列表。如果我们使用插入排序算法保持列表有序，我们将有 O(n) 的插入复杂度；删除复杂度仍然是 O(1)；并且，使用二进制搜索来查找元素，我们将有 O(log n) 的搜索复杂度。

下表比较了无序列表、有序列表和哈希表的插入、删除和查找操作的平均时间复杂度：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-dcbfe003f08e89e48d813c95142dd2c4_l3.svg)

## 5.总结

在本教程中，我们研究了哈希表。首先，我们回顾了哈希。因此，我们探索了哈希表的数据结构。在此背景下，我们研究了在哈希表中插入、删除和搜索数据的时间复杂度。最后，我们将哈希表中这些操作的时间复杂度与其他数据管理结构进行了比较。

我们可以看到哈希表对于所有考虑的数据管理操作具有诱人的平均时间复杂度。 特别是，搜索数据的恒定时间复杂度使哈希表成为减少算法循环次数的绝佳资源。

最后，尽管在最坏的情况下具有线性时间复杂度，但平衡良好的哈希函数和维度良好的哈希表自然会避免冲突。因此，最坏情况下的时间复杂度往往不会发生。