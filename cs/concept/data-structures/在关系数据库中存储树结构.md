## 1. 概述

在本文中，我们将探索在关系数据库中存储树结构的几种方法。例如，家谱或嵌套的评论层次结构适合这样的模型。

## 2. 问题是什么？

关系数据库非常适合存储表格数据，其中一些数据与其他数据相关。我们可以很容易地将数据存储在两个相互关联的不同表中。例如：

![截图 2022-04-21-at-09.19.39](https://www.baeldung.com/wp-content/uploads/sites/4/2022/05/Screenshot-2022-04-21-at-09.19.39.png)

当关系指向同一个表时这是可能的，但它变得更加复杂。无论是在正确读取数据方面，还是在写入数据和保持完整性方面。如果我们想要一个深度嵌套的结构而不是仅仅一个层次的关系，这会变得更加复杂。

如果我们想读取嵌套树结构的单层，这与任何普通查询相同。但是，如果我们想要读取整个结构，我们需要能够遍历树的多个级别。更糟糕的是，它可能是任意数量的级别，所以我们不能只将其计划到我们的查询中。

反之，如果我们要在一个树结构的底部写一个新节点，那么这就是一个简单的写法。但是，如果我们想写入树结构的中间，或者如果我们想在整个结构中进行更新，这会很快变得非常复杂，并且有可能破坏记录的完整性。

## 3. JSON 对象

实现此目的的最简单方法是放弃关系数据库并将结构存储在 JSON blob 中。这让我们忽略了跨多条记录读写的复杂性，而只是将所有内容存储为一条记录。然后我们将在我们的应用程序代码而不是我们的数据库中进行任何解析和更新。

数据库引擎会自动为我们做很多我们无法从这里受益的事情。然而，这样做往往得不偿失。例如，我们失去了参照完整性的整个概念，无论是在树中的节点之间还是在其他表之间。因为整个树存储在单个记录中，所以不可能有指向单个节点或从单个节点指向其他表的数据库控制的外键。

这也不能很好地扩展。如果我们将整个树存储为单个记录，那么在变得难以读写之前，该记录的大小是有限制的。

## 4. 存储父密钥

一旦我们决定要单独存储每个节点，而不是一次性存储整棵树，我们就需要确定实现此目的的最佳方法。

实现此目的的一种方法是在每个节点上存储其直接父节点的 ID。没有父节点的节点将存储NULL，具有父节点的节点可以存储对该父节点的引用。例如，我们可以将表创建为：

```sql
CREATE TABLE tree (
    node_id INT PRIMARY KEY,
    parent_id INT NULL REFERENCES tree (node_id),
    .... other columns ....
);
```

这将允许我们存储以下树：

![截图 2022-04-24-at-10.39.58](https://www.baeldung.com/wp-content/uploads/sites/4/2022/05/Screenshot-2022-04-24-at-10.39.58-1024x768.png)

如下：

```

```

这为我们提供了数据库中的参照完整性，因为我们可以确保parent_id列中的值也存在于node_id列中。

我们还可以使用一条语句轻松地将记录插入到树中的正确位置：

```sql
INSERT INTO tree (node_id, parent_id) VALUES (6, 5);
```

以及使用单个语句将树的一部分移动到不同的父级：

```sql
UPDATE tree SET parent_id = 1 WHERE node_id = 4;
```

然而，在这里读取整棵树更加复杂。如果没有额外的数据库支持——例如递归公用表表达式——我们必须单独选择树的每个级别并将它们放在我们的应用程序中。同样，读取给定节点的整个祖先列表也需要一次一个地完成。

显然，这将非常低效，那么我们如何改进呢？

### 4.1. 使用递归公用表表达式检索

如果我们的数据库引擎支持递归公用表表达式，则可以使用WITH RECURSIVE子句一次性查询这样的结构。

这样做涉及编写一个查询，该查询实质上将表连接回自身并通知数据库引擎它应该递归地执行此操作，直到它用完所有行。

例如，要查询上表，我们可以这样做：

```sql
WITH RECURSIVE rectree AS (
  SELECT  
    FROM tree 
   WHERE node_id = 1 
UNION ALL 
  SELECT t. 
    FROM tree t 
    JOIN rectree
      ON t.parent_id = rectree.node_id
) SELECT  FROM rectree;

```

这将从选择node_id = 1的节点开始，向下递归树查找t.parent_id = rectree.node_id的行，直到不再返回任何行。如果我们需要列出所有祖先节点而不是所有子节点，则可以编写类似的查询以相反的方向遍历。

这是使用这种树结构的最有效方法，因为我们可以廉价地将记录插入数据库并以相对便宜的方式查询整个树结构。然而，并不是所有的数据库引擎都支持这种形式的查询，所以它可能不是我们的选择。例如，MySQL 在 8.0 中支持，但在更早的版本中不支持。

### 4.2. 标记整棵树

允许我们检索整棵树的另一种方法是使用一个额外的列来标识每个节点所属的树。这可能是根节点的 ID，或整个树的其他标识符。

这意味着我们的表获得了一个额外的列，因此我们存储了更多数据。这也意味着向表中插入记录稍微复杂一些——因为我们需要提供树的直接父代和根。然而，这意味着我们现在可以使用单个查询来选择同一棵树中的每个节点，而不是需要很多：

```sql
SELECT  FROM tree WHERE tree_id = 1;
```

然后我们可以根据这个查询将树结构放在内存中。

不幸的是，我们不能用它来选择子树。我们也无法有效地列出给定节点的所有祖先。我们能做的最好的事情就是列出整棵树并从返回的数据中自己计算出祖先。

但是，根据我们的确切要求，这可能不是问题。

## 5. 关闭表

我们可以使用另一种机制将图形与节点分开存储在所谓的闭包表中。这个平行表将存储每个节点的每个祖先，包括节点与其祖先之间的距离。

例如，上述树的闭包表为：

```

```

这使我们可以非常轻松地搜索整个子树并检索任何给定节点的整个祖先集。

然而，向树中插入和更新节点更加复杂。根据节点的深度，我们将不得不在我们的闭包表中创建或更新许多记录。移动节点也非常昂贵，因为我们需要为正在移动的子树中的每个节点重新计算闭包表。

## 6.存储路径

另一种选择是将整个路径存储在树中，而不仅仅是直接父级。在这种情况下，我们上面的树将存储为：

```

```

在这里，我们的路径列是一个字符串，由树中每个祖先的 ID 组成，由句点字符分隔。一些数据库引擎支持本机数组或可以替代使用的类似构造。

这样做对从我们的表中读取数据有很多好处。每一行都有其整个父级层次结构作为其一部分。我们还可以使用LIKE运算符轻松查询子树：

```sql
SELECT  FROM tree WHERE path LIKE '1.3.%';
```

请注意，我们在末尾添加了一个句点，这样我们就可以进行匹配而不必担心匹配节点的一部分。例如，没有最后句点的以下查询查询：

```sql
SELECT  FROM tree WHERE path LIKE '1.3%';
```

也会错误地匹配任何恰好包含诸如“1.30”之类的值。

向树中插入新记录也相对简单。我们需要知道节点的正确路径，它可以从父节点导出。但是，四处移动节点更加复杂。如果我们只移动一个叶节点，这是唯一需要更新的路径。但是如果我们要移动一个有子节点的节点，那么整个子树都需要更新，并且每个节点都需要按照自己的方式进行更新。

但是，我们以这种方式失去了树中的参照完整性。我们不能让数据库确保父节点都正确存在，因为它们只是结构化字符串的一部分。

我们还需要看看这对我们的需求有多有效。字符串上的LIKE匹配比整数键上的相等匹配效率低，因此如果我们不需要子树查找，这可能会降低效率以获得切实的好处。

## 七、总结

在这里，我们看到了几种可用于在关系数据库中表示分层数据的技术，以及每种技术的收益和成本。下次你需要存储此类数据并且使用专用图形数据库不是一种选择时，为什么不尝试其中一种选择呢？