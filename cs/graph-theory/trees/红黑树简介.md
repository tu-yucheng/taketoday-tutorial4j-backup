## 1. 概述

在本文中，我们将了解什么是红黑树以及为什么它们是如此流行的数据结构。

我们将从查看二叉搜索树和 2-3 树开始。从这里开始，我们将看到如何将红黑树视为平衡 2-3 树的不同表示。

本文的目的是通俗易懂地解释红黑树，因此我们不会深入研究所有可能的插入和删除情况的代码示例或详细示例。

## 2. 二叉搜索树

二叉搜索树 (BST) 是一种树，其中每个节点都有 0、1 或 2 个子节点。没有子节点的节点称为叶子。此外，一个节点的左孩子的值必须小于该节点的值，而右孩子的值必须大于该节点的值。

让我们从一个简单的例子开始：

![二叉搜索树插入平衡](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/binary-search-tree-insertion-balanced-1024x300-1.png)

我们有元素4, 8, 12, 16, 18, 24, 32。我们可以以元素16作为根 (a) 开始我们的树，然后插入8和24 (b)，最后插入元素4、12、18和32 (c)。注意左边的孩子总是比它的父母小，而右边的孩子总是比它的父母大。我们很容易看出树的高度是log n，n是元素的个数。

如果我们想在我们的树中搜索一个元素，我们可以从根开始。如果我们正在寻找的元素等于根，我们就完成了。如果它更小，我们继续向左搜索，如果它更大，我们继续向右搜索。我们继续，直到我们找到元素，或者直到我们到达叶节点(黄色)。很容易看出我们搜索的时间复杂度为O(log n)。

![树不平衡](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/2-3-tree-unbalanced-1024x484-1.png)

然而，树的结构高度依赖于元素插入的顺序。如果我们按24, 32, 16, 18, 12, 8, 4的顺序插入元素，生成的树不再平衡 (d)。如果我们按排序顺序插入元素，结果是一棵树，每个节点 (e) 只有一个孩子。这实际上是一个列表，而不是一棵树。这意味着我们找到一个元素的最坏情况复杂度是O(n)。

## 3.平衡的2-3棵树

### 3.1. 2-3 树的定义

我们现在将查看 2-3 棵树，这有助于我们保持平衡的树，无论我们以何种顺序将元素插入树中。2-3 树是具有两种类型节点的树。一个 2 节点有一个值和两个子节点(同样，左孩子有一个较小的值，右孩子有一个较大的值)，一个 3 节点有两个值和三个子节点。

3 节点的左子节点小于父节点的左值。中间孩子的值介于两个父值之间，右孩子的值大于父母的右值。

###  3.2. 将元素插入 2-3 树

让我们看看如何将元素32、24、18、16、12、8、4插入到 2-3 树中，同时保持树平衡。

![树添加](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/3-2-tree-add-32-24-300x158-1.png)

我们从32开始，它给了我们一棵只有根节点 (a) 的树。然后我们插入24，它在根 (b) 处给我们一个 3 节点。

![树加18](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/3-2-tree-add-18-300x135-1.png)

接下来，我们将插入下一个元素18作为根的左子节点(因为18小于24)。这会导致树不平衡。我们可以通过将24移出 3 节点并使其成为根节点来获得平衡树。

结果将是一棵只有 2 个节点的平衡树 (b)。

![树加16](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/3-2-tree-add-16-300x170-1.png)

我们要插入的下一个元素是16。同样，我们以一棵不平衡的树 (a) 结束。这次我们可以简单地将16向上移动一级，与18 (b)一起形成一个 3 节点。

![树加12](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/3-2-tree-add-12-1024x275-1.png)

接下来，我们插入12作为我们刚刚创建的 3 节点 (a) 的左子节点。为了平衡树，我们首先将12向上移动一层以形成一个临时的 4 节点 (b)。

我们现在可以通过将中间元素16移动到根来拆分 4 节点，这再次为我们提供了一个很好的平衡树 (c)。

![树加8](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/3-2-tree-add-8-300x123-1.png)

8的插入现在非常简单——我们首先创建12 (a) 的左子节点，然后将元素向上移动一级以形成一个包含12 (b) 的 3 节点。

![树加4](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/3-2-tree-add-4-1024x527-1.png)

要插入的最后一个元素4导致插入稍微复杂一些。首先，我们创建一个左节点 (a) 并将其向上移动一层，这为我们提供了一个临时的 4 节点 (b)。现在我们可以将中间元素8向上移动一层以获得根 (c) 处的 4 节点。

在最后一步中，我们通过提取16作为根节点 (d)来拆分 4 节点。

### 3.3. 插入的复杂性

上面的示例表明可以以维护平衡树的方式插入元素。但是，每次插入执行的操作都非常复杂，无法用代码表达。原因是我们需要三种不同类型的节点(2 节点、3 节点和 4 节点)。

此外，我们需要区分几种不同的情况，以便将元素向上移动并合并到 3 节点或将 3 节点拆分为 2 节点。

在下一节中，我们将看到红黑树如何帮助我们降低这种复杂性。

## 4. 红黑树

### 4.1. 对应2-3棵树

红黑树本质上是 2-3 树的不同表示。让我们直接看一个例子：

![红黑树3-2对应](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/red-black-tree-3-2-correspondence-1024x265-1.png)

(a) 中的树显示了我们在上一节中看到的 2-3 树。我们已将 3 节点标记为红色，这直接将我们引导至红黑树。我们将每个 3 节点拆分为两个 2 节点，并将两者之间的链接标记为红色。

这也直接将我们引向了红黑树的两个主要属性：

-   一个红色链接后面总是跟着两个黑色链接(因为我们拆分的 3 节点后面跟着三个黑色链接)。
-   从根到叶节点的路径总是包含相同数量的黑色链接(这直接源于我们的 2-3 树是平衡的这一事实)。

最重要的是，我们添加以下两个条件：

-   只有指向左子节点(较小的子节点)的链接可以是红色的。这个条件进一步简化了实现。
-   所有叶子都有空链接 (nil)。

### 4.2. 为什么这个表示法？

简而言之，它简化了树的实现和操作。我们可以使用与二叉树相同的操作(例如，查找值的工作方式与“普通”二叉树中的工作方式完全相同)。

### 4.3. 插入

要将新值插入红黑树，我们添加一个新节点作为新叶节点。当然，这会导致树不平衡。为了平衡树，我们首先将指向新节点的链接涂成红色。

然后我们只需要三种操作来重新平衡我们的树。让我们来看看这些操作。

![红黑树向左旋转](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/red-black-tree-rotate-left-300x125-1.png)

第一个操作是左旋转。在这里，我们通过移动两个链接将子树 (a) 转换为子树 (b)。

![红黑树向右旋转](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/red-black-tree-rotate-right-300x118-1.png)

第二个操作是右旋，与左旋刚好相反。

![红黑树翻转颜色](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/red-black-tree-flip-colors-300x171-1.png)

第三个操作是翻转颜色。我们可以把两个红色链接改成两个黑色链接，把父链接改成红色链接。

这里重要的是所有三个操作都是本地操作，这意味着它们不会对整棵树产生影响。

在本文中，我们不会查看完整的插入示例。这里要强调的重点是这三个简单的操作使我们能够轻松地重新平衡树。

### 4.4. 插入示例

让我们看一个将元素插入到红黑树中的示例。我们要插入的元素是37(橙色背景)，根显示为蓝色背景。

![红黑树插入一个](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/red-black-tree-insert-a-300x164-1.png)

首先，我们从根开始，沿着树向下走，直到找到要插入元素的叶节点。在我们的例子中，37将是树中最大的元素，所以它在最右边。新节点的链接是红色的，我们得到一棵树，如 (a) 所示。

![红黑树插入b](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/red-black-tree-insert-b-300x160-1.png)

由于父元素36现在有两个红色链接，因此第二步是翻转颜色操作，这将我们引向 (b) 中所示的树。

![红黑树插入c](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/red-black-tree-insert-c-300x171-2.png)

由于现在值为28的节点有两个红色链接，第三步再次是翻转颜色操作，这导致树如图 (c) 所示。

![红黑树插入d](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/red-black-tree-insert-d-300x154-1.png)

因为我们希望所有的红色链接都向左倾斜，所以我们进行了左旋转，这导致了 (d) 中的树，其根为28 。我们可以很容易地看到树是平衡的。

### 4.5. 删除

删除节点后，我们可以使用相同的三个操作来重新平衡树。在本文中，我们不会查看完整的实现，而只会概述思路并给出几个删除元素的示例。

对于所有示例，我们将从以下(有效的)红黑树开始：

![红黑树删除开始](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/red-black-tree-deletion-start-300x165-1.png)

简单的情况是删除带有红色链接的叶节点。让我们看看两种可能的情况，删除2和36。

#### 删除 2

![红黑树删除2](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/red-black-tree-deletion-2-1024x271-1.png)

那是最简单的情况。元素2是一个红色链接的左节点，所以我们可以删除它，直接得到一个有效的红黑树，不需要重新平衡。

#### 删除 36

![红黑树删除 36](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/red-black-tree-deletion-36-1024x282-1.png)

如果我们想删除36，我们再次删除该节点，但是，由于36是红色链接的右侧节点，我们需要将链接从28更改为36以指向32。同样，我们得到了一个有效的红黑树。

#### 删除 8

如果我们想删除一个非叶子节点，我们可以先把它变成一个叶子节点。为此，我们找到左子树的最大元素或右子树的最小元素。这种交换不会改变红黑树的属性。因为我们可以将每个节点移动到树的底部，所以了解如何删除叶节点就足够了。

让我们看看如何删除元素8。左子树的最大值为4 (a)。所以我们交换节点8和4并将其删除。由于8有一个红色链接，我们得到了与删除元素4 (b) 相同的简单情况。

![红黑树删除 8-1](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/red-black-tree-deletion-8-1-1024x257-1.png)

同样，最终的树是一棵有效的红黑树 (c)。

![红黑树删除 8-2](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/red-black-tree-deletion-8-2-300x182-1.png)

#### 删除 24

如果我们想要删除一个不是红色链接的右节点或左节点的叶节点，事情就会变得有点复杂。

例如，让我们看一下24 (a) 的删除。首先，我们翻转24和18(18是左子树的最大元素)。

我们现在需要删除树 (b) 中的24，它没有红色链接。

![红黑树删除 24-1](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/red-black-tree-deletion-24-1-1024x255-1.png)

删除了24的树(c) 不是有效的红黑树，因为18只有一个孩子，所以树不平衡。

![红黑树删除 24-2](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/red-black-tree-deletion-24-2-1024x254-1.png)

我们可以通过旋转 (d) 来平衡树。

## 5. 复杂性

红黑树为插入、搜索和删除提供对数平均和最坏情况时间复杂度。

重新平衡的平均时间复杂度为O(1)，最坏情况复杂度为O(log n)。

此外，红黑树在批量和并行操作方面具有有趣的特性。例如，可以使用时间复杂度为O(log(log n))和 ( n/log(log n))处理器的排序列表构建红黑树。

## 6. 红黑树的应用

红黑树的实际用途包括Java 集合库中的TreeSet、TreeMap和Hashmap。此外，Linux 内核中的 Completely Fair Scheduler 也使用了这种数据结构。Linux 还在mmap和munmap操作中使用红黑树来进行文件/内存映射。

此外，红黑树还用于几何范围搜索、k 均值聚类和文本挖掘。

从上面的例子我们可以看出，红黑树主要是底层使用的，我们作为开发者，虽然每天都在用，但接触的并不多。

## 七、总结

在本文中，我们了解了什么是红黑树，以及它们基本上是 2-3 树的不同表示形式。

我们还看到了一张表格，总结了树上操作的复杂性，最后，我们简短地总结了红黑树的一些实际应用。

但是，在为特定用例选择数据结构时，需要考虑很多因素。如果我们需要良好的插入和搜索平均成本，以及保证这两个操作的对数最坏情况成本，红黑树尤其有用。

此外，如果我们经常更新树，红黑树是一个不错的选择，因为重新平衡成本低于其他平衡树，例如 AVL 或 B 树。