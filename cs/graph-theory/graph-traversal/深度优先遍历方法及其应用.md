## 1. 概述

树遍历是恰好访问树节点一次的过程。 遍历树的方式有很多种，通常根据遍历发生的先后顺序进行分类。它们也可以根据遍历的方向大致分为[深度优先](https://www.baeldung.com/java-depth-first-search)(垂直)或[广度优先](https://www.baeldung.com/java-breadth-first-search)(水平)遍历。

在本教程中，我们将仔细研究三种类型的深度优先遍历：中序、后序和前序。[我们将在二叉树](https://www.baeldung.com/java-binary-tree)上应用我们学到的知识，因为它们更容易表示并且示例更容易追踪。但是，我们可以将这些概念应用于任何类型的图。

## 2. 我们的二叉树示例

下图是二叉搜索树的示例。在接下来的部分中，我们将演示遍历这棵树的不同方法：

![BST](https://www.baeldung.com/wp-content/uploads/sites/4/2020/04/BST.png)

请记住，如果我们使用图形，我们可以选择任何节点作为开始。然而，当我们处理二叉树时，我们总是从根开始遍历，在本例中为 6。

## 3.中序遍历(LNR)

中序遍历的首字母缩写词是 LNR，代表左、节点、右，表示我们遍历树的顺序。

要执行中序遍历，我们递归地执行以下步骤：

1.  遍历左子树
2.  遍历根节点
3.  遍历右子树

从根 (6) 开始，我们检查：

-   它有左孩子吗？确实如此，所以我们检查左孩子 (3) 并询问它是否有左孩子？是的，是的，但是那个孩子 (2) 没有左孩子，所以我们可以遍历它
-   因为这是有序的，我们遍历的下一个节点是 (2) 的根节点，即节点 (3) 后跟右子节点 (4)
-   现在，由于 (4) 没有自己的子树要遍历，我们已经完成了对左子树的遍历，我们可以继续遍历树 (6) 的根，然后是它的右子树

为了遍历正确的子树，我们检查：

-   如果节点(19)有左节点，我们将遍历它；它确实如此，并且它的左节点 (12) 有一个没有要遍历的子节点的左节点 (7)。所以我们遍历 (7) 然后它的根 (12) 然后是右节点 (15)。
-   最后，在处理完它的左子树后，我们回到节点 (19) 并遍历它，然后遍历它的右节点 (30)。

通过这种方式，我们已经按照下图中显示的相同方式使用中序遍历完全遍历了树的节点。注意红色的数字标记了遍历节点的顺序：

![为了](https://www.baeldung.com/wp-content/uploads/sites/4/2020/04/inorder.png)

中序遍历最流行的用途之一是以升序检索二叉搜索树的排序内容。或者，要按降序检索项目，我们可以通过从右子树开始到左子树结束来反转该过程。这被称为反向中序遍历。

## 4. 后序遍历(LRN)

对于后序遍历(左、右、节点)，我们采用不同的顺序，而是从根开始递归地执行以下步骤：

1.  遍历左子树
2.  遍历右子树
3.  遍历根节点

让我们遍历同一棵树，但这次让我们使用后序遍历来完成：

![邮购](https://www.baeldung.com/wp-content/uploads/sites/4/2020/04/postorder.png)

与中序遍历类似，我们首先查看树的根并检查其最左边的节点，直到找到可以开始遍历的左叶节点 (2)。一旦我们遍历了 (2)，我们就遍历了它的右兄弟节点 (4)，然后是它的根节点 (3)。这样，我们就完成了对左子树的遍历，我们可以用同样的方式移动到右子树，留下树的根。

后序遍历在某些没有内置垃圾回收的语言(如 C 和 C++)中有有用的应用。要从内存中释放一个对象，我们必须先访问它的子对象，并在访问它们的父对象之前将它们从内存中释放。如果我们不这样做，我们就会遇到一个我们称为悬挂指针的情况。当我们需要从二叉搜索树中删除节点时，我们也可以使用后序遍历。我们必须先遍历并在根之前删除叶子。

作为称为反向波兰表示法 (RPN) 或后缀表示法的表达式评估方法的一部分，后序遍历在某些时候也非常流行。RPN 用于表达数学公式，无需使用括号来保持优先顺序。例如，使用 RPN 我们可以表示这个数学表达式：

 ![[ (2+3)y - 2 ]](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-96cbb348e9f50547803c80458f5b3c83_l3.svg)

像这样：

 ![[ 2 3 + 和  2 - ]](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-d80d5f3023b534dc034a2d63813c93d0_l3.svg)

这意味着更简单的计算并且更容易被机器解释。历史上，一些惠普计算器和 PostScript 和 Forth 等语言使用了 RPN 并变得非常流行。如今，RPN 在与解析数学表达式相关的领域有非常具体的用例。我们可以通过执行语法树的后序遍历来构造 RPN。

让我们看一个小例子，看看它是如何使用我们上面的数学表达式工作的。

首先，我们将数学表达式表示为表达式树：

![表达](https://www.baeldung.com/wp-content/uploads/sites/4/2020/04/expression.png)

接下来，我们将执行树的后序遍历以获得此表达式的后缀表示法：

![后缀](https://www.baeldung.com/wp-content/uploads/sites/4/2020/04/postfix.png)

## 5. 前序遍历(NLR)

最后，让我们了解一下前序遍历。顾名思义，先序遍历首先遍历根节点，然后分别遍历左右子树。这意味着我们将通过以下步骤遍历树：

1.  遍历根节点
2.  遍历左子树
3.  遍历右子树

看看我们的示例二叉搜索树是如何工作的：

![预购](https://www.baeldung.com/wp-content/uploads/sites/4/2020/04/pre-order.png)

使用这种方法，我们将从遍历根节点 (6) 开始，然后移动到它的左子树。左子树的根节点是(3)，所以遍历完它，我们继续遍历它的左孩子(2)，再遍历它的右孩子(4)，这样就完成了对左子树的遍历。最后，我们以类似的方式遍历右子树，从根节点 (19) 开始，到其右子节点 (30) 结束。

当我们在二叉搜索树中搜索元素时，预序遍历很有用。我们可以使用根节点值来确定接下来是否需要搜索右子树或左子树。此外，数据库通常在搜索操作期间使用先序遍历来遍历 B 树索引。

预序遍历在所谓的拓扑排序中也有应用。假设一个节点是其子节点的先决条件或依赖项，对拓扑有序树的先序遍历对于在依赖项之前列出依赖项很有用。拓扑排序在程序的动态链接和解决依赖关系以及处理器调度方面都有用例。

使用它的一个具体示例是 Linux makefile 实用程序。

## 六，总结

总而言之，我们介绍了一些深度优先遍历方法并了解了它们在现实世界中的应用。尽管我们在二叉树的上下文中讨论了这些方法，但我们也可以将这些概念用于遍历图。

如果我们准备好进入实现细节，[我们现在可以了解更多关于如何在 Java 中实现其中一些方法的信息](https://www.baeldung.com/java-binary-tree)。