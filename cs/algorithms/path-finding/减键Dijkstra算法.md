## 1. 概述

[Dijkstra 算法](https://www.baeldung.com/cs/dijkstra)是最著名的[寻找最短路径](https://www.baeldung.com/cs/dfs-vs-bfs-vs-dijkstra)的算法之一。Dijkstra 算法的主要部分之一是用于遍历[图](https://www.baeldung.com/cs/graphs)中节点的优先级队列，这也是Dijkstra 算法与[BFS的主要](https://www.baeldung.com/java-breadth-first-search)[区别](https://www.baeldung.com/cs/graph-algorithms-bfs-dijkstra)。

在本教程中，我们将考虑该算法的三个版本。人们将使用一个简单的优先级队列，它只支持最小节点的入队和出队。另一种方法将在将新节点加入队列之前检查队列中的现有节点，最后一种方法将支持减少帮助中键的值。

## 2. Dijkstra 算法

首先，让我们回顾一下 Dijkstra 算法背后的思想。在一般实现中，Dijkstra 算法返回从源节点到所有节点的最短路径的集合：

```

```

然而，我们通常只需要确定从源节点到结束节点的最短路径。在这种情况下，我们可以考虑以下版本，它也允许我们根据第 10 行的条件提前退出算法：

```

```

第24 行的CreatePath函数根据有关权重和先前节点的信息重新创建路径。为简单起见，它没有出现在当前算法中，[我们对 Dijkstra 的](https://www.baeldung.com/cs/dijkstra#2-pseudocode)介绍对其进行了解释。本文中的所有示例都将基于此版本的 Dijkstra 算法构建，因为查找两个节点之间的路径是最常见的应用。

## 3. 简单的实现

经典 Dijkstra 算法的这种实现有一个重大缺陷。但是，很容易犯这个错误，尤其是从头开始实现算法时：

```


```

尽管此算法会返回从源节点到目标节点的最短路径，但它会以次优方式执行此操作。在这种方法中，我们不断地将新节点插入队列，而不是更新已经存在的节点的权重。因此，在最坏的情况下，队列中的元素数量可能会增长到图中边的数量。增加的队列大小恶化了入队和出队的时间复杂度。

对于这种情况，时间复杂度![O(日志(E))](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-f89ea91ffa9ce7612997a40a42c1be07_l3.svg)适用于入队和出队操作。这种方法的总时间复杂度为![mathbf{O(Elog(E))}](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-ea192d972cf6e64f758cf3890c32da3e_l3.svg)。在大多数情况下，我们可以看到这种实现具有存储重复节点的优先级队列，并且不允许通过它们的键轻松访问其中的元素。

## 4. 提高时间复杂度

为了解决上一段中解释的问题，我们需要确保队列不会包含具有不同权重的相同节点，并且有几种方法可以解决这个问题。

### 4.1. 渴望去除

删除和插入有助于我们减轻以前的实现所产生的问题，并且不允许在队列中有相同的节点。我们可以在插入新节点时将其删除，而不是懒惰地清理队列：

```

```

这种方法可以显着提高算法的复杂性，从而增加入队和出队操作的时间复杂度![mathbf{O(log(V))}](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-948b2daaf1de366d63ebbee26fe52c52_l3.svg)。不幸的是，这个实现需要一个更复杂的队列。排序队列的标准实现具有访问元素的线性时间复杂度。因此，要使用这种方法，我们应该确保元素检索不会影响性能。

### 4.2. 减键实现

减少队列中已有节点的密钥权重更加直接明了。换句话说，如果我们找到到特定节点的新的更短路径，我们将在输出队列中更新此信息：

```

```

如果我们的堆允许我们减少一个特定的键，这种方法将具有与前一种结合二叉堆相同的时间复杂度。此实现确保队列大小不能超过节点数。

### 4.3. 改进的减键实现

从技术上讲，使用[Fibonacci 堆](https://en.wikipedia.org/wiki/Fibonacci_heap)等特殊堆结构的[减少键实现](https://www3.cs.stonybrook.edu/~rezaul/papers/TR-07-54.pdf)可以显着提高算法的性能。算法的实现不会改变，与上一节相同，但堆本身的底层实现会有所不同。但是，它具有比二叉堆更大的常数因子。它还需要更复杂的数据结构。此外，这种方法的时间复杂度是分摊的，这意味着它是几个操作之间的平均值。

## 5. 复杂性分析

关于这些方法，我们可以[查表了解它们的复杂性](https://stackoverflow.com/a/9255681)。该表不包含天真的方法。以下是以下实现中操作的时间复杂度：

```

```

正如我们所看到的，使用Decrease-Key的实现在二叉堆和二叉堆的情况下没有提供显着的改进。但是，假设我们正在使用不同的优先级队列实现，如 Fibonacci 堆。在那种情况下，我们可以显着降低时间复杂度。虽然，我们需要考虑用于 Fibonacci 堆的时间复杂度是在操作之间分摊和分配的。

## 六，总结

在本文中，我们了解到支持 Decrease-Key 操作的优先级队列实现将提高算法在特定堆(如 Fibonacci 堆)中的复杂性。然而，大多数语言使用二叉堆作为这种数据结构的主要实现。因此，解决这个问题并避免增加密集图的复杂性的最简单方法是使用队列实现，它允许检查现有节点并通过使用新权重删除和插入它们来模拟更新。