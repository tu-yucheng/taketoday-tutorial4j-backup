## 1. 概述

最近我们研究了[Dijkstra 算法](https://www.baeldung.com/cs/dijkstra)，以此作为找到任意两点之间最短路线的方法。在这里，我们将看看 A 算法，它是对此的更有效扩展。

## 2.A算法

A 是对 Dijkstra 算法的相对简单的调整，使其成为[最佳优先搜索](https://en.wikipedia.org/wiki/Best-first_search)。

这是通过为每个节点设置两个评分机制来实现的。一种与 Dijkstra 算法中使用的相同。第二个是关于节点与目标节点的接近程度的启发式分数。然后，我们使用这些来存储针对每个节点的两个不同分数——到达当前路线上的节点的分数，以及选择下一个要访问的节点的分数。

这对算法的工作方式有微妙但重要的影响。这意味着我们总是喜欢更接近我们目标的节点，并避免访问更远的节点。这反过来又使我们的算法更加高效，因为我们将在每一步都朝着正确的总体方向前进。

有趣的是，如果我们有一个总是返回 0 的启发式算法，那么 A 算法与 Dijkstra 算法是相同的。这一个分数是两者之间的唯一区别。

### 2.1. 伪代码

该算法的核心与我们看到的 Dijkstra 算法非常相似。我们只需要考虑额外的评分启发式。

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-af025beb1b77475f20998fee481130be_l3.svg)

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-65542b5c8488df4ff71b8a224d65f9ea_l3.svg)

我们的nodeWithLowestScore算法与我们上一篇文章中的算法相同，只是使用heuristicScore代替。然后，这将根据我们的启发式方法选择我们认为是下一个最佳节点的节点。calculateScore和buildPath也与之前相同，根据实际分数为我们提供了通过图形到达每个节点的最佳路线。

### 2.2. 启发式分数

唯一缺少的部分是我们的启发式。这不是一件容易描述的事情，因为它与我们正在寻找路径的图类型有关。唯一的要求是启发式分数和实际分数彼此一致。

例如，在地理图中，这可能基于图中节点之间的物理距离。我们的实际分数可以是两个节点之间的路线上的米数，而我们的启发式分数可以是两个节点之间的直线上的米数。

然后，这将优先考虑使我们更接近目标的步骤，希望这些步骤能够产生更有效的路径。如果没有更好的选择，我们只会开始偏离我们的目标。

## 3. A的性质

A 算法有几个特性，使其成为通用寻路算法的绝佳选择。

### 3.1. 终止和完整性

终止的性质意味着算法将达到停止状态——也就是说，它要么找到解决方案，要么达到无法继续前进的地步。

完备性意味着算法总能找到一个解，只要有一个解可以找到。

如果我们正在处理一个有限图，其中节点之间的每个连接都具有非负成本，那么 A 算法可以保证终止和完成。

如果我们正在处理无限图，那么在某些条件下可以保证找到解决方案，但如果不满足这些条件，则算法可能永远不会终止。

### 3.2. 可受理性

如果启发式算法永远不会返回大于同一路线的最佳成本的成本，则该启发式算法被认为是可接受的。例如，如果两个节点之间最有效的路径的成本为n ，那么可采纳的启发式方法永远不会返回大于此的成本。

在 A 中，如果使用的启发式算法是可接受的并且算法返回一个解决方案，则可以保证该解决方案是最优的。如果启发式算法不可接受，那么算法可能会选择不太理想的路线，尽管这不会阻止它找到解决方案。

如果启发式是可接受的，那么我们可以保证找到最优解。但是，如果有多条路径的成本都相同，那么它们都会被探索，这将导致更高的整体处理成本。通过放宽可接受性标准，我们可以避免这种情况，但存在整体更差解决方案的风险。

相反，我们可以放宽准入标准，但只能在一定范围内放宽。这将使我们能够发现一条足够优化的路径，但以更有效的方式进行。

## 4. 复杂性

A 的时间复杂度取决于启发式函数的质量。在最坏的情况下，算法可以是O(b^d)，其中b是分支因子——每个节点的平均边数，d是结果路径上的节点数。

启发式函数越好，需要访问的节点就越少，因此复杂性会下降。我们可以将启发式函数的结果描述为有效分支因子——我们需要访问的每个节点的平均边数。

Dijkstra 算法有一个有效分支因子，它与整体分支因子完全相同。一个完美的最佳启发式函数将为我们提供1的有效分支因子——即，从每个节点，我们将永远只有一个边可以访问。现实可能介于两者之间，并且在这个规模上的哪个位置将决定搜索的时间复杂度。

标准 A 的空间复杂度始终为O(b^d)，因为我们需要始终跟踪图中的每个节点，即使是那些我们从未访问过也永远不会访问的节点。可以通过仅在节点变得相关时将节点添加到我们的算法，或者在节点变得不那么相关时忘记节点来围绕此进行优化。尽管如此，这些都对整体产出有潜在影响。

## 5.总结

在这里，我们研究了 A 算法的工作原理，包括一些关于在某些情况下可以使其工作得更好或更差的细节。我们之前已经看到了这个的[实际实现](https://www.baeldung.com/java-a-star-pathfinding)。