## 1. 概述

大多数从事计算机科学的开发人员和人员都听说过[Quicksort](https://www.baeldung.com/cs/algorithm-quicksort)。他们中的许多人以一种或另一种形式实现了这个算法。这是一个无处不在的算法，但是它有那么好吗？

许多主要语言默认使用不同的排序算法。该算法具有有趣的特性，但大多数人都没有听说过[Timsort](https://medium.com/@rscheiwe/the-case-for-timsort-349d5ce1e414)。

本教程将深入探讨这两种算法之间的区别，并讨论它们的优缺点。然而，由于目标是突出差异，本文不会集中讨论这些算法的实现细节。

## 2. Quicksort 和 Timsort 的历史

让我们简要回顾一下这些算法的历史以及引入它们的时间以获取更多上下文。

让我们回顾一下快速排序算法。Tony Hoare 于 1961 年发表了该算法，此后得到广泛应用。该算法有许多不同的方法和实现，可以在特定情况下提高其最优性。然而，令人着迷的是，这个 60 多年前推出的算法在当今得到了广泛的应用，许多编程语言都以它为主要对象来对数据进行排序。

与 Quicksort 相比，Timsort 是一个年轻的算法，尽管它已有二十多年的历史。Tim Peters 在 2002 年引入了这个算法。它基于 Peter McIlroy 1993 年的论文“乐观排序和信息理论复杂性”中的技术。Timsort 是归并排序和插入排序的高度优化融合，性能优于两者。

## 3. 复杂度比较

在大多数情况下，算法中最有趣的部分是它们的时间复杂度指标，它显示了算法处理大量数据的速度。在查看其他差异之前，让我们先比较一下这两种算法的性能：

```

```

正如我们所见，Timsort 有一个更好的最坏时间(这种情况并不经常发生)和一个非常好的最佳时间。然而，时间复杂度只是整个画面的一部分，因为我们经常在时间和空间之间进行权衡。让我们比较一下这些算法的空间复杂度：

```

```

## 四、分选特点

排序算法具有以下特点：自适应/非自适应、稳定/不稳定、递归/非递归、在线/离线、串行/并行、外部/内部。我们将在本文中专注于稳定性和适应性。在我们的例子中，其他参数是无关紧要的，因为它们在很大程度上是特定于实现的。

### 4.1. 适应性

冒泡排序总是[错误的方法](https://youtu.be/k4RRi_ntQc8)吗？[排序算法和自适应性](https://en.wikipedia.org/wiki/Adaptive_sort)最有趣的特征之一。它告诉我们算法如何适应给定数据并发挥最佳性能。我们是否需要对已经排序的集合进行排序？我们是否应该花更少的时间对只有少数元素乱序的集合进行排序？这些都是合理的问题，一些算法，尤其是简单的实现，可能不会使用输入数据的结构来提高性能。

Quicksort 的简单版本不是自适应的，甚至会尝试对已经排序的集合进行排序。在只有少数元素乱序的设置中，冒泡排序或插入排序的性能优于快速排序。因为这些算法是自适应的，所以它们可以利用集合预排序的好处。然而，在随机数据集上，这些算法可能会导致整个系统停止运行。

然而，在上面的例子中，所有具有适应性优势的算法都有一个巨大的障碍，即在随机数据上速度慢。Timsort 解决了这个问题，此外，为了达到最优，该算法还可以利用已排序或预排序的数据。由于现实世界的数据通常不是完全随机的，并且通常包含已排序的部分，因此 Timsort 可以显着提高性能。例如，自适应 Timsort 在部分排序数据上的性能大大[优于](https://youtu.be/ZxLxf5xqqyE)非自适应 Mergesort。这并不意味着 Mergesort 或 Quicksort 不能自适应，但它生动地展示了自适应算法的好处。

### 4.2. 稳定

Quicksort 和 Timsort 之间的另一个不同的关键特征是[稳定性](https://www.baeldung.com/cs/stable-sorting-algorithms)。用外行的话来说，稳定性确保相等(在比较参数方面相等)的元素将与排序前的顺序相同。例如，假设我们有一个按字母顺序排序的人员列表，然后决定按年龄对他们进行排序。在这种情况下，稳定性将确保所有同龄人仍按字母顺序排列。在对非原始值进行排序时，此特性特别有价值。这就是为什么，例如，在 Java 中，Quicksort 用于原始数据而 Timsort 用于对象。

## 5. 优点和缺点

正如我们之前看到的，Timsort 是一个很棒的算法，具有许多优点和良好的整体性能。首先可以认为是负点的是空间复杂度。Timsort 的另一个问题是它比 Quicksort[复杂得多。](https://gist.github.com/rscheiwe/7a756c8ded39bdc0fa02bdcc40b86ec5#file-timsort-py)即使是经过良好调整的快速排序实现也可以用二十行左右的代码写下来。同时，Timsort 是 Mergesort 和 Insertion sort 的混合体，其核心有许多提高性能的技术。

然而，这并不意味着我们不每天使用 Timsort。如前所述，许多主要语言使用此算法作为主要排序方法。 尽管实现对用户是隐藏的，但我们在代码中获得了 Timsort 的所有好处。

## 六，总结

在本文中，我们了解了 Timsort 和 Quicksort 之间的区别。Quicksort 是一种易于使用且易于实现的完美算法。另一方面，Timsort 具有更复杂的实现并且可以显着提高性能。然而，与快速排序相比，Timsort 有更多的移动部分并且相当复杂。花一些时间来实现它是一个很好的挑战，因为这可以很好地反思几个计算机科学概念。