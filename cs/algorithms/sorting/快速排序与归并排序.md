## 1. 概述

有许多算法可以对数据进行排序。通常，当我们选择排序算法时，我们依赖于速度和空间使用等标准。

在本教程中，我们将比较两种流行的排序算法[Quicksort](https://www.baeldung.com/cs/algorithm-quicksort)和[Mergesort](https://www.baeldung.com/cs/non-recursive-merge-sort)。在性能和存储使用方面，这两种算法以不同的方式和不同的属性应用[分而治之的方法。](https://www.baeldung.com/cs/divide-and-conquer-strategy)

## 2. 快速排序

Quicksort 是一种流行的就地排序算法，它采用分而治之的方法。我们可以将快速排序概括为三个主要步骤：

-   选择一个元素作为枢轴
-   通过将较小的元素移动到枢轴的左侧并将较大的元素移动到其右侧来划分问题集
-   在每个分区上重复上述步骤，直到我们得到一个排序列表

让我们来看一个小例子，我们使用快速排序对以下列表进行排序：

![截图 2021-03-21-at-12.44.50](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/Screenshot-2021-03-21-at-12.44.50-2048x171-1-1024x86.png)

第一步是我们选择一个支点。有不同的方法来选择一个枢轴，但对于这个例子，我们将始终选择最右边的元素。

一旦我们选择了枢轴 23，我们需要将所有大于 23 的元素移到它的右边，所有小于 23 的元素都移到它的左边。请记住，我们不担心现阶段的订单。我们只是根据枢轴定位元素。

通过这样做，我们将列表分为两个分区：

![截图 2021-03-21-at-12.46.35](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/Screenshot-2021-03-21-at-12.46.35-2048x177-1-1024x89.png)

现在我们可以对每个分区重复算法的步骤。由于最右边的分区只包含一个元素，我们可以通过选择 5 作为基准然后组织围绕它的元素来对最左边的分区 [15, 3, 8, 10. 5] 应用这些步骤。注意在我们这样做之后我们是如何慢慢接近有序集的：

![截图-2021-03-21-at-13.01.02](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/Screenshot-2021-03-21-at-13.01.02-2048x162-1-1024x81.png)

现在我们在 [5] 周围有两个分区，它们是 [3]，不需要任何进一步的分区，以及 [15,8,10]。通过选择 10 作为基准并围绕它组织剩余的 15 和 8，我们得到了最终的排序列表：

![截图-2021-03-21-at-13.03.52](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/Screenshot-2021-03-21-at-13.03.52-2048x172-1-1024x86.png)

要更深入地解释快速排序以及我们可以选择枢轴的不同方式，我们可以阅读快速排序的 [概述文章](https://www.baeldung.com/cs/algorithm-quicksort)。

接下来，让我们将 Mergesort 应用于同一个数组，看看它是如何工作的。

## 3.归并排序

Mergesort 是另一种分而治之的算法。但是，与快速排序不同的是，它不是[就地算法](https://www.baeldung.com/java-in-place-sorting)，需要临时数组来存储排序后的子数组。

我们可以将合并排序概括为两个主要步骤：

-   将列表分成子列表，直到我们到达一个元素
-   重复将子列表合并到排序的子列表中，直到我们到达最终的排序列表

现在让我们将这些概念应用到我们在上一个示例中使用的相同数组。从未排序的列表开始，我们将列表分成最小的子列表：

![截图-2021-03-21-at-13.10.59](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/Screenshot-2021-03-21-at-13.10.59-1-2048x348-1-1024x174.png)

现在我们将获取每两个子列表并将它们合并在一起，确保合并的子列表已排序。我们现在有四个排序的子列表：

![截图 2021-03-21-at-13.14.00](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/Screenshot-2021-03-21-at-13.14.00-2048x494-1-1024x247.png)

同样，我们将取每两个子列表并将它们合并到排序的子列表中，这为我们提供了两个排序的子列表：

![截图-2021-03-21-at-13.15.27](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/Screenshot-2021-03-21-at-13.15.27-1024x301.png)

最后，我们最后一次应用相同的概念，这将为我们提供最终的排序列表：

![截图-2021-03-21-at-13.18.36](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/Screenshot-2021-03-21-at-13.18.36-1024x388.png)

要更深入地了解归并排序算法及其实现方式，我们可以查看这篇文章，其中解释了[如何在链表上应用归并排序](https://www.baeldung.com/cs/merge-sort-linked-list)。

## 4. 合并排序和快速排序的比较

现在我们已经了解了快速排序和归并排序的工作原理，让我们看看这两种算法之间的主要区别：

```

```

## 5.总结

在本文中，我们讨论了两种排序算法：Quicksort 和 Mergesort。

我们了解了这些方法的实际工作原理，并在空间和时间复杂度以及稳定性和就地排序等其他属性方面对它们进行了比较。