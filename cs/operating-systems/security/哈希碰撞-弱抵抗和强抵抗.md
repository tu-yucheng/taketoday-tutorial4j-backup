## 1. 概述

[散列](https://www.baeldung.com/cs/hashing)是将可变长度数据输入转换为固定长度输出的过程，称为散列或摘要。散列在现代计算中有不同的应用，从在数据库中存储密码到签署通过 Internet 发送的消息。

但是，由于散列的工作方式，可能会发生冲突。总之，冲突是为不同的输入生成相同的散列。反过来，散列算法可以设计为避免碰撞，具有弱或强的抗碰撞性。

在本教程中，我们将探索弱和强哈希碰撞抵抗。首先，我们将简要回顾一下哈希。因此，我们将特别研究散列冲突，详细说明弱和强抗冲突性。最后，我们将介绍弱抗碰撞性和强抗碰撞性都特别相关的用例。

## 2. 哈希概述

综上所述，我们可以将哈希理解为将任意数据映射为定长代码的过程。 整个过程包括提供原始数据作为散列机制的输入，该机制通过特定的散列函数对其进行处理并生成散列作为输出。

下图描述了高层次的散列过程：

![哈希 2](https://www.baeldung.com/wp-content/uploads/sites/4/2022/02/Hashing-2.png)

需要强调的是，散列函数是单向处理。这意味着这些函数可以在给定原始数据作为输入的情况下计算哈希值。但是，他们无法在给定哈希码作为输入的情况下恢复原始数据。

散列在计算中有多种用途。在最相关的散列应用程序中，我们可以列举密码存储、数据完整性验证和键/值数据结构的创建：

-   密码存储：不是以纯文本形式保存密码，而是可以在数据库中仅存储密码的散列。因此，如果攻击者可以访问数据库，他们将需要处理哈希(通常使用暴力或[彩虹表](https://www.baeldung.com/cs/rainbow-table-attacks)策略)来恢复密码
-   数据完整性验证：为了启用数据[完整性验证](https://www.baeldung.com/java-digital-signature#digital_signature)，已知且开放的散列机制为作为输入提供的数据生成散列。因此，我们可以使用其各自的哈希码使这些数据可用。这样，每个拿到数据的人都可以重新计算hash，与提供的进行比较：如果匹配，则数据正确
-   键/值数据结构：一些编程语言提供基于键/值关系的数据结构。这些数据结构使用[哈希表](https://www.baeldung.com/cs/hashing#hash-table)来保持链接到唯一键的通用数据(值)。因此，我们可以访问请求其各自密钥的特定存储数据(值)

尽管有好处，但散列的内在特性也带来了一些挑战。这些挑战之一是散列冲突，将在下一节中讨论。

## 3.哈希冲突

简而言之，当不同的数据输入经过哈希机制处理后产生相同的哈希值时，就会发生冲突。 但是，我们在这里应该注意，冲突不是问题，而是散列机制的内在特征。

由于哈希将任何输入(无论其长度如何)映射到固定长度的代码，因此会出现冲突。因此，由于我们有无限的可用输入集和有限的可用输出集，散列机制最终将生成重复的散列。

下图以高层次描述了所描述的场景：

![哈希冲突](https://www.baeldung.com/wp-content/uploads/sites/4/2022/02/HashCollision.png)

当冲突不可接受时，存在解决冲突的技术。例如，我们可以使用替换列表将散列移动一定的偏移量。此技术通常与哈希表一起使用。

另一种技术包括在系统中采用散列机制的层次结构。因此，如果发生冲突，我们可以使用另一种哈希机制重新创建哈希。

然而，比解决散列冲突更好的方法是避免它们发生。 为此，散列机制必须保证有关抗碰撞性的特定属性。

在下一节中，我们将研究抗碰撞特性。

## 4. 抗碰撞性

使散列机制能够抵抗冲突是一项主要与散列函数设计相关的挑战。特别是，我们应该注意哈希函数可以生成的不同哈希值的数量。此外，我们应该注意它生成这些哈希中每一个的频率。

因此，考虑一个需要哈希机制的特定问题。一个好的哈希函数可以解决这个问题，可以生成足够多的不同哈希值，为每个输入提供一个唯一的哈希值。

此外，给定一个具有任意数量输入的集合，一个设计良好的散列函数会返回一组散列，其中重复次数最多的散列与重复次数最少的散列的频率差最小。

在使用散列机制时，需要这些特性来避免冲突。但是，我们可以在避免特定输入或任意输入的碰撞方面探索碰撞阻力。这些特征定义了弱和强的抗碰撞性。

### 4.1. 抗碰撞性弱

弱抗碰撞的定义是：给定一个输入 X 和一个哈希函数 H()，很难找到另一个输入 X' 使得 H(X) = H(X')。

换句话说，以输入 X 作为参数，用另一个输入 X' 散列 H(X) 不是一项简单的任务。

### 4.2. 抗碰撞性强

强抗碰撞性背后的主要思想是：给定一个哈希函数 H() 和两个任意输入 X 和 Y，存在 H(X) 等于 H(Y) 的绝对最小机会。

在强碰撞阻力的情况下，我们没有像弱碰撞阻力那样的参数来搜索碰撞。

在强抗碰撞中，我们考虑任意输入，这种场景发生碰撞的几率很低。

## 5. 哈希碰撞抵抗的用例

在许多情况下，抗哈希冲突变得尤为重要。在其中一些情况下，抵抗力弱就足够了。然而，其他散列场景可能需要很强的抗碰撞性。

弱碰撞抵抗通常就足够了的一个例子是将[密码作为哈希](https://www.baeldung.com/java-password-hashing)存储在数据库中。在这种情况下，只有创建密码的人知道生成哈希的输入。因此，由于无法找到生成相同散列的另一个输入，散列机制可以保护密码。

另一方面，我们需要强大的抗碰撞性的一个例子是检查数据完整性。 在这种情况下，我们可以访问生成哈希的原始输入。因此，我们可以重新计算哈希并将其与提供的哈希进行比较。例如，当我们对[文档进行数字签名](https://www.baeldung.com/cs/encoding-vs-signing-asymmetric-encryption#signing-data-with-asymmetric-encryption)时，通常会采用此过程。

因此，我们相信找到生成相同散列的任意输入是不可能的。通过这种方式，我们可以相信我们的数据是原始数据的真实副本。

## 六，总结

在本教程中，我们研究了抗哈希冲突性。首先，我们对散列进行了一般性的简要回顾。因此，我们了解了有关哈希冲突的核心概念。因此，我们探讨了有关抗哈希冲突的概念：弱和强。最后，我们看到了现实世界中抗哈希冲突的特殊用例。

我们可以得出总结，散列是当今计算的基本过程。然而，无论采用何种散列机制/函数，都可能发生冲突。因此，我们必须正确设计这些机制以避免碰撞，满足弱或强阻力特性。