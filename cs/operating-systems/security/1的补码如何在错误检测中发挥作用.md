## 1. 概述

在本教程中，我们将讨论如何使用 1 的补码技术来检测数据传输中的错误。

此外，我们将提供一个使用 1 的补码技术进行错误检测的实际示例。

## 2. 1的补码介绍

错误检测是任何需要维护[数据完整性](https://www.baeldung.com/cs/cia-triad)的数字系统的关键部分。因此，必须有一种可靠的方法来检测传输数据在到达目的地之前的错误。最常用的技术之一是 1 的补码。这是检测数字数据错误的一种快速有效的方法。 

在 1 的补码系统中，二进制数中的每个数字都被反转。因此，要找到二进制数的 1 的补码，我们可以简单地将每个 1 替换为 0，将每个 0 替换为 1。例如，要查找 10110110 的 1 的补码，我们将 1 替换为 0，将 0 替换为 1获得 01001001：

![img](https://www.baeldung.com/wp-content/uploads/sites/4/2022/12/1-exam.png)

我们还可以使用 1 的补码来表示计算机中的负数，因为它允许使用标准电路对二进制数进行简单的加法和减法。此外，我们还可以利用这种技术来简化某些计算机操作的实现，例如[按位非](https://www.baeldung.com/java-logical-vs-bitwise-or-operator)和[移位](https://en.wikipedia.org/wiki/Bitwise_operation)。

二进制数的 1 的补码可用于传输数据时的错误检测和反转数据的顺序以计算[校验和](https://www.baeldung.com/cs/crc-vs-checksum)。我们可以在将十进制数转换为二进制数时使用此技术，反之亦然。它可以识别十进制数的[最高有效位和最低有效位。](https://www.baeldung.com/cs/most-significant-bit)如果我们想求一个十进制数的 1 的补码，我们需要将所有数字相加，然后将结果加 1。

## 3. 使用 1 的补码进行错误检测

在讨论我们如何使用 1 的补码技术进行错误检测之前，让我们讨论一下在传输数据时可能发生的不同类型的错误。

数字数据中可能会出现几种不同类型的错误。一些常见错误包括单位错误、突发错误、定时错误和损坏错误。

单位错误影响数字数据流中的单个位。各种因素，包括干扰、噪音或硬件故障，都可能导致这些错误。突发错误会影响数字数据流中的多个连续位。此外，当数字数据传输的时序关闭时，会出现时序错误，从而导致数据出现错误。

我们可以使用 1 的补码技术来检测数字数据系统中的单位错误。假设我们有一条消息要发送给另一个人 Sam。我们首先需要将消息转换成二进制码，并找到二进制码的1的补码。此外，我们将原始消息连同原始消息的 1 补码一起发送给 Sam。

当 Sam 收到消息时，他将二进制代码转换回原始消息。此外，他然后找到二进制代码的 1 的补码并将其与接收到的 1 的补码进行比较。如果两个 1 的补码相同，则消息被正确传输。此外，在这种情况下，我们可以说传输过程中没有发生错误。

但是，如果两个 1 的补码不同，则传输有错误。两个 1 的补码之间的差异准确地告诉我们错误的位置和类型。错误检测对于纠错至关重要。

## 4.例子

我们已经探讨了 1 的补码如何用于错误检测。现在让我们举个例子来解释我们如何实际应用这个方法。

假设两台计算机正在相互通信。作为数据传输的一部分，计算机 A 将二进制数据 10011001 和 11100010 发送到计算机 B。在发送之前，我们需要添加数据包并对结果数据应用 1 的补码技术。所以计算机A要发送的两个二进制数相加就是101111011，我们加上进位后得到01111100，如果对结果数据01111100进行1的补码，就变成了10000011。

计算机A将10000011连同原始二进制数据10011001和11100010一起发送给计算机B。计算机B收到数据后，将两个二进制数相加生成输出和01111100。最后，为了检查是否有错误发生在传输时，将 01111100 与 10000011 相加。如果相加结果为 0，则表示传输没有发生错误。如果在传输过程中出现错误，结果和将不会为 0：

![img](https://www.baeldung.com/wp-content/uploads/sites/4/2022/12/1s-Complement-Works-in-Error-Detection.drawio-1.png)

## 5.优点和缺点

使用 1 的补码进行错误检测的主要优点是速度快。由于涉及较少的计算，1 的补码方法比其他错误检测技术(例如[奇偶校验](https://www.baeldung.com/cs/calculating-parity-bit)或[校验和](https://www.baeldung.com/cs/crc-vs-checksum))更快。

此外，1 的补码方法仅适用于传输数据的最高有效位，这意味着它不会向数据添加额外的位。另一方面，奇偶校验方法在传输的数据中增加了一位。此外，校验和还会在数据前添加一个额外的位并增加额外的计算。1 的补码方法是一种不需要特殊设备的低成本错误检测方法。

通常，它允许以二进制形式简单有效地表示负数。在1的补码系统中，负数用对应的正数取1的补码表示。此外，它还允许对二进制数进行加法和减法。

虽然 1 的补码方法快速高效，但它无法检测出所有传输错误。它可以检测单比特和一些 2 比特错误。但是，它不能检测三个或更多位错误。如果出现 3 位错误，则可能会产生不正确的结果。它还可以纠正单位错误，但前提是错误位于最高有效位。1 的补码方法无法纠正最低有效位中的单位错误。

与表示负数的其他方法相比，1 的补码在表示给定值范围所需的位数方面效率较低。此外，它没有零的唯一表示。在 1 的补码系统中，零可以用全 0 或全 1 表示，这会在处理二进制数时导致混淆和潜在错误。

## 六，总结

在本教程中，我们讨论了如何使用 1 的补码技术来检测数据传输中的错误。此外，我们还提供了一个使用 1 的补码技术进行错误检测的实际示例。