## 1. 概述

在能够真正毁掉我们一天的无数攻击中，SQL 注入理应占据一个非常特殊的位置。它是最常用的网络系统黑客技术之一。他们现在被许多黑客工具(例如[sqlmap](https://sqlmap.org/))武器化了。如此之多，以至于这些工具甚至可以帮助不那么熟练的黑客进行极具破坏性的攻击。

简而言之，注入攻击者试图将任意代码插入到应用程序逻辑中。如果成功，将使用应用程序权限和安全角色执行此代码。这些攻击属于更广泛的远程代码执行攻击 (RCE) 类别。也就是说，上传代码(二进制或脚本)并诱使服务器随后执行它。

很长一段时间以来，注入攻击一直是[OWASP](https://owasp.org/www-project-top-ten/)前十名中风险较高的攻击之一，它们也应该如此。精心设计的攻击可以轻松更改应用程序数据，甚至抹去它们的踪迹。SQL 注入是指攻击者试图修改和破坏应用程序使用的 SQL子句。

我们已经有一个[教程](https://www.baeldung.com/sql-injection)涵盖了它在 Java 编程中的某些方面。在本教程中，我们将更深入地研究什么是 SQL 注入。它是如何工作的，是什么让它如此危险。我们将看到它的类别和混淆技术，并展示如何修复它。

## 2. SQL 注入是如何工作的？

简而言之，当应用程序通过连接字符串和应用程序输入参数来构建 SQL 命令时，可能会发生 SQL 注入。例如，假设某些 Web 应用程序登录使用以下伪代码来验证登录表单上的凭据是否有效：

```

```

如果参数为 Username = “root” 和 Password = “root”，生成的 SQL 子句将产生：

```sql
SELECT id,Fullname FROM users WHERE Password ='63a9f0ea7bb98050796b649e85481845' AND Username ='root'
```

如果我们使用用户名“root' or 1=1 limit 1;–”和一个空白密码，结果子句将是：

```sql
SELECT id,Fullname FROM users WHERE Password ='d41d8cd98f00b204e9800998ecf8427e' AND Username ='root' or 1=1 limit 1;--'
```

后者给出与第一个相同的结果，即使攻击者无法猜出正确的密码。诀窍是“or 1=1”条件插入。这可能会欺骗应用程序接受任何有效的凭据。

通过添加其他 SQL 子句，这种简单的注入攻击可能会更糟，例如：

-   用户名=” root' 或 1=1 ; select  from customers;– ”, 在其他表上选择
-   用户名=” root' 或 1=1 ; insert into users (username, password) values ('backdoor_user','some_hash');–》，插入数据
-   用户名=” root' 或 1=1 ; 选择  客户；—》，窃取应用程序数据；甚至
-   用户名=” root' 或 1=1 ; 删除表客户；—》, 删除数据
-   Username=” root' or 1=1 union select password_hash as fullname from users; — ”, 窃取密码哈希

损坏的可能性是无穷无尽的！当然，适用于任何给定应用程序的实际命令将取决于其实际数据模型，以及应用程序将如何响应 SQL 更改。因此，攻击者要做的第一件事就是使用 SQL 注入来识别数据库并尝试检索其模型。

正如我们所见，许多应用程序容易受到 SQL Inject 攻击的原因是它们的用户输入直接连接起来构建它们的 SQL 命令。更糟糕的是，大多数时候他们甚至不对这些输入应用验证规则。

最重要的是，大多数数据库允许在同一个查询字符串中使用多个 SQL 命令。即使应用程序不显示在单个字符串命令中发出的链接 SQL 子句的结果，它们也会被执行。在某些情况下，攻击者可以通过应用程序错误消息和结果推断出查询响应。

SQL 注入攻击是高度可编写脚本的。这样一来，一些工具可以对整个数据库模型进行逆向工程，逐个字母地测试并检查错误情况。对于你的培训实践，我的 GitHub ( https://github.com/gchehab/sql_inject_sandbox ) 上有一个易受攻击的容器化应用程序示例，它显示了在编码时不要做什么。

## 三、SQL注入攻击的分类

SQL 注入有不同的方法，具体取决于应用程序的反应方式：

### 3.1. 基于错误

应用程序返回 SQL 错误。攻击者可以使用错误消息作为反馈来改进他们的方法。因此，进行适当的应用程序错误处理是一种很好的做法。强烈建议不要直接向用户提供可能会泄露有关应用程序如何工作的信息的详细信息。

### 3.2. 以联盟为基础

精心设计的 SQL 注入攻击试图通过联合构造使用单个子句字符串，从而诱使应用程序发送额外信息。为此，攻击者必须首先获取有关数据库列名的信息。请注意，如果应用程序发回实际的 SQL 错误，它还会通知完整的查询，包括有效部分，并且肯定会泄露表名和列名。

### 3.3. SQL 盲注

在以前的技术中，应用程序以某种方式被诱骗向攻击者提供信息。但是，当应用程序不向用户提供任何错误或错误 SQL 的任何反馈时，会使用更复杂的方法。所以攻击者必须猜测他们尝试的效果。

他们可以尝试使用任何基于布尔的查询和子字符串逐个字母地迭代猜测所需的信息。这是一种暴力破解完整信息的方式。是的，这需要很长时间，是的，需要数千次后续查询才能收集到任何有用的信息。但如果系统不受监控，那只是时间和坚持的问题。

顺便说一句，布尔运算是返回是或否、真或假信息的任何人。例如，通知应用程序中不存在用户是这种攻击的公平游戏。这就是为什么安全感知系统从不透露登录失败是由于用户错误还是密码错误造成的。

即使系统没有布尔运算，攻击者也可以测量响应时间。在数据库中找到的信息总是比不在数据库中的信息检索得更快。这可能足以猜测。无论查询结果如何，安全感知应用程序都可以调整为具有规律的响应时间。此外，他们可以缩短对持续重复查询的响应时间。

## 4.高级SQL注入混淆技术

一些应用程序开始通过在输入数据中搜索 SQL 保留字(例如“ select ”、“ update ”、“ insert ”、“ delete ”、“ drop ”、“ create ”)来检测攻击。这还远远不够。

攻击者使用创造性的混淆技术来逃避检测。混合大小写、使用转义字符或 SQL 命令将 ASCII 码转换为字符是他们的一些策略。下面的代码是一个真正的混淆攻击的摘录：

```http
GET http://www.somesite.com/Portal/showPortalPage.do?action&codItem=(cONVErt(int,(ChAR(58)%2BChAR(113)%2BChAR(101)%2BChAR(118)%2BChAR(58)%2B(selECT%2F%2A%2A%2FTOP%2F%2A%2A%2F1%2F%2A%2A%2FsubsTriNG((IsNull(caSt(APP..syscolumns.name%2F%2A%2A%2FaS%2F%2A%2A%2FNVARChAR(4000)),ChAR(32))),1,100)%2F%2A%2A%2FFrom ...
```

解析此命令摘录后会产生(攻击有效载荷以粗体显示)：

```http
GET http://www.somesite.com/Portal/showPortalPage.do?action&coditem=<strong>(</strong>
<strong>convert(int,(:qev:(select top 1 substring((isnull(cast(app..syscolumns.name as nvarchar(4000)), )),1,100) from</strong> ...
```

太棒了，不是吗？不得不写一个巨大的脚本来正确解析它……

## 5. 缓解SQL注入攻击：参数绑定

我们如何保护自己免受那些可恶的、不小的攻击？首先，我们不应该直接使用输入数据来构建查询。这意味着，始终使用参数绑定来创建 SQL。许多现代对象关系映射框架都使用参数绑定。但是，它们的行为可能会被覆盖：例如，制作你自己的原始 SQL 子句。

参数绑定是一种万事通。它不仅对 SQL 注入提供适度的保护，而且还提高了数据库性能。与前面显示的示例代码相对应的基本伪代码是：

```

```

而不是直接执行 SQL 发生的是：

-   prepare命令将 SQL 模板发送到数据库。基于此模板，数据库引擎解析命令，生成并缓存其执行计划。
-   bindParam命令通知它应使用的参数。数据库可以建立其他数据访问策略
-   执行命令，要求数据库执行查询
-   获取数据

当我们有一个准备好的 SQL 语句时，我们可以用不同的参数再次执行它。只需重放步骤 2-4 即可节省大量数据库资源。

使用此技术，通过申请表发送的每条信息仅用作查询的参数。这样他们就不会与 SQL 查询本身混淆。很明显，代码得到的行代码多了一点。因此，一种常见的设计模式是将 SQL 准备、参数绑定和查询执行封装在库函数中。

### 5.1. 其他框架

我们可以看到任何框架都有自己的参数绑定方式：

-   Java EE——使用[`PreparedStatement()`](https://www.baeldung.com/java-statement-preparedstatement)绑定变量
-   Hibernate——使用[`createQuery()`](https://www.baeldung.com/hibernate-error-named-parameters-not-set)绑定命名参数
-   PHP – 在 PDO 中使用`prepare`数据库对象方法创建语句和语句`bindParam`方法绑定命名参数
-   .NET – 使用参数化查询，如 `SqlCommand()` or `OleDbCommand()`

### 5.2. 参数绑定的额外好处

随后使用相同的准备好的 SQL 语句，即使参数不同，也会重新利用缓存的执行计划。这大大提高了性能。附带一提，现代数据库试图重新利用查询计划，即使是对于没有参数绑定的子句。另一方面，这仍然会产生一些额外的性能开销。

顺便说一句，不使用参数绑定曾经是降低数据库性能的最简单方法之一。拒绝服务攻击会覆盖整个数据库缓存区域，可以使用如下简单的脚本来完成：

```

```

## 6. 其他提示和良好做法

除了参数绑定之外，我们还必须牢记一些好的做法，以增强代码的保护和安全性。

### 6.1. 输入表单验证和转义

参数绑定是一种很好的保护技术。即便如此，强烈建议根据预期的边界和内容正确验证所有输入数据。这可能会增加抵御其他形式的远程代码执行攻击的能力。

这意味着在进一步使用数据之前检查数据是否属于其正确的域。例如，对于数字，检查它们是否只是十进制字符并且在边界内。对于常规文本，检查是否只有字母数字等。此外，避免让输入字段接受比实际需要更多的字符。始终施加适当的限制。

### 6.2. 存储过程

与参数绑定类似，使用Stored procedures也将SQL查询参数与语句分开。发生这种情况是因为参数作为函数参数发送到数据库，因此数据库不应将它们与语句混合。这确保了 SQL 注入的安全性，当然，除非存储过程不尝试使用字符串连接动态创建动态查询。

### 6.3. 最低权限

在任何情况下，如我们所见，除非另有编码，查询都是使用应用程序的数据库访问权限执行的。减轻这种行为风险的一种方法是将应用程序数据库服务帐户调整到所需的最低访问级别。

帐户没有 DBA 或架构所有者权限是最低起点。但它肯定会受到更多限制。有时，让特定的应用程序帐户执行更高权限的任务也是一种很好的做法。

### 6.4. Web 应用程序防火墙

如果我们有一个封闭源代码或难以修复的易受攻击的应用程序怎么办？

在这种情况下，我们可以使用 [Web 应用程序防火墙](https://en.wikipedia.org/wiki/Web_application_firewall)。不要将它与[常规网络防火墙](https://www.baeldung.com/cs/firewalls-intro)混淆。

Web 应用程序防火墙是一种在[OSI 应用程序层](https://www.baeldung.com/cs/osi-model)上运行的软件解决方案。这意味着它会检查应用程序数据流的所有方面。在[SSL/TLS](https://www.baeldung.com/cs/ssl-vs-tls)(如[https](https://www.baeldung.com/cs/https-urls-encrypted))连接中，它需要服务器的私钥才能执行此操作。它可以学习应用程序的有效参数和使用模式以强制执行它们。它尝试应用前面描述的一些保护技术来验证、转义和检测用户输入中的注入模式。

此外，他们可以检测自动网络请求和数据泄漏，例如 SSN 或信用卡号码，从而阻止进一步的尝试。它们的主要问题是它们难以配置并且容易产生误报，尤其是在应用程序行为未被完全理解的情况下。

在切换到商业软件包之前，我们甚至可以尝试一些开源 Web 应用程序防火墙选项，例如[Modsecurity](https://github.com/SpiderLabs/ModSecurity)、[Naxsi](https://github.com/nbs-system/naxsi)、[Shadow Daemon](https://github.com/nbs-system/naxsi)。此外，各种基于云的安全或 CDN(内容交付网络)解决方案都在其服务中包含此类保护。

## 七、总结

了解草率编码可能带来的漏洞是安全应用程序开发的关键。此外，了解攻击的工作原理可以让我们更好地理解如何缓解它们。尽管它是最常见的攻击之一并且很容易修复，但仍然有许多应用程序可以进行 SQL 注入。

在本教程中，我们更多地展示了 SQL 注入。易受攻击的应用程序如何工作，以及修复它们的最佳实践是什么。