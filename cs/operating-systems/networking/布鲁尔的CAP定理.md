## 1. 概述

在本教程中，我们将介绍和解释 CAP 定理。我们还将熟悉分配系统设计。最后，我们将检查所提出定理的问题，并查看当今可用的替代方案。

## 2.CAP定理

### 2.1. 历史

[CAP 假说](https://people.eecs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf)于 2000 年由 Eric Brewer 首次提出；然而，直到 2002 年其他计算机科学家才提出对该假设的正式[证明。](https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/)从它的介绍开始，它就被称为 CAP 定理(或布鲁尔定理)。最初，布鲁尔希望社会开始讨论[分布式系统](https://www.baeldung.com/cs/distributed-systems-guide)中的妥协。

### 2.2. 基本定义

CAP 是 Consistency、Availability 和 Partition tolerance 的缩写。让我们用简单的话来讨论这三个概念：

-   一致性意味着每次读操作都会得到最新的记录。所有信息都保证是最新的。
-   可用性是指示分布式系统将始终可用的属性。这种系统的一个或多个节点可能会关闭；但是，系统仍可通过其他节点访问。
-   分区容忍度表示系统被分区的能力。因此，这意味着每个节点都可以独立于其他节点工作。

### 2.3. 定理

CAP 定理指出分布式系统只能满足 3 个属性中的 2 个。所以可能只有CA、AP或CP系统。我们不能保证第三个属性会实现，而其他两个属性已经得到保证。因此，不存在 CAP 分布式系统。我们将在下一节中查看不同类型系统的示例。

## 3. 数据库和 CAP

让我们引入一个重要的定义，以便更容易理解数据库中的差异。

### 3.1. 

是数据库扩展技术之一。该技术基于这样一种想法，即来自一台数据库服务器的数据可以连续()到一台或多台其他服务器(称为副本)。应用程序可以使用多个服务器来处理所有请求。因此，可以将负载从一台服务器分配到多台服务器。

通常，主节点称为master。所有的副本都称为奴隶。master 可能只支持写入操作以在数据库中进行更改。之后，更改将分发到所有从属的副本以进行读取操作。这有助于保持数据库的一致性。这种称为主从。

但是，也存在主-主，其中允许主和所有副本执行读写操作。

### 3.2. 数据库比较

让我们看一个三角形，其中一些最常见的数据库根据其类型进行分类：

![数据库和 CAP 1](https://www.baeldung.com/wp-content/uploads/sites/4/2021/03/Databases-and-CAP-1-300x277.jpg)

正如我们所见，不同类型的数据库严格分为CA、AP或CP系统。

CA系统保证一致性和可用性。大多数关系数据库都是CA系统的例子。比如在PostgreSQL中，一致性是通过主从，两阶段[事务](https://www.baeldung.com/transactions-intro)提交的方式来实现的。replicas与master的同步可以是同步的也可以是异步的，系统是强可用的。分区时问题开始。如果我们尝试在 PostgreSQL 中使用分区，我们将永远无法保证一致性。

AP系统是关于可用性和分区容错性的。因此，它们可能不会始终保持一致。AP系统的一个例子是 NoSQL 数据库是 Cassandra。它采用master-master replication，其实符合AP系统定义。我们可以轻松地对 Cassandra 进行分区。所有节点将是独立的单元。因此，如果至少一个节点工作，系统将可用。然而，分区节点之间的同步可能导致一致性差。

CP系统具有一致性和分区容错性。例如，MongoDB 是一个 NoSQL 数据库和一个CP系统。通过使用单个主节点进行写操作来实现强一致性。MongoDB 可以在不丢失一致性的情况下进行分区。但是，在分区时，它可能变得不可用。在确保所有操作都被安全保存之前，系统不会接受写请求。

## 4. 简单分布式系统设计示例

在本节中，我们将尝试设计自己的分布式系统。让我们从单个节点开始。假设我们在提供日志记录服务的呼叫中心工作。我们接到客户的电话，需要注册一些活动(写操作)。他们还可以回电要求记住他们之前告诉我们的事情(读取操作)。我们决定将所有信息写在一个笔记本中。

一切正常，但客户数量每天都在增长。我们不得不将呼叫排成一个大队列，但我们知道我们失去了等不及我们接听电话的客户。

我们决定邀请一位朋友加入我们的日志记录服务。他还将接听电话，并在自己的笔记本上写和读请求。请注意，现在我们有两个不同的笔记本。在出现问题之前，一切都会好转一段时间。

### 4.1. AP系统

我们接到一位客户的电话，要求我们写下他妻子的生日。几个月后，他打电话回来，因为他知道他妻子的生日快到了，但他记不起具体日期了。这次我们的朋友接听了电话。他的笔记本上没有生日信息，因为我们没有分享。客户生气了：

![AP 1](https://www.baeldung.com/wp-content/uploads/sites/4/2021/03/AP-1-300x216.jpg)

在上图中，电话代表客户。![LS1](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-ae7ec83d702e392c08e8688e7b4324db_l3.svg)和![ls2](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-a02301021306fde27ab0e27a943da724_l3.svg)是日志服务的两个节点，我们和我们的朋友。

上述情况称为不一致。目前，我们的系统是一个AP系统，因为它可用且分区容错。

### 4.2. CP系统

现在我们决定处理这种不一致。每次客户给我们或我们的朋友打电话后，我们都会在笔记本上写下所有内容，然后互相打电话以同步信息。因此，现在客户将始终从服务中获得真实信息。

也可能会出现生病一天或更长时间无法工作的情况。在这种情况下，我们的朋友首先检查他是否可以打电话给我们同步我们的笔记本。如果我们没空，他就会给我们发电子邮件。当我们回去工作时，我们将首先检查电子邮件以在我们的笔记本中填充缺失的数据：

![CP 1](https://www.baeldung.com/wp-content/uploads/sites/4/2021/03/CP-1-300x126.jpg)

结果，客户将不得不等待服务的答复。我们将不得不花时间互相打电话或写下电子邮件中的信息来刷新我们的笔记本。该服务变得有点不可用。这是现在的CP系统。

### 4.3. CA系统

现在我们的朋友决定退出，但日志服务继续工作。我们只有一部手机和一台笔记本，就像一开始一样。我们可能会注意到，该系统仍然可用。我们将继续接听电话并将其记录到我们的笔记本中：

![那](https://www.baeldung.com/wp-content/uploads/sites/4/2021/03/CA-300x116.jpg)

因此，我们的系统是一致的。一致性是通过单一来源，一个笔记本来实现的。我们不再需要与朋友的笔记本同步。但是，系统没有分区，因为我们是日志服务中的单个节点。这是一个CA系统。 如果我们因为有大量客户而聘请另一个朋友来做这份工作，那么我们将不得不再次在可用性或一致性之间做出选择。

### 4.4. 结果

从这个例子得出的总结是，我们总是必须在系统属性之间做出选择。不存在完美的系统。我们应该始终根据要求、类型和操作频率来构建系统。这个想法是找到C、A和P的平衡。

## 5. 问题和备选方案

### 5.1. 上限问题

如今，CAP 定理并没有被严格使用。它存在一些重大的误解和模棱两可的定义，与实际应用相去甚远。

CAP 中的可用性有两个问题。其中之一是没有部分可用系统的定义。例如，系统可能只有 50% 可用，因为它的一半节点由于某些问题而关闭。该系统仍然可供客户使用；但是，它在 CAP 中不可用。

第二个问题是CAP 中的可用性不包括响应时间(延迟)。这意味着系统在读取请求后 1 小时或 1 天可用。

许多系统可能只是P系统。想象一下采用主从技术的系统。假设这样一个系统包含一个主节点、一个从节点和一个客户。客户可以从从属节点读取并且只能写入主节点。如果我们立即失去与主服务器的连接，那么客户将失去可用性。我们的系统变成了CP。

想象另一种情况。客户对主机执行写操作。然后它尝试从从站读取并获取不正确的数据。这可能是因为系统没有足够的时间进行同步。我们失去了一致性。如果可能的话，现在我们的系统就是P。

### 5.2. PACELC

[PACELC 定理](https://en.wikipedia.org/wiki/PACELC_theorem)是 CAP 定理的扩展和替代。PACELC 的规则更适合现实世界的分布式系统。该定理是一种公式：“如果系统是P则它是A或C，否则它是C或L。”

简单来说，如果系统可以分区容忍，那么我们就必须在可用性和一致性之间做出选择。如果系统不能分区正常工作，那么我们要么构建一个一致的系统，要么选择一个具有低延迟(平均响应时间)的系统。

## 六，总结

在本文中，我们了解了 Brewer 的 CAP 定理及其替代定理。我们发现系统不能同时可用、分区、一致和低延迟。因此，系统特性的选择取决于应用和要求。我们应该记住，我们必须牺牲一些属性才能使系统满足其他属性。