## 1. 概述

每当我们编写一个新的 HTTP API 时，我们都要做出几个决定：URL 模式、资源结构等。一个重要的决定是客户端如何通过我们的身份验证来访问我们的 API。

在本教程中，我们将研究一些替代方案及其优缺点。

## 2. 传统认证

HTTP 规范提供了一些简单的方法来验证请求。这些被称为基本和摘要身份验证。

基本身份验证的工作原理是将用户名和密码与“:”分隔符组合在一起，然后对结果字符串进行 base64 编码。然后在带有“基本”方案的授权标头中提供。例如，对于用户名“baeldung”和密码“superSecret：”

-   将两者组合成“baeldung:superSecret”
-   Base64 将此字符串编码为“YmFlbGR1bmc6c3VwZXJTZWNyZXQ=”
-   在“Authorization: Basic YmFlbGR1bmc6c3VwZXJTZWNyZXQ=”的 HTTP 标头中提供此信息

然后 HTTP 服务器可以轻松地将其转换回原始用户名和密码以验证它们是否正确。但是，这具有安全隐患。每次请求都会提供密码，因此很容易被拦截。

摘要身份验证通过生成用户名、密码和其他详细信息的加密摘要对此进行了改进。然后将此信息与用户名和其他详细信息一起发送到服务器。服务器可以查找密码，生成相同的摘要，然后进行比较。

这是有利的，因为密码不会以任何形式通过网络发送，而是要求服务器生成相同的摘要，这意味着它需要访问相同的详细信息。因此，密码必须以明文形式提供给我们的服务器。

这两种机制还要求用户在每次请求时都经过身份验证。这涉及查找用户详细信息并在每次请求时验证密码。这可能会很昂贵，特别是如果它需要引用远程服务来获取用户详细信息：

![验证](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/authentication.png)

## 3. 基于令牌的认证

一种替代方法是对客户端进行一次身份验证，并在这样做时为他们提供一个特殊的令牌，证明他们已经通过身份验证。这被称为“访问令牌”，服务器可以使用它来证明用户身份，而无需完成整个身份验证过程。

基于令牌的身份验证需要可以为经过身份验证的用户生成令牌的特殊基础设施，以及确保令牌有效的方法。但是，这允许用户身份验证与服务的其余部分分离，并且意味着未来的 API 调用仅提供此令牌，而不提供用户的实际凭据。这就是[OAuth2](https://www.baeldung.com/tag/oauth/)和[OpenID Connect](https://www.baeldung.com/spring-security-openid-connect)等规范给我们的。他们描述了获取用于未来 API 调用的令牌的各种方法。

令牌采用的确切形式将取决于我们的确切需求。我们可以使用简单的值，然后在数据库中查找它们以查看它们代表什么。我们也可以使用一些自包含的格式，比如[JWT](https://www.baeldung.com/spring-security-oauth-jwt)，这意味着我们只需要验证它们是有效的。

出于安全目的，不得泄露或共享令牌。但是，有能力使它们短暂存在，以便轻松遏制任何违规行为。OAuth2 等规范具有定期请求新令牌的方法，从而允许定期轮换访问令牌。

令牌不能被攻击者猜测或生成也很重要。使用 JWT 等格式意味着每个生成的令牌都保证是唯一的，并且证明是由身份验证服务器生成的。[其他服务可以使用异步加密签名](https://www.baeldung.com/java-digital-signature)或使用共享签名密钥来验证令牌是否正确生成：

![令牌](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/token.png)

这是有益的，因为我们可以使用相同的令牌对多个服务进行身份验证。只要每个服务都能够验证令牌，它们就会正常工作。这对于构建不在同一个 API 网关前端的分布式服务很有用：

![双令牌](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/twotokens.png)

如果简单的 ID 用于令牌，那么以非确定性方式生成它们很重要。如果使用递增数字，则攻击者可以尝试其他数字以查看会发生什么。使用诸如 UUID 之类的东西意味着攻击者不太可能能够预测有效令牌。

## 4. 基于会话的身份验证

另一种选择是利用可从许多容器(例如 Tomcat)获得的会话基础结构。会话充当针对会话 ID 存储简单数据片段的方法，而 webapp 容器管理这些数据的存储并将它们与会话 ID 相关联。

我们可以使用它通过将登录用户存储到会话中来实现身份验证。如果用户出现在会话中，那么这就是我们通过身份验证的用户。如果没有用户在场，则我们当前未通过身份验证。我们可以根据需要将其他数据存储到会话中，例如用户的权限集或任何其他可能有用的数据：

![会话](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/sessions.png)

通常，这些 ID 通过 cookie 传输，或通过将它们注入 URL 来传输。这要方便得多，因为容器为我们做了很多工作。但是，只有当应用程序在这些范围内工作时才会出现这种情况。例如，将会话 ID 注入 URL 与自己生成 URL 的 API 客户端结合使用效果不佳。

容器还将处理会话的整个生命周期，包括在不再需要时将其过期。通常这与特定的时间点无关，而是与一段时间的不活动有关。这意味着用户仅在他们积极使用系统时才保持身份验证，一旦他们完成，会话将过期并且他们将不再被身份验证。

虽然有并发症。使用会话取决于对存储的访问，要求来自同一客户端的所有调用都到达单个服务器，或者在服务器之间配置会话。此外，我们需要一些方法来处理注销。实现此目的的常见方法是使整个会话过期或清除用户详细信息。

## 5.总结

决定如何验证我们的 API 并不是一个微不足道的选择。有几件事需要平衡：安全隐患、实施成本、部署成本等。

通常，基于令牌的身份验证更为典型，尤其是使用 OAuth2 或 OpenID Connect 等框架时。这意味着第三方客户会发现更容易与我们互动，因为他们可以使用已经理解这些概念的工具。

但是，基于会话的身份验证可能更容易在单个服务中实现，因为它通常是应用程序容器的标准功能。这意味着我们的 API 的开发成本更低，但对客户来说成本更高。