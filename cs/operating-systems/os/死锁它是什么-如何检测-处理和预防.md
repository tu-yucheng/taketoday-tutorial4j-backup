## 1. 概述

在本教程中，我们将通过实际示例探讨如何预防、避免、检测和忽略死锁。

## 2. 死锁介绍

几乎任何进程共享资源的情况都可能发生死锁。它可以发生在任何计算环境中，但它广泛存在于分布式系统中，其中多个进程在不同的资源上运行。

在这种情况下，一个进程可能正在等待另一个进程已经占有的资源。死锁类似于先有[鸡还是先有蛋的问题](https://en.wikipedia.org/wiki/Chicken_or_the_egg)。

让我们看一个死锁的例子：

![一维](https://www.baeldung.com/wp-content/uploads/sites/4/2021/06/1D.png)

假设有三个进程 P1、P2 和 P3，以及三个资源 R1、R2 和 R3。

现在，假设 P1 请求资源 R2，该资源由 P2 持有。在这种情况下，P1 不会在没有 R2 的情况下继续进行，并且会无限期地等待，因为 P2 在获得 P3 持有的 R3 之前无法释放资源 2。P1和P3也是如此。因此，它是操作系统中死锁情况的理想示例。

## 3.死锁的必要条件

如果同时满足以下四个条件，则可能会出现死锁：

第一个条件是互斥。在这种情况下，我们不能同时在不同进程之间共享资源。

比如两个人要同时打印一张纸，这个过程是做不到的。必须等到系统释放打印(资源)。因此，我们一次只能将资源分配给一个进程。

死锁的第二个必要条件是保持等待或资源持有。在这种情况下，一个进程同时持有至少一个资源并同时等待另一个资源。在这里，进程不处于[运行状态](https://www.baeldung.com/cs/process-lifecycle)。它处于[等待状态](https://www.baeldung.com/cs/process-lifecycle)。

第三个条件是不可抢占。如果一个进程持有一个资源，那么在释放资源之前，不能从进程中强行夺走该资源。当进程处于等待状态时，此语句也成立。

死锁的最终条件是循环等待。假设进程 P1 正在等待资源 R2。现在特定资源 R2 已经被进程 P2 占用。进程 P2 正在等待下一个进程持有的资源。这将一直持续到最后一个进程正在等待第一个进程持有的资源。

循环等待条件创建一个循环链并使所有进程处于等待状态。

## 4. 死锁预防

在死锁预防过程中，操作系统将通过避免导致死锁的四种情况中的任何一种来防止死锁的发生。如果操作系统可以避免任何必要条件，则不会发生死锁。

### 4.1. 没有互斥

这意味着多个进程可以同时访问一个资源。这是不可能的，因为如果多个进程同时访问同一个资源，就会出现混乱。此外，不会完成任何过程。所以这是不可行的。因此，操作系统无法避免互斥。

让我们举一个实际的例子来理解这个问题。杰克和琼斯分享一碗汤。两人都想喝同一个碗里的汤，同时用一个勺子，这是不可行的。

### 4.2. 没有等待

为了避免等待，有很多方法可以在开始执行之前获取所有需要的资源。但这也不可行，因为一个进程一次只能使用一个资源。在这里，资源利用率会非常低。

在开始执行之前，进程并不知道完成它需要多少资源。除此之外，进程完成并释放资源的总线时间也是未知的。

另一种方法是，如果一个进程正在持有资源并想要拥有额外的资源，那么它必须释放获得的资源。这样，我们可以避免保持等待状态，但会导致[饥饿](https://en.wikipedia.org/wiki/Starvation_(computer_science))。

### 4.3. 取消不可抢占

造成死锁的原因之一是没有抢占。这意味着即使进程处于等待状态，CPU 也不能强行从任何进程获取资源。如果我们可以去掉不可抢占，强行从一个等待的进程中获取资源，我们就可以避免死锁。这是避免死锁的可实现逻辑。

举个例子，就像杰克来喝汤的时候，他从琼斯手里拿过碗给杰克。让我们假设琼斯先来并获得资源并进入等待状态。现在杰克来了，管宴席的人强行从琼斯手中接过碗，并告诉他如果你处于等待状态就不要拿着碗。

### 4.4. 删除循环等待

在循环等待中，两个进程卡在等待对方已经占有的资源的状态。为了避免循环等待，我们为所有资源分配一个整数值，并且进程必须以递增或递减的顺序访问资源。

如果进程以递增顺序获取资源，则只有当该资源具有更高的整数值时，它才能访问新的附加资源。如果该资源具有较小的整数值，则它必须在获取新资源之前释放已获取的资源，反之亦然以降序排列。

例如，餐饮服务商为碗和勺子分配了一个整数值，分别为 1 和 2，以便可以按升序访问资源。现在，如果琼斯有一个碗，那么他就可以拿到勺子。但是由于杰克有一个整数值更大的勺子，他必须先离开勺子，然后再拿碗。此后，他将拿起勺子喝汤。

## 5.死锁避免

死锁避免方法帮助操作系统避免死锁的发生。在开始执行之前，OS 会维护一个进程在整个生命周期中所需的最大所需资源的日志。在将任何新请求的资源分配给任何进程之前，操作系统将不断检查系统的状态。

基本上，在避免死锁时，操作系统会尽量不处于循环等待状态。如果操作系统可以将所有请求的资源分配给进程而不会在将来引起死锁，则称为[安全状态](https://en.wikipedia.org/wiki/Banker's_algorithm)。 如果操作系统无法分配所有请求的资源而不会在未来造成死锁，则称为[不安全状态](https://en.wikipedia.org/wiki/Banker's_algorithm)。

### 5.1. 资源分配图 (RAG) 算法

使用 RAG，可以预测操作系统中死锁的发生。

资源分配图是所有已分配资源、可用资源和操作系统当前状态的图形视图。我们可以算出每个进程分配了多少资源，以后需要多少资源。这样，我们就可以很容易地避免死锁。

由于每个图都有顶点和边，以同样的方式，RAG 也有顶点和边。RAG有两个顶点：进程顶点和资源顶点，以及两条边：分配边和请求边。大多数情况下，我们用矩形表示顶点，用圆形表示边：

![D1](https://www.baeldung.com/wp-content/uploads/sites/4/2021/06/D1-1024x496.png)

RAG 算法有一个限制，它只有在所有资源都只有一个实例时才有效。如果资源的实例不止一个，则在确定死锁时将不确定。会有形成圈子的可能，但也可能会导致死锁。因此，在那种情况下，我们使用[银行家算法](https://en.wikipedia.org/wiki/Banker's_algorithm)来确定死锁。

例如，让两个进程 P1、P2 和两个资源 R1、R2：

![2d](https://www.baeldung.com/wp-content/uploads/sites/4/2021/06/2D.png)

这里P1用R1，以后会用R2，用虚线表示。目前，它是免费的。P2 正在请求 R2，但操作系统不会分配它，因为稍后 P1 将需要它。所以它会避免形成一个圆圈。因此，它避免了发生死锁的可能性。但是从上面的解决方案来看，R2是不会被使用的。因此，资源利用率会降低。

### 5.2. 银行家算法

当资源有多个实例时，我们使用银行家算法。它被称为银行家算法，因为银行遵循它以这样一种方式管理资源，以便它们永远不会用完资源并避免进入不安全状态。银行在分配或批准银行系统中的任何贷款之前使用此算法。

在这个算法中，我们需要一些预先确定的数据，例如每个进程完成生命周期所需的最大资源和操作系统中的总可用资源。从这些数据中，它会产生一个安全的序列。如果操作系统按该顺序运行所有进程，它将避免死锁的发生。

该算法维护一个矩阵，其中包含总可用资源、每个进程所需的最大资源、分配给每个进程的总资源以及当前所需资源。

## 6. 死锁检测与避免

在这种方法中，操作系统假定将来会发生死锁。所以它会每隔一段时间运行一个死锁检测机制，当它检测到死锁时，它会启动恢复方法。

操作系统的主要任务是检测死锁。我们之前已经介绍过两种检测方法。

在这里，我们使用相同的方法进行一些即兴创作：

![D2](https://www.baeldung.com/wp-content/uploads/sites/4/2021/06/D2.png)

在等待图形方法中，操作系统检查圆的形成。它在某种程度上与资源分配图 (RAG) 相同，但存在一些差异。大多数情况下，它会导致 RAG 和等待图之间的混淆。

RAG 和等待图之间的主要区别是每个图包含的顶点数。RAG 图有两个顶点：资源和进程。等待图有一个顶点：进程。

我们还可以使用 RAG 创建等待图：

![3D](https://www.baeldung.com/wp-content/uploads/sites/4/2021/06/3D-1024x482.png)

等待图没有形成一个圆圈，这意味着它不会导致系统陷入死锁。

对于多实例资源，我们使用安全算法，它使用与银行家算法相同的方法。但它没有最大所需资源矩阵。它只有三个矩阵：分配矩阵、可用矩阵和当前需求矩阵。

现在，一旦操作系统检测到死锁，它就会启动恢复方法。从死锁中恢复有两种主要方法：

![D3](https://www.baeldung.com/wp-content/uploads/sites/4/2021/06/D3-1024x496.png)

### 6.1. 乐观主义的方法

乐观主义方法的一个例子是资源和进程抢占。在这种方法中，操作系统将选择一些进程并抢占它们的资源，然后将它们分配给其他进程。因此，操作系统将尝试打破这个循环。

这种方法的一个缺点是同一进程有可能成为抢占的牺牲品。在这种情况下，进程将陷入饥饿状态。

操作系统将回滚到未发生死锁的特定安全状态的另一种方法。但是为此，操作系统必须维护一些日志，直到它处于安全状态。

这种方法的缺点之一是没有决定参数来选择流程回滚的顺序。

### 6.2. 悲观的方法

一种悲观的方法是中止所有陷入僵局的进程。这是打破死锁恢复循环的最简单方法，但也是处理死锁成本最高的方法。在这种方法中，我们杀死所有进程，操作系统将丢弃它们或稍后根据需要重新启动一部分进程。

此外，我们可以一次中止一个进程，直到我们从系统中消除死锁。

在这种方法中，操作系统一次杀死一个进程，并选择完成最少工作的进程。之后，它运行死锁检测算法来验证死锁是否恢复。如果没有恢复，那么它会一直杀死进程，直到消除死锁。

## 7.死锁无知

这是处理死锁的广泛使用的方法之一。在这种方法中，操作系统假定永远不会发生死锁。如果出现死锁情况，操作系统将重新启动系统。这种方法在面向最终用户的操作系统中非常流行。

死锁无知方法用于 Linux 和基于 Windows 的操作系统，在这些操作系统中，用户直接与系统联系。

## 八、总结

在本教程中，我们彻底讨论了操作系统中死锁的概念。我们举了一个例子来说明操作系统中死锁背后的想法。

此外，我们探索了防止、避免、检测和忽略死锁的各种方法。