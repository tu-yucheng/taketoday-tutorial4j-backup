## 1. 概述

操作系统 (OS) 进程与同一系统中运行的其他进程交互以完成一项常见任务。与其他进程交互的进程称为协作进程。

基于进程实现的[进程间通信](https://www.baeldung.com/cs/inter-process-communication)(IPC)策略，它可以与其他进程共享其地址空间或通过消息交换进行通信。在前一种技术中，控制通信至关重要，因为两个进程共享一个公共地址空间。

这种对进程通信的控制称为同步。如果没有适当的同步，进程可能会读取过时的数据或覆盖其他进程数据。

信号量和互斥量是我们可以实现同步和管理进程协调的两种机制。在本文中，我们将研究这两个同步实用程序并比较各种特性。

## 2. 理解临界区

在讨论信号量和互斥量之前，让我们了解临界区问题。

假设我们有一个包含 n 个进程的系统。这些进程中的每一个都有一段代码，进程可以在其中执行公共变量更新、表更新或写入文件。这段代码被称为进程的[临界区](https://www.baeldung.com/cs/what-is-mutex)。

### 2.1. 临界区问题的特征

临界区的本质特征是一旦一个进程开始执行它的临界区，就不允许其他进程执行它的临界区。也就是说，没有两个进程可以同时执行它们的临界区。这个临界区问题是设计一个协议，让进程可以使用协作。

每个进程都需要获得进入其临界区的权限。实现权限的代码片段称为入口部分。同样，实现临界区退出的代码片段称为退出区。

### 2.2. 临界区问题的准则

临界区问题的解决方案需要满足以下条件：

-   互斥：如果一个进程正在执行它的临界区，那么没有其他进程可以执行它的临界区
-   进展：如果没有进程正在执行他们的临界区，那么其他进程可以决定执行他们的临界区。基于解决方案和实现，选择一个可以执行其临界区的进程。显着的特征是进程有能力进入选择进程以执行其关键部分
-   有界等待：当一个进程请求其临界区入口部分和另一个进程执行其临界区的次数时，它应该有一个有界等待

## 3.互斥锁

有几种实用程序可以解决操作系统中的临界区问题。互斥 ( [mutex](https://www.baeldung.com/cs/what-is-mutex) ) 锁或 mutex 是最简单的解决方案。我们使用互斥锁来保护临界区并防止竞争条件。进程在访问其临界区之前需要获取锁，并在完成临界区执行后释放锁。

### 3.1. 互斥锁如何工作？

这两个获取和释放锁的功能通过两个函数表示——acquire() 和 release()。acquire函数获取锁，release释放锁。互斥锁有一个布尔变量，它决定锁是否可用。如果锁可用，则 acquire() 方法成功，锁被视为不可用。任何试图访问不可用锁的进程都将被阻塞，直到锁被释放。

以下伪代码显示了acquire()方法：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-df14150bf0431789378ed965d97fd550_l3.svg)

以下伪代码显示了release()方法：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-372b82ee16df62338ab1a07106ffb6ea_l3.svg)

### 3.2. 互斥体的缺点

互斥锁的主要缺点是如果锁不可用，它会让线程自旋锁。

当一个线程已获取锁并处于其临界区时，所有其他试图获取锁的线程都处于循环中，线程会定期检查锁是否可用。因此，它为锁定而旋转并浪费了本可以被其他一些线程有效使用的 CPU 周期。

这是单 CPU 机器的主要问题。自旋锁也称为忙等待，因为线程“忙”等待锁。

### 3.3. 互斥体的优点

尽管互斥锁存在自旋锁问题，但它们确实有一个优势。由于进程在 CPU 中自旋锁，它消除了进程上下文切换的需要，否则这将是必需的。

进程的上下文切换是一项耗时的操作，因为它需要在[进程控制块](https://www.baeldung.com/cs/process-control-block)(PCB) 中保存执行进程统计信息并将另一个进程重新加载到 CPU 中。在多处理器 CPU 中，一个进程可以在一个处理器内核中旋转，而另一个可以执行它们的临界区。因此，在某些情况下，持续时间较短的自旋锁比进程上下文切换更有用。

## 4.信号量

[信号量](https://www.baeldung.com/cs/semaphore)是另一种实用程序，它也提供类似于互斥锁的同步功能，但更健壮和复杂。

信号量是一个整型变量，除了初始化之外，还可以通过两个标准的原子操作——wait()和signal()来访问。wait()操作称为P， signal ( )操作称为V。

让我们看一下wait()操作：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-00069b1b7998dfb0a4f16b1876b92d07_l3.svg)

最后，让我们看一下signal()操作：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-e3576c87ede1374f51e005b0dbb5a3c4_l3.svg)

!

wait()和signal()中对信号量整数值的所有操作都是原子执行的。也就是说，一旦一个进程修改了信号量值，其他进程就不能同时修改同一个信号量值。

根据信号量S的值，它分为两类——计数信号量和二进制信号量。计数信号量的值可以在 0 到有限值之间。而二进制信号量的值可以介于 0 和 1 之间。

### 4.1. 计数信号量

计数信号量可以控制给定资源的 N 个实例。让我们用一个类比来解释计数信号量。

让我们假设有一个图书馆有三个自习室，并且有一个图书管理员拿着十把钥匙，每把钥匙代表一个不同的房间。一旦读者需要进入某个房间，他们就需要获得一把钥匙才能使用该房间。一旦读者使用完毕，他们会将房间钥匙还给图书管理员。一旦所有房间都在使用中，新的阅读器需要等到现有阅读器腾出一个房间。

在上面的例子中，资源是一个房间，它有十个实例。这些实例通过一个初始化为 10 的计数信号量进行管理。这个信号量值是通过信号量的wait()和signal()方法控制的。下图说明了这一点：

![计算信号量](https://www.baeldung.com/wp-content/uploads/sites/4/2021/03/CoutingSemaphore-1528x2048-1-764x1024.png)

### 4.2. 二进制信号量

二进制信号量有两个可能的值， 0 和1 。如果该信号量管理的资源可用，则该信号量值为1，否则设置为0，表示该资源不可用。

二进制信号量具有与互斥锁相同的功能。不支持互斥锁的系统可以利用二进制信号量来实现相同的功能。

下图说明了二进制信号量：

![二进制信号量](https://www.baeldung.com/wp-content/uploads/sites/4/2021/03/BinarySemaphore-2048x1155-1-1024x578.png)

## 5. 信号量与互斥量

下表总结了信号量和互斥锁的重要特性：

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-b57dfdce57fd98c26f1fd3b58d388478_l3.svg)

## 六，总结

在本文中，我们讨论了互斥量和信号量的各个方面。

首先，我们讨论了临界区以及使用互斥量或信号量来控制临界区执行的必要性。然后我们讨论了互斥量和信号量。

最后，我们提供了信号量和互斥量的比较。