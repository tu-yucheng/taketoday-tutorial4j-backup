## 1. 概述

当我们开始使用并行或并发编程时，通常我们遇到的第一件事是两个并发(或并行)执行试图访问同一资源(例如变量)时出现的问题。[Mutex](https://www.baeldung.com/java-mutex)是解决此问题的最简单的解决方案之一。在接下来的教程中，我们将解释它的工作原理和使用方法。

## 2.互斥解释

互斥锁解决的问题到底是什么？让我们想象一下在早上与五位开发人员和 Scrum Master 举行的 Scrum 每日会议。其中一个人正在喝咖啡，他在完全清醒之前无法说话。另一个人想回到办公桌前完成该 SQL 查询，而不是开会。其余的人(三个人)都明白会议的目的，并且很高兴谈论他们所做的事情，所以他们开始同时发言。

这最终导致混乱，没有人理解任何事情。Scrum Master 走上前，将球交给其中一位开发人员并说：“只有拿着球的人才能说话！”。从那一刻起，他们相互理解，可以迅速结束会议：

![互斥代表](https://www.baeldung.com/wp-content/uploads/sites/4/2020/08/Mutex-repr.png)

如果我们考虑一下，SM 通过在系统中定义关键部分来解决这种情况。我们理解“关键”这个词，因为如果我们没有妥善管理它，我们可以看到它会将我们引向何方。开发人员(演员)使用球作为工具来向其他可以发言的人和必须等待的人发出信号。换句话说，这个球相互排斥了开发商的发言权。这种命名是如此普遍以至于人们开始缩写：Mutex(Mutual Ex clusion)。

## 3.我们在哪里使用？

这个概念可以应用于许多不同的情况，主要目标始终是能够定义临界区：

-   多个线程通过读写访问访问共享内存
-   多个进程访问公共资源(打印机和相机)

Mutex的一种常见实现是可以获取(进入临界区)和释放(离开临界区)的锁：

![互斥流](https://www.baeldung.com/wp-content/uploads/sites/4/2020/08/Mutex-flow.png)

## 4.属性

正如我们上面所说的，关键部分保证一次只能访问一个参与者。如果我们的系统设计不当，我们最终会得到一个很大的关键部分，其中只有一个参与者可以工作，而其他参与者总是必须等待Mutex被解析。

这与顺序执行没有区别，因此我们没有通过选择并发编程获得任何性能(如果你考虑一下，我们的Scrum示例就是这样)。由此可见临界区定义的重要性。当我们设计我们的系统时，我们必须识别和本地化公共资源，以便能够从并行执行中受益。

另一个常见问题是[死锁](https://www.baeldung.com/java-deadlock-livelock)。为了好玩，我们假设 Scrum 团队决定开发人员只有在他完全完成后才传球，但他需要他的同事提供一些信息。怎么了？

-   有球的人(“Dev A”)向“Dev B”提出问题并等待答案
-   “Dev B”(没有球)知道答案，但他等待球能够说话
-   “Dev A”在他完全完成之前不能传球，他需要答案

 

![互斥死锁](https://www.baeldung.com/wp-content/uploads/sites/4/2020/08/mutex-deadlock.png)

这种情况有解决办法吗？很不幸的是，不行。我们的系统永远挂起，或者换句话说，处于死锁状态。

死锁尤其可能发生在具有多个锁的系统中。为确保你的设计无死锁，你应在每个参与者中以相同的顺序获取锁。

[22 条军规的](https://en.wikipedia.org/wiki/Catch-22_(logic))情况也表现出类似的现象。

## 5.总结

在本文中，我们总结了Mutexes的定义和属性，并了解了我们在使用它们时可能遇到的问题。重要的是要注意，有一些设计模式试图以不同于Mutex的方式解决参与者之间的交互。了解问题对于能够为其设计最佳解决方案至关重要。