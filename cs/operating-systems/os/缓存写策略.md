## 1. 概述

在本教程中，我们将了解在缓存中实现写操作的不同方法。我们将考虑每种方法的优势并讨论评估标准。

但在我们这样做之前，让我们回顾一下有关缓存的一些基础知识。

## 2.缓存

通常，缓存是一个外观组件，用于提供对某些存储的方便访问。通常，高速缓存存储速度更快且更昂贵，因此数量较少。在某些情况下，缓存存储可能属于我们设计的系统——与源存储不同。

缓存的目的是提高延迟(执行单个操作的时间间隔)和吞吐量(操作处理率)。我们可以在硬件(例如 CPU 缓存)和软件(例如页面缓存使用 RAM 来缓存来自辅助存储的数据，例如 SSD)级别上使用缓存。

如果请求的数据位于缓存存储中，则会发生缓存命中。否则，会发生高速缓存未命中。

逐出 是指我们从缓存中删除数据。这可能是因为数据未使用、体积庞大，或者我们只是认为继续存储数据效率低下。过期和未过期的数据都可能发生驱逐。

这与失效不同，后者是指我们通过直接从缓存中删除或提供在请求后从后备存储中刷新数据的方式来声明缓存中的条目无效的过程。

## 3. 写政策

缓存的写策略是执行写操作时缓存的行为。缓存的写策略在缓存公开的所有各种不同特征中起着核心作用。现在让我们来看看三项政策：

-   直写
-   绕写
-   回写

## 4.直写

假设我们设计缓存首先确保一致性。也就是说，我们希望在将响应发送回客户端之前同步更新我们的后备存储。

如果在缓存中找不到请求的条目，我们首先在缓存存储中创建一个条目：

![高速缓存 WT](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/Cache-Cache-WT-1.png)

这是最容易实现的策略，我们将其称为write-through。

## 5. 绕着写

现在，write-through 提供了最好的结果，以防我们希望很快访问写入的数据。根据我们的缓存使用模式，这可能不是真的。

如果我们不希望在不久之后进行读取操作，则缓存将被我们未使用的条目污染。为了避免缓存污染，我们可以在缓存未命中的情况下绕过缓存条目分配：

![高速缓存高速缓存 WT NA](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/Cache-Cache-WT-NA-1.png)

我们将此策略称为“write-through with no-write allocation”或write-around。

直写缓存的另一个变体是写无效策略。在这种模式下，随着写入操作直接进入后备存储，缓存数据条目在缓存命中时会失效。

## 6.回写

虽然 write-through 为我们提供了最好的一致性，但它并没有帮助我们解决写操作延迟——缓存仅在后备存储更新后才向客户端返回响应。

我们也可以利用我们的快速缓存存储来简化这一过程。为此，我们必须在更新后备存储之前返回响应。在这种情况下，后备存储更新以单独的顺序异步发生。

我们可以通过多种方式启动这样的序列——在响应返回之前、定期或集成到基于缓存条目脏状态的缓存驱逐中。对于 CPU 缓存，我们使用脏位作为状态指示器。在软件缓存中，响应返回之前的异步启动通常更可取。

我们将这种类型的策略称为回写或后写：

![高速缓存 WB](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/Cache-Cache-WB-1.png)

异步更新为我们带来了更好的响应能力以及提高吞吐量的机会，例如，使用源存储更新批处理。

除了回写更难实现之外，还可能遇到一致性问题。缓存在易失性内存中，回写完成前断电会导致数据丢失。

更微妙的问题也出现在回写实现中。考虑一下我们何时不仅通过我们的缓存实例访问源存储，还使用其他一些方式——通过另一个缓存实例或直接写入操作。尚未写入backing store的数据只有在直接写入操作完成后才能到达store。

为确保这种情况不会发生，我们必须在某种程度上保持操作顺序。我们称这种技术为事务序列化。

考虑到解决此类问题的技术集和概念本身，我们使用术语缓存一致性。

## 7. 编写分配决策

与我们修改直写策略以绕过缓存未命中缓存的方式相同，我们可以调整回写策略。这种类型的选择称为写分配：

-   写分配或写时获取是在任何后续后备存储操作之前填充缓存的决定
-   No-write allocate or no-fetch-on-write是绕过缓存并继续进行后备存储操作的决定

将 no-fetch-on-write 应用于写回可能被证明具有挑战性，具体取决于更新后备存储的序列触发器。因此，fetch-on-write 通常与 write-back 搭配使用，而 no-fetch-on-write 更常用于 write-through。

## 8. 理解权衡

无论我们是从头开始设计缓存还是打算使用众多可用缓存中的一种，我们都必须了解哪种策略最适合我们的需求。如果我们想要实现最大的一致性，我们最好使用直写。

如果我们需要为写操作提供高性能，我们可能会研究回写策略。由于回写策略可能会出现一致性问题，我们可能也想解决这些问题。

此外，我们在读/写频率和数据局部性方面的缓存访问模式可能会影响我们的策略选择和写入分配决策。

## 9.总结

在本文中，我们了解了缓存中使用的各种写入策略。

我们讨论了这个决定带来的挑战以及一些已知技术的优缺点。

最后，我们看到对于我们应该在所有地方应用的那种政策没有普遍的答案。我们的具体选择取决于需求重点、访问模式和可用资源。