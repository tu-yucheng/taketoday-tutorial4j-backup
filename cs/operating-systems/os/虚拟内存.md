## 1. 概述

虚拟内存允许[进程](https://www.baeldung.com/linux/process-memory-management)使用机器上物理上可用的更多内存。

在本教程中，我们将详细介绍虚拟内存基础知识。我们将描述两个关键的虚拟内存实现，即暂存和分页。最后，我们将比较它们。

## 2. 基础

虚拟内存将物理内存(随机存取内存，[RAM](https://www.baeldung.com/linux/ram-slots-in-use))与逻辑内存分开。它基于一个属性，即在任何时候，只有一部分过程必须放在计算机的随机存取存储器中。具体来说，进程实际使用的部分。

使用虚拟内存的系统提高了[多任务环境](https://www.baeldung.com/java-threading-models)中随机存取内存的利用率。使用虚拟内存的核心好处是：

-   能够在进程之间共享内存
-   由于内存隔离提高了安全性
-   可以使用机器上物理上可用的更多内存

虚拟内存会产生一种错觉，即进程在单个连续的内存区域中工作。而在物理上，它可以进行碎片整理、不连续，并且可以部分存储在大容量存储设备上。可以通过将物理内存中的地址映射到逻辑地址来实现。此外，逻辑地址的面积可以大于物理地址的面积。下面，我们可以看到虚拟内存的一般概念：

![编译流程示例第 2 页](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/Compilation-Flow-Example-Page-2.svg)

可以使用称为需求分段和需求分页的两种常见机制来实现虚拟内存。在下一节中，我们将详细讨论它们。

## 2.分页虚拟内存

分页虚拟内存是最常用的实现方式。通常，分页是一种允许从辅助存储存储和检索数据的技术。物理内存被分成固定大小的块，称为帧。逻辑内存被分成固定大小的块，称为页面。随后，页面和框架的大小相同。

在进程执行时，如果需要，页面会安装到适当的框架中。因此，该过程称为按需分页或按需分页：

![编译流程示例第 4 页](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/Compilation-Flow-Example-Page-4.svg)

因此仅在我们需要时才将页面加载到随机存取存储器中会带来很多好处。它减少了输入/输出操作的数量和 RAM 内存消耗。这样，大型进程的单次执行可能只需要其代码的一小部分。因此，系统的响应时间得到改善。随后，可以处理更多的用户。

当进程引用内存时，可能会发生以下情况：

-   [引用](https://www.baeldung.com/java-weak-reference)无效_
-   引用有效且存在所需页面
-   引用有效，所需页面不存在

在第一种情况下，请求被拒绝。在第二种情况下，即成功场景，请求被正确处理。在最后一种情况下，系统必须将所需的页面从磁盘调入内存。

### 2.2. 验证位

验证位是一种用于验证页面状态的硬件支持机制。为页表中的每条记录设置验证位。该位只能取两个可能的值：零或一。

最初，所有位都设置为零。这意味着该页面不存在于随机存取存储器中或引用无效。另一方面，当该位设置为 1 时，引用有效且页面存在。如果该位在地址转换期间被设置为 0，则这种情况称为页面错误，处理器会触发相应的机制，我们将在下一小节中对此进行描述。

### 2.3. 页面错误

当页面错误发生时，处理器将控制权转移给操作系统。首先，系统在磁盘上定位所需的数据。其次，它在随机存取存储器中寻找空闲帧。然后，它将页面加载到该框架中。之后，它更新页表。最后，流程继续执行。

RAM 中可能没有任何空闲帧。因此需要释放一些。存在用于提供称为[页面替换](https://www.baeldung.com/cs/fifo-page-replacement)算法的特殊服务技术。

### 2.4. 页面替换

[页面替换](https://www.baeldung.com/cs/fifo-page-replacement)过程的一般工作流程包括以下操作：

1.  在磁盘上找到所需的页面
2.  识别将从随机存取存储器中删除的帧
3.  通过将帧到磁盘来备份要删除的帧(如果还没有副本)
4.  通过将对已删除框架的引用设置为无效来更新页表
5.  将所需页面加载到释放的框架中
6.  再次更新页表

页面替换算法主要负责第二点。特定算法的选择会影响虚拟内存的性能。最佳页面替换算法仅在理论上存在。简单来说，就是交换最远以后要用到的页面。

在现实场景中，不可能实现这样的功能。虽然，还有其他算法可以或多或少有效地处理它。让我们简单介绍一下：

-   FIFO(先进先出)——替换最旧的页面
-   LRU (Least Recently Used) – 替换最长时间未使用的页面
-   LFU(最不常用)——替换最不常用的页面
-   MFU (Most Frequently Used) – 替换最常使用的页面

## 3.分段虚拟内存

第二种流行的实现是分段虚拟内存。分段是将物理内存分成称为[段](https://www.baeldung.com/cs/networking-packet-fragment-frame-datagram-segment#segment)的连续块的过程。 这些段可以具有不同的大小。因此逻辑地址由两个值表示：段号和偏移量。

段号是段表中的索引。该表中的每条记录都有一个基地址，它指的是物理内存中段的开头。而且，该段在物理内存中有一个指向该段末尾的限制值。随后，偏移量是 0 和限制之间的值。

![空白图 4](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/Blank-diagram-4.svg)

系统根据应用程序的请求创建段。它将段的索引传递给应用程序。因此，进程引用段内的内存区域。因此，他们不知道数据在这些段所指的物理内存中的位置。此外，进程无法访问其他进程的段。 

### 3.1. 段描述符

段的参数存储在称为段描述符的 8 位长记录中：

![空白图第2页](https://www.baeldung.com/wp-content/uploads/sites/4/2021/04/Blank-diagram-Page-2.svg)

描述符包括：

-   BA – 基地址，从该内存开始的段的物理地址
-   G——粒度，当为空时，限制以字节为单位描述。如果设置，限制由 4096 字节页面定义
-   D – 默认操作数大小，设置时，该段为16位代码，如果注明，该段为32位
-   B——大，同D的意思
-   L – long，如果设置，则该段为 64 位
-   AVL——可用，保留给软件使用
-   P – 存在，如果为空则产生异常
-   DPL——描述符特权级别
-   T——型
-   C – 符合，定义是否可以从权限较低的级别访问段内的代码
-   E – expand-down，如果设置，段从最大偏移量向下扩展到limit，如果为空，段从基地址向上扩展到base + limit
-   R——可读，如果为空，则该段不可读，只是执行
-   W – 可写，如果为空，则该段不可写，只能读
-   A – 已访问。当段被访问时设置为 1

这些段存储在两种类型的表中。其中第一个是 GDT(全局描述符表)。系统中只有一个GDT，它存放着所有进程的段。第二个是LDT(本地描述符表)。有许多描述各个进程段的局部描述符表。

### 3.2. 段选择器

每个描述符都有一个对应的选择器。段选择器是对特定表(GDT 或 LDT)中描述符的引用。 选择器包含以下字段：

-   特定表中段的描述符索引
-   表指示符字段通知在哪个表中定位描述符。它只能保存两个值之一：零值表示描述符在 GDT 中，值一表示 LDT
-   请求者的权限级别字段定义了安全属性，例如，哪些指令可以处理执行，并且还可以访问它不拥有的数据

因此，当进程想要访问分段内存时，首先，它指向段注册表中的段选择器。然后，特定的选择器引用 GDT 或 LDT 表中的适当描述符。最后，描述符告知在哪里可以找到所需的段。

## 4. 分页与分段

![由 QuickLaTeX.com 呈现](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-ec7daefcc8908e1737e052b7086f44d9_l3.svg)

## 5.总结

在本文中，我们详细描述了虚拟内存的概念。

有两种主要使用的基于分页或分段的实现。这两种类型有很大不同，并且各有利弊。如今，现代操作系统倾向于结合使用这两种类型来获得所有好处。