## 1. 概述

创建编程语言是为了允许开发人员编写人类可读的源代码。然而，计算机使用的是[机器码](https://en.wikipedia.org/wiki/Machine_code)，人们很难写或读。因此，编译器将编程语言的源代码翻译成专用于特定机器的机器代码。

在本文中，我们将分析编译过程的各个阶段。然后，我们将看到编译器和解释器之间的区别。最后，我们将介绍一些现代编程语言的编译器示例。

## 2.编译阶段

正如我们已经提到的，编译过程将高级源代码转换为可由目标机器执行的低级机器代码。此外，编译器的一个重要作用是通知开发人员所犯的错误，尤其是与语法相关的错误。

编译过程包括几个阶段：

1.  词法分析
2.  语法分析
3.  语义分析
4.  中间代码生成
5.  优化
6.  代码生成

在本节中，我们将详细讨论每个阶段。

### 2.1. 词法分析

编译过程的第一阶段是词法分析。在此阶段，编译器将源代码拆分为称为词素的片段。词素是特定语言词汇系统的抽象单位。我们来分析一个简单的例子：

```java
String greeting = "hello";
```

在上面的语句中，我们有五个词位：

1.  细绳
2.  问候语
3.  =
4.  “你好”
5.  ;

将代码拆分为词素后，将创建一系列标记。记号序列是词法分析的最终产物。因此，词法分析通常也称为标记化。标记是描述词素的对象。它提供了有关词素用途的信息，例如它是关键字、变量名还是字符串文字。此外，它存储了词素的源代码位置数据。

### 2.2. 语法分析

在语法分析期间，编译器使用在第一阶段生成的一系列标记。令牌用于创建称为[抽象语法树](https://www.baeldung.com/java-build-compiler-plugin#extract-ast-data)(AST) 的结构，这是一种表示程序逻辑结构的树。

在此阶段，编译器检查源代码的语法结构及其句法正确性。同时，任何语法错误都会导致编译错误，编译器会将这些错误通知开发人员。

简而言之，语法分析负责两项任务：

1.  它检查源代码是否存在任何语法错误。
2.  它生成下一阶段使用的抽象语法树。

### 2.3. 语义分析

在此阶段，编译器使用抽象语法树来检测任何语义错误，例如：

-   将错误的类型分配给变量
-   在同一范围内声明具有相同名称的变量
-   使用未声明的变量
-   使用语言的关键字作为变量名

语义分析可以分为三个步骤：

1.  类型检查——检查赋值语句、算术运算、函数和方法调用中的类型匹配。
2.  流量控制检查——调查流量控制结构是否被正确使用以及类和对象是否被正确访问。
3.  标签检查——验证标签和标识符的使用。

为了实现上述所有目标，编译器在进行语义分析时，对抽象语法树进行了一次完整的遍历。语义分析最终产生一个带注释的 AST，它描述了其属性的值。

### 2.4. 中间代码生成

在编译过程中，编译器可以生成一种或多种中间代码形式。

>   “在对源程序进行语法和语义分析之后，许多编译器会生成一个显式的低级或类似机器的中间表示，我们可以将其视为抽象机器的程序。这种中间表示应该具有两个重要的属性：它应该易于生成并且应该易于转换为目标机器。” –编译器。原则、技术和工具。第二版。阿尔弗雷德诉阿霍。哥伦比亚大学。莫妮卡·林。斯坦福大学。拉维塞西。阿瓦亚。

中间代码是机器无关的。因此，不需要为每台不同的机器配备唯一的编译器。此外，优化技术比机器代码更容易应用于中间代码。中间代码有两种表示形式：

1.  高级——类似于源语言。在这种形式下，我们可以轻松提升源代码的性能。但是，它不太适合提高目标机器的性能。
2.  Low-Level——接近机器的机器代码。它是进行与机器相关的优化的首选。

### 2.5. 优化

在优化阶段，编译器使用多种方式来提升代码的效率。当然，优化过程应遵循三个重要规则：

1.  生成的代码不能改变程序的原始含义。
2.  优化应侧重于消耗更少的资源并加快软件的运行速度。
3.  优化过程不应显着影响编译的总时间。

让我们看几个优化技术的例子：

1.  [函数内联](https://www.baeldung.com/jvm-method-inlining)——用函数体替换函数调用。
2.  死代码消除——编译器去除从未执行过的代码，或者即使执行了，也不会使用其返回结果的代码。
3.  循环融合——在一个循环中执行来自具有相同迭代条件的相邻循环的操作。
4.  指令合并——实现相似操作的指令合并为一条；例如，x = x + 10；x = x – 7; 可以用x = x + 3 代替；

### 2.6. 代码生成

最后，编译器将优化后的中间代码转换为目标机器专用的机器码。最终代码应该与源代码具有相同的含义，并且在内存和 CPU 资源使用方面是高效的。此外，代码生成过程也必须高效。

### 2.7. 实例

在下面的流程图中，我们可以看到一个简单语句的编译过程示例。

[![编译流程示例算法流程图示例](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/Compilation-Flow-Example-Algorithm-Flowchart-Example-791x1024.png)](https://www.baeldung.com/wp-content/uploads/sites/4/2020/07/Compilation-Flow-Example-Algorithm-Flowchart-Example.png)

## 3.编译器与解释器

我们已经知道，编译器将高级源代码转换为低级代码。然后，目标机器执行低级代码。另一方面，解释器直接分析和执行源代码。口译员通常使用以下几种技术之一：

1.  分析(解析)源代码并直接执行。
2.  将高级源代码转换为中间代码并立即执行。
3.  显式执行由编译器生成的存储的预编译代码。在这种情况下，编译器属于解释器系统。

让我们看一下解释器和编译器之间的简要比较：

| 编译器：                               | 口译员：                                                     |
| -------------------------------------- | ------------------------------------------------------------ |
| 1.转换代码但不执行。                   | 1.直接执行代码。                                             |
| 2. 实现编译器需要了解目标机器。        | 2. 不需要了解目标机器，因为解释器会执行代码。                |
| 3. 每条指令只翻译一次。                | 3.同一条指令可以多次分析。                                   |
| 4、编译后的程序运行速度更快。          | 4. 解释型程序运行速度较慢，但解释比编译和运行花费的时间更少。 |
| 5. 由于中间代码生成消耗更多内存。      | 5. 通常直接执行输入的代码，因此占用内存少。                  |
| 6.编译语言示例：Java、C++、Swift、C#。 | 6. 解释性语言示例：Ruby、Lisp、PHP、PowerShell。             |

## 4.编译示例

### 4.1. Javac

在 Java 中，源代码首先由[javac](https://www.baeldung.com/javac)编译器编译为字节码。然后，Java 虚拟机 (JVM) 解释并执行字节码。因此，javac 是属于解释器系统的编译器的一个很好的例子。这样的系统使 Java 具有可移植性和多平台性。

此外，还有其他语言(如 Kotlin 或 Scala)也被编译为字节码，但它们使用独特的编译器。因此，JVM 可以执行最初使用不同技术编写的代码。

### 4.2. 单核细胞增多症

[Mono](https://www.mono-project.com/)是一个工具集，包括 C# 编程语言编译器，用于执行专用于 .NET 平台的软件。它的创建是为了允许 .NET 应用程序在不同的平台上运行。此外，一个重要的目标是为在 Linux 上工作的开发人员提供更好的环境和工具来使用 .NET 平台。

编译器将 C# 源代码转换为中间字节码。之后，虚拟机执行它。C# 编译器和虚拟机都属于 Mono 工具集。

### 4.3. GNU 编译器集合

GNU 编译器集合 (GCC) 是一组属于[GNU 项目](https://www.gnu.org/gnu/thegnuproject.en.html)的开源编译器。这些编译器可以在不同的硬件和软件平台上运行。因此，他们可以为各种体系结构和操作系统生成机器代码。

在编译期间，GCC 负责处理参数、为特定编程语言调用编译器、运行汇编程序，并最终运行链接器以生成可执行二进制文件。

GCC 由多种编程语言的编译器组成：

-   C (海湾合作委员会)
-   C++ (g++)
-   目标-C(gobjc)
-   Fortran(g77 和 GFortran)
-   爪哇 (gcj)
-   那里(小昆虫)

## 5.总结

在本文中，我们描述了编译器的作用。此外，我们经历了编译过程的所有阶段。然后我们讨论了编译器和解释器之间的区别。最后，我们提到了一些真实世界的编译器示例。